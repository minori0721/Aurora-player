<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aurora Player</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.4.0/color-thief.min.js"></script>

    <style>
        :root {
            --bg-1: #e0c3fc; --bg-2: #8ec5fc;
            --text-main: #2c3e50; --text-sub: rgba(44, 62, 80, 0.6);
            --glass: rgba(255, 255, 255, 0.4);
            --glass-strong: rgba(255, 255, 255, 0.95);
            --border: rgba(255, 255, 255, 0.6);
            --accent: #2980b9;
        }

        body {
            margin: 0; height: 100vh;
            background-color: #f5f7fa;
            background-image: 
                radial-gradient(circle at 10% 20%, var(--bg-1) 0%, transparent 50%),
                radial-gradient(circle at 90% 80%, var(--bg-2) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, #fff 0%, transparent 60%);
            background-size: 150% 150%;
            animation: bgMove 15s infinite alternate;
            color: var(--text-main); font-family: 'Segoe UI', sans-serif;
            overflow: hidden; display: flex; justify-content: center; align-items: center;
            transition: --bg-1 1s, --bg-2 1s;
        }
        @keyframes bgMove { 0% { background-position: 0% 0%; } 100% { background-position: 100% 100%; } }

        #visual-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none; }

        .top-bar { position: absolute; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; z-index: 100; }
        .tool-group { display: flex; gap: 10px; }
        .glass-btn {
            background: var(--glass); backdrop-filter: blur(10px); border: 1px solid var(--border);
            padding: 8px 15px; border-radius: 20px; cursor: pointer; font-size: 0.9rem; color: var(--text-main);
            display: flex; align-items: center; gap: 5px; transition: 0.2s; outline: none; white-space: nowrap;
        }
        .glass-btn:hover { background: #fff; transform: translateY(-2px); }

        /* é€šç”¨é¢æ¿æ ·å¼ */
        .panel-float {
            position: absolute; top: 70px; right: 20px; background: var(--glass-strong); padding: 20px; border-radius: 15px;
            border: 1px solid var(--border); width: 320px; 
            transform: translateX(120%); transition: transform 0.3s cubic-bezier(0.19, 1, 0.22, 1);
            z-index: 90; box-shadow: 0 10px 30px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 12px;
        }
        .panel-float.show { transform: translateX(0); }
        
        .panel-row { display: flex; align-items: center; justify-content: space-between; font-size: 0.9rem; }
        .panel-input { width: 80px; border: 1px solid #ccc; border-radius: 5px; padding: 4px; text-align: center; font-family: monospace; }
        .panel-title { margin: 0; border-bottom: 1px solid rgba(0,0,0,0.1); padding-bottom: 10px; font-size: 1rem; font-weight: bold; position: relative; }
        
        /* é¢æ¿å…³é—­æŒ‰é’® */
        .panel-close {
            position: absolute; right: 0; top: 50%; transform: translateY(-50%);
            background: none; border: none; font-size: 1.5rem; color: var(--text-sub);
            cursor: pointer; padding: 0 5px; line-height: 1; display: none;
        }
        .panel-close:hover { color: var(--text-main); }

        /* åˆ†æé¢æ¿ç‰¹åˆ«æ ·å¼ */
        #analyze-panel { right: 350px; width: 300px; } /* æ”¾åœ¨å¾ªç¯é¢æ¿å·¦è¾¹ */
        #analyze-panel:not(.show) { transform: translateX(calc(100% + 370px)); } /* ç¡®ä¿èƒ½å®Œå…¨æ»‘å‡ºå±å¹• */
        .analyze-btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 5px; }
        .big-btn { width: 100%; justify-content: center; background: var(--accent); color: white; border: none; }
        .big-btn:hover { background: #1a5276; }

        .main-container { width: 85vw; height: 80vh; display: grid; grid-template-columns: 450px 1fr; gap: 80px; position: relative; z-index: 10; }
        .left-panel { display: flex; flex-direction: column; justify-content: center; position: relative; }
        .cover-wrapper { width: 100%; padding-bottom: 100%; position: relative; margin-bottom: 40px; filter: drop-shadow(0 20px 30px rgba(0,0,0,0.1)); }
        .default-disc {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 50%;
            background: conic-gradient(from 0deg, #e0e0e0, #ffffff, #e0e0e0, #d0d0d0, #ffffff, #e0e0e0);
            box-shadow: inset 0 0 0 5px rgba(255,255,255,0.8); display: flex; justify-content: center; align-items: center;
            animation: spin 10s linear infinite paused;
        }
        .default-disc::after { content:''; width:20%; height:20%; background:#f5f7fa; border-radius:50%; border:5px solid rgba(255,255,255,0.5); }
        .playing .default-disc { animation-play-state: running; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .album-img { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; border-radius: 20px; opacity: 0; transition: opacity 0.5s; }
        
        .progress-section { margin-top: auto; }
        .time-display { font-size: 0.9rem; color: var(--text-sub); margin-bottom: 12px; font-weight: 500; display: flex; justify-content: space-between;}
        .progress-bar-bg { width: 100%; height: 8px; background: rgba(0,0,0,0.05); border-radius: 4px; position: relative; cursor: pointer; transition: height 0.2s; overflow: visible;}
        .progress-bar-bg:hover { height: 12px; }
        .progress-line { position: absolute; top: 0; left: 0; width: 0%; height: 100%; background: var(--text-main); border-radius: 4px; }
        .buffer-line { position: absolute; top: 0; left: 0; width: 0%; height: 100%; background: rgba(255,255,255,0.6); border-radius: 4px; transition: width 0.2s; }
        
        .loop-marker { 
            position: absolute; top: -6px; width: 2px; height: 20px; background: #e74c3c; 
            z-index: 20; pointer-events: none; display: none; box-shadow: 0 0 5px rgba(231, 76, 60, 0.5);
        }
        .loop-marker::after { content: attr(data-label); position: absolute; top: -15px; left: -50%; color: #e74c3c; font-size: 10px; font-weight: bold; }

        .right-panel { display: flex; flex-direction: column; justify-content: center; position: relative; }
        .track-header { margin-bottom: 20px; }
        .track-title { font-size: 3rem; font-weight: 800; margin: 0 0 10px 0; line-height: 1.1; }
        .track-artist { font-size: 1.2rem; color: var(--text-sub); font-weight: 500; }
        
        .lyrics-box { 
            height: 350px; overflow: hidden; margin-bottom: 30px; position: relative; 
            padding-left: 20px;
            mask-image: linear-gradient(to bottom, transparent, black 15%, black 85%, transparent); 
            -webkit-mask-image: linear-gradient(to bottom, transparent, black 15%, black 85%, transparent); 
        }
        .lyrics-scroll { transition: transform 0.3s ease-out; width: 100%; text-align: left; }
        .lyric-line { font-size: 1.1rem; color: var(--text-sub); margin: 14px 0; cursor: pointer; opacity: 0.6; transition: 0.2s; line-height: 1.4; }
        .lyric-line.active { color: var(--text-main); font-size: 1.4rem; font-weight: 800; opacity: 1; transform-origin: left center; }

        .controls-row { display: flex; align-items: center; justify-content: flex-start; gap: 25px; padding-top: 20px; }
        .btn { background: var(--glass); backdrop-filter: blur(10px); border: 1px solid var(--border); color: var(--text-main); cursor: pointer; width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: 0.2s; position: relative; }
        .btn:hover { background: #fff; transform: translateY(-3px); }
        .btn svg { width: 20px; height: 20px; fill: currentColor; }
        .btn-play { width: 70px; height: 70px; background: var(--text-main); color: #fff; }
        .btn-play:hover { background: #000; }

        .playlist-sidebar { position: fixed; right: 0; top: 0; bottom: 0; width: 320px; background: var(--glass-strong); backdrop-filter: blur(30px); box-shadow: -10px 0 40px rgba(0,0,0,0.05); transform: translateX(100%); transition: transform 0.4s; z-index: 95; padding: 80px 30px 30px 30px; overflow-y: auto; }
        .playlist-sidebar.show { transform: translateX(0); }
        .pl-item { padding: 12px; border-radius: 8px; cursor: pointer; font-size: 0.95rem; color: var(--text-sub); margin-bottom: 5px; display: flex; align-items: center; }
        .pl-item:hover { background: rgba(0,0,0,0.05); }
        .pl-item.active { background: #fff; color: var(--text-main); font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.05); }

        .drag-mask { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.9); z-index: 999; display: flex; flex-direction: column; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: 0.3s; }
        body.drag-on .drag-mask { opacity: 1; pointer-events: all; }
        .loading-tip { position: absolute; bottom: 20px; font-size: 0.8rem; color: #2980b9; display: none; font-weight: bold; }
        .tag-source { font-size: 0.7rem; padding: 2px 6px; border-radius: 4px; background: rgba(0,0,0,0.1); margin-left: 10px; vertical-align: middle;}

        #debug-console {
            position: fixed; top: 70px; left: 20px; width: 350px; max-height: 200px;
            background: rgba(0,0,0,0.85); color: #0f0; font-family: monospace; font-size: 11px;
            overflow-y: auto; z-index: 9999; padding: 10px; border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); pointer-events: all;
            display: none; border: 1px solid rgba(255,255,255,0.2);
        }
        .log-warn { color: yellow; } .log-err { color: #ff5555; font-weight: bold; } .log-suc { color: #55ff55; font-weight: bold; }

        .vol-container { position: relative; display: flex; align-items: center; justify-content: center; }
        .vol-popup {
            position: absolute; bottom: 65px; left: 50%; transform: translateX(-50%);
            width: 40px; height: 120px;
            background: var(--glass-strong); backdrop-filter: blur(10px);
            border-radius: 20px; border: 1px solid var(--border);
            display: flex; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: all 0.3s cubic-bezier(0.19, 1, 0.22, 1);
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }
        .vol-popup.show { opacity: 1; pointer-events: all; bottom: 70px; }
        input[type=range].vol-range {
            writing-mode: vertical-lr; direction: rtl;
            width: 8px; height: 90px; background: rgba(0,0,0,0.1);
            cursor: pointer; accent-color: var(--text-main);
        }

        /* é«˜çº§èœå• */
        .advanced-menu-container { position: relative; }
        .advanced-menu {
            position: absolute; top: 45px; right: 0;
            background: var(--glass-strong); backdrop-filter: blur(20px);
            border-radius: 12px; border: 1px solid var(--border);
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            min-width: 140px; padding: 8px 0;
            opacity: 0; pointer-events: none; transform: translateY(-10px);
            transition: all 0.2s ease;
            z-index: 9999;
        }
        .advanced-menu.show { opacity: 1; pointer-events: all; transform: translateY(0); }
        .advanced-menu-item {
            display: block; width: 100%; padding: 10px 15px;
            background: none; border: none; text-align: left;
            font-size: 0.85rem; color: var(--text-main); cursor: pointer;
            transition: background 0.15s;
        }
        .advanced-menu-item:hover { background: rgba(0,0,0,0.05); }
        .advanced-menu-item:active { background: rgba(0,0,0,0.1); }
        
        /* æ¡Œé¢ç«¯éšè—é«˜çº§æŒ‰é’® */
        .mobile-only { display: none; }
        .desktop-only { display: flex; }

        /* ========== ç§»åŠ¨ç«¯å“åº”å¼ ========== */
        @media screen and (max-width: 900px) {
            html, body { 
                overflow-x: hidden; 
                overflow-y: auto;
                height: auto; 
                min-height: 100vh;
                max-width: 100vw;
            }
            
            .main-container {
                width: 100%; height: auto;
                grid-template-columns: 1fr; gap: 15px;
                padding: 70px 15px 100px 15px;
                box-sizing: border-box;
            }
            
            .left-panel { order: 1; }
            .right-panel { order: 2; }
            
            .cover-wrapper { 
                width: 55vw; max-width: 250px; padding-bottom: 55vw; 
                margin: 0 auto 15px auto; 
            }
            
            .progress-section { padding: 0; }
            
            .track-header { text-align: center; padding: 0 10px; }
            .track-title { font-size: 1.5rem; word-break: break-word; }
            .track-artist { font-size: 0.95rem; }
            
            .lyrics-box { 
                height: 180px; padding: 0 10px;
                mask-image: linear-gradient(to bottom, transparent, black 10%, black 90%, transparent);
                -webkit-mask-image: linear-gradient(to bottom, transparent, black 10%, black 90%, transparent);
            }
            .lyric-line { font-size: 0.9rem; margin: 8px 0; text-align: center; }
            .lyric-line.active { font-size: 1.1rem; }
            .lyrics-scroll { text-align: center; }
            
            .controls-row { justify-content: center; gap: 12px; padding: 10px 0; }
            .btn { width: 42px; height: 42px; }
            .btn svg { width: 16px; height: 16px; }
            .btn-play { width: 56px; height: 56px; }
            
            /* é¡¶éƒ¨å·¥å…·æ  - ç§»åŠ¨ç«¯é‡æ–°å¸ƒå±€ */
            .top-bar { 
                top: 8px; left: 8px; right: 8px;
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                gap: 5px;
                overflow: visible;
            }
            .tool-group { 
                gap: 5px; 
                flex-wrap: nowrap;
                overflow: visible;
            }
            .tool-group::-webkit-scrollbar { display: none; }
            .glass-btn { 
                padding: 5px 8px; font-size: 0.7rem; 
                border-radius: 12px;
                flex-shrink: 0;
            }
            /* ç§»åŠ¨ç«¯éšè—éƒ¨åˆ†æŒ‰é’®æ–‡å­—ï¼Œåªæ˜¾ç¤ºå›¾æ ‡ */
            .glass-btn .btn-text { display: none; }
            
            /* é¢æ¿ */
            .panel-float { 
                position: fixed;
                top: auto; bottom: 0; left: 0; right: 0;
                width: 100%; max-width: 100%;
                border-radius: 20px 20px 0 0;
                max-height: 70vh; overflow-y: auto;
                transform: translateY(100%);
                box-sizing: border-box;
            }
            .panel-float.show { transform: translateY(0); }
            
            /* ç§»åŠ¨ç«¯æ˜¾ç¤ºå…³é—­æŒ‰é’® */
            .panel-close { display: block; }
            
            #analyze-panel { 
                position: fixed;
                top: auto; bottom: 0; left: 0; right: 0;
                width: 100%;
            }
            #analyze-panel:not(.show) { transform: translateY(100%); }
            
            .playlist-sidebar { 
                width: 100%; max-width: 100%; 
                padding: 60px 15px 15px 15px; 
                box-sizing: border-box;
            }
            
            #debug-console { 
                position: fixed;
                width: calc(100% - 20px); left: 10px; right: 10px;
                top: auto; bottom: 10px; max-height: 120px;
            }
            
            .vol-popup { bottom: 50px; }
            .vol-popup.show { bottom: 55px; }
            
            /* æ‹–æ‹½é®ç½© */
            .drag-mask h1 { font-size: 1.5rem; }
            .drag-mask p { font-size: 0.9rem; }
            
            /* ç§»åŠ¨ç«¯ï¼šæ˜¾ç¤ºé«˜çº§æŒ‰é’®ï¼Œéšè—åŸæ¥çš„ä¸‰ä¸ª */
            .mobile-only { display: block; }
            .desktop-only { display: none !important; }
            .advanced-menu { right: 0; left: auto; }
        }
        
        /* è¶…å°å±å¹• */
        @media screen and (max-width: 400px) {
            .main-container { padding: 60px 10px 90px 10px; }
            .cover-wrapper { width: 60vw; padding-bottom: 60vw; max-width: 220px; }
            .track-title { font-size: 1.3rem; }
            .glass-btn { padding: 4px 6px; font-size: 0.65rem; }
            .controls-row { gap: 10px; }
            .btn { width: 38px; height: 38px; }
            .btn-play { width: 50px; height: 50px; }
            .lyrics-box { height: 150px; }
        }
    </style>
</head>
<body id="body">
    
    <div id="debug-console"><div>> Debugger Ready.</div></div>
    <canvas id="visual-canvas"></canvas>
    <div class="drag-mask"><h1>æŠ•å–‚éŸ³ä¹</h1><p>MP3 / FLAC / OGG / SLI</p></div>

    <div class="top-bar">
        <div class="tool-group">
            <button id="btn-import" class="glass-btn mobile-only" title="å¯¼å…¥éŸ³ä¹æ–‡ä»¶">ğŸ“‚ å¯¼å…¥</button>
            <input type="file" id="file-input" multiple accept="audio/*,.lrc,.sli" style="display:none">
            <button id="toggle-netease" class="glass-btn" title="è‡ªåŠ¨ä»ç½‘æ˜“äº‘æœç´¢æ­Œè¯">â˜ï¸ äº‘è¯</button>
            <select id="effect-select" class="glass-btn">
                <option value="none">âœ¨ æ— ç‰¹æ•ˆ</option>
                <option value="snow">â„ï¸ å‡›å†¬é£é›ª</option>
                <option value="bars">ğŸ“Š å¾‹åŠ¨é¢‘è°±</option>
                <option value="waves">ğŸŒŠ æå…‰æ³¢æµª</option>
            </select>
            <button id="toggle-debug" class="glass-btn desktop-only">ğŸ Debug</button>
        </div>
        <div class="tool-group">
            <button id="toggle-analyze" class="glass-btn desktop-only">ğŸ” æ™ºèƒ½åˆ†æ</button>
            <button id="toggle-loop-panel" class="glass-btn desktop-only">ğŸ” å¾ªç¯è®¾å®š</button>
            <button id="toggle-list" class="glass-btn">ğŸ“œ åˆ—è¡¨</button>
            <!-- ç§»åŠ¨ç«¯é«˜çº§èœå• -->
            <div class="advanced-menu-container mobile-only">
                <button id="toggle-advanced" class="glass-btn">âš™ï¸ é«˜çº§</button>
                <div class="advanced-menu" id="advanced-menu">
                    <button class="advanced-menu-item" data-action="debug">ğŸ Debug</button>
                    <button class="advanced-menu-item" data-action="analyze">ğŸ” æ™ºèƒ½åˆ†æ</button>
                    <button class="advanced-menu-item" data-action="loop">ğŸ” å¾ªç¯è®¾å®š</button>
                </div>
            </div>
        </div>
    </div>

    <div class="panel-float" id="analyze-panel">
        <h4 class="panel-title">Loop Analyzer (æ™ºèƒ½å¯¹é½åˆ†æ)<button class="panel-close" onclick="this.closest('.panel-float').classList.remove('show')">&times;</button></h4>
        <div style="font-size:0.8rem; color:#666; margin-bottom:10px;">
            ä¸çŸ¥é“åœ¨å“ªé‡Œè®¾ç½®å¾ªç¯ç‚¹ï¼Ÿè¯•è¯•æ™ºèƒ½åˆ†æï¼<br>
            1. ç²—ç•¥è®¾ç½® A/B ç‚¹ (å‰åè¯¯å·®<2s)<br>
            2. ç‚¹å‡»â€œå¼€å§‹åŒ¹é…â€ä¼šè‡ªåŠ¨å¯»æ‰¾æœ€ä½³æ¥ç¼å“¦ï¼
        </div>
        <div class="panel-row">
            <span>Rough Start (A)</span>
            <input type="number" id="ana-start" class="panel-input" step="0.1" placeholder="0.0">
        </div>
        <div class="panel-row">
            <span>Rough End (B)</span>
            <input type="number" id="ana-end" class="panel-input" step="0.1" placeholder="0.0">
        </div>
        
        <div class="analyze-btn-group">
            <button class="glass-btn" onclick="capturePoint('a')">ğŸ“ å®šä½ A</button>
            <button class="glass-btn" onclick="capturePoint('b')">ğŸ“ å®šä½ B</button>
        </div>
        <div class="analyze-btn-group">
            <button class="glass-btn" onclick="previewPoint('a')">ğŸ”Š è¯•å¬ A</button>
            <button class="glass-btn" onclick="previewPoint('b')">ğŸ”Š è¯•å¬ B</button>
        </div>
        
        <button class="glass-btn big-btn" onclick="runAnalysis()" style="margin-top:10px;">âœ¨ å¼€å§‹ç²¾ç¡®åŒ¹é…</button>
        <button class="glass-btn big-btn" onclick="exportSLI()" style="margin-top:8px; background:#27ae60;">ğŸ’¾ å¯¼å‡º .sli æ–‡ä»¶</button>
        <div id="ana-msg" style="font-size:0.75rem; text-align:center; min-height:1.2em; margin-top:5px;"></div>
    </div>

    <div class="loop-panel panel-float" id="loop-panel">
        <h4 class="panel-title">Loop Controller<button class="panel-close" onclick="this.closest('.panel-float').classList.remove('show')">&times;</button></h4>
        <div class="panel-row"><span>å¼€å¯å¾ªç¯</span><input type="checkbox" id="loop-enable"></div>
        <div class="panel-row" style="background:rgba(0,0,0,0.05); padding:5px; border-radius:5px;"><span title="ä¿®æ­£é‡‡æ ·ç‡">Base Rate (Hz)</span><input type="number" id="base-rate" class="panel-input" value="44100" step="100"></div>
        <div class="panel-row"><span>Start (A)</span><input type="number" id="loop-start" class="panel-input" step="0.001" value="0"></div>
        <div class="panel-row"><span>End (B)</span><input type="number" id="loop-end" class="panel-input" step="0.001" value="0"></div>
        <div style="display:flex; gap:10px; margin-top:5px;">
            <button class="glass-btn" style="flex:1; justify-content:center;" onclick="setLoopPoint('a')">Set A</button>
            <button class="glass-btn" style="flex:1; justify-content:center;" onclick="setLoopPoint('b')">Set B</button>
        </div>
        <div id="loop-msg" style="font-size:0.7rem; color:green; height:15px; text-align:right;"></div>
    </div>

    <div class="playlist-sidebar" id="playlist-sidebar"><h3 style="margin-top:0;">PLAYLIST</h3><div id="pl-container"></div></div>

    <div class="main-container">
        <div class="left-panel">
            <div class="cover-wrapper" id="cover-wrap">
                <div class="default-disc"></div>
                <img src="" class="album-img" id="album-img" crossorigin="anonymous">
                <div class="loading-tip" id="loading-tip">Decoding Audio...</div>
            </div>
            <div class="progress-section">
                <div class="time-display">
                    <span id="curr-time">00:00</span>
                    <span id="loop-status" style="color:#e74c3c; display:none; font-weight:bold; font-size:0.8rem">âˆ SEAMLESS</span>
                    <span id="total-time">00:00</span>
                </div>
                <div class="progress-bar-bg" id="prog-bg">
                    <div class="buffer-line" id="buffer-line"></div>
                    <div class="progress-line" id="prog-line"></div>
                    <div class="loop-marker" id="marker-a" data-label="A"></div>
                    <div class="loop-marker" id="marker-b" data-label="B"></div>
                </div>
            </div>
        </div>

        <div class="right-panel">
            <div class="track-header">
                <div class="track-title" id="track-title">Aurora Player</div>
                <div class="track-artist" id="track-artist">System Ready</div>
            </div>
            <div class="lyrics-box" id="lyrics-box">
                <div class="lyrics-scroll" id="lyrics-content"><div class="lyric-line active" style="margin-top: 100px;">Ready.</div></div>
            </div>
            <div class="controls-row">
                <button class="btn" id="mode-btn"><svg id="icon-list-loop" viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/></svg><svg id="icon-random" style="display:none" viewBox="0 0 24 24"><path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/></svg><svg id="icon-single" style="display:none" viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4zm-4-2V9h-1l-2 1v1h1.5v4H13z"/></svg></button>
                <button class="btn" id="prev-btn"><svg viewBox="0 0 24 24"><path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/></svg></button>
                <button class="btn btn-play" id="play-btn"><svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></button>
                <button class="btn" id="next-btn"><svg viewBox="0 0 24 24"><path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/></svg></button>
                <div class="vol-container">
                    <div class="vol-popup" id="vol-popup"><input type="range" class="vol-range" id="vol-range" min="0" max="1" step="0.01" value="1"></div>
                    <button class="btn" id="vol-btn" title="Volume"><svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg></button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const debugConsole = document.getElementById('debug-console');
        function log(msg, type='') {
            console.log(msg);
            const div = document.createElement('div');
            div.className = `log-item ${type==='error'?'log-err':(type==='success'?'log-suc':'')}`;
            div.textContent = `> ${msg}`;
            debugConsole.appendChild(div);
            debugConsole.scrollTop = debugConsole.scrollHeight;
        }

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let actx = new AudioContext();
        let audioBuffer = null, sourceNode = null, gainNode = actx.createGain(), analyser = actx.createAnalyser();
        gainNode.connect(analyser); analyser.connect(actx.destination); analyser.fftSize = 512;

        let playbackState = { startTime: 0, pauseTime: 0, isPlaying: false, duration: 0 };
        let playlist = [], curIdx = -1, playMode = 0;
        let lyrics = [], isSyncedLyrics = true;
        let neteaseSearchEnabled = false; // ç½‘æ˜“äº‘æ­Œè¯æœç´¢å¼€å…³ï¼Œé»˜è®¤å…³é—­
        let loopState = { active: false, start: 0, end: 0 };
        let particles = [];

        const el = {
            img: document.getElementById('album-img'), coverWrap: document.getElementById('cover-wrap'),
            title: document.getElementById('track-title'), artist: document.getElementById('track-artist'),
            lyricBox: document.getElementById('lyrics-content'),
            progBg: document.getElementById('prog-bg'), progLine: document.getElementById('prog-line'), bufferLine: document.getElementById('buffer-line'),
            currTime: document.getElementById('curr-time'), totalTime: document.getElementById('total-time'),
            plContainer: document.getElementById('pl-container'), playBtn: document.getElementById('play-btn'),
            effectSel: document.getElementById('effect-select'), canvas: document.getElementById('visual-canvas'),
            loopPanel: document.getElementById('loop-panel'), loopStart: document.getElementById('loop-start'), loopEnd: document.getElementById('loop-end'), loopEnable: document.getElementById('loop-enable'),
            baseRateInput: document.getElementById('base-rate'), loopMsg: document.getElementById('loop-msg'),
            markerA: document.getElementById('marker-a'), markerB: document.getElementById('marker-b'),
            modeBtn: document.getElementById('mode-btn'), loadTip: document.getElementById('loading-tip'),
            volBtn: document.getElementById('vol-btn'), volPopup: document.getElementById('vol-popup'), volRange: document.getElementById('vol-range'),
            // Analyze UI
            anaPanel: document.getElementById('analyze-panel'), anaStart: document.getElementById('ana-start'), anaEnd: document.getElementById('ana-end'), anaMsg: document.getElementById('ana-msg')
        };
        const colorThief = new ColorThief();
        const canvasCtx = el.canvas.getContext('2d');

        // --- æ ¸å¿ƒï¼šè‡ªåŠ¨æ³¢å½¢åŒ¹é…ç®—æ³• (å‡çº§ç‰ˆï¼šMSE + è¿‡é›¶ç‚¹ä¼˜åŒ–) ---
        function runAnalysis() {
            if (!audioBuffer) { el.anaMsg.textContent = "Please load audio first!"; return; }
            
            const roughA = parseFloat(el.anaStart.value);
            const roughB = parseFloat(el.anaEnd.value);
            if (isNaN(roughA) || isNaN(roughB) || roughB <= roughA) {
                el.anaMsg.textContent = "Invalid range (A must < B)"; return;
            }

            el.anaMsg.textContent = "Analyzing... (This may take a moment)";
            el.anaMsg.style.color = "var(--accent)";

            requestAnimationFrame(() => {
                setTimeout(() => {
                    try {
                        // å°è¯•ä¸‰æ¬¡ï¼šåŸå§‹Bç‚¹ã€B+0.1sã€B-0.1s
                        const attempts = [
                            { bOffset: 0, label: "åŸå§‹" },
                            { bOffset: 0.1, label: "B+0.1s" },
                            { bOffset: -0.1, label: "B-0.1s" }
                        ];
                        
                        let bestResult = null;
                        let bestConfidence = 0;
                        let bestLabel = "";
                        
                        for (const attempt of attempts) {
                            const adjustedB = roughB + attempt.bOffset;
                            if (adjustedB <= roughA) continue; // è·³è¿‡æ— æ•ˆèŒƒå›´
                            
                            const result = findBestMatch(audioBuffer, roughA, adjustedB);
                            if (result) {
                                const confidence = Math.max(0, (1 - result.diff) * 100);
                                log(`å°è¯• ${attempt.label}: ç½®ä¿¡åº¦ ${confidence.toFixed(1)}%`);
                                
                                // å¦‚æœç½®ä¿¡åº¦ >= 99%ï¼Œç«‹å³é‡‡ç”¨
                                if (confidence >= 99) {
                                    bestResult = result;
                                    bestConfidence = confidence;
                                    bestLabel = attempt.label;
                                    break; // æ‰¾åˆ°æ»¡æ„ç»“æœï¼Œåœæ­¢å°è¯•
                                }
                                
                                // è®°å½•æœ€ä½³ç»“æœ
                                if (confidence > bestConfidence) {
                                    bestResult = result;
                                    bestConfidence = confidence;
                                    bestLabel = attempt.label;
                                }
                            }
                        }
                        
                        // åˆ¤æ–­æœ€ç»ˆç»“æœ
                        if (bestResult && bestConfidence >= 99) {
                            applyLoop(bestResult.start, bestResult.end);
                            el.anaMsg.textContent = `âœ¨ æ¬¸å˜¿å˜¿ æ‰¾åˆ°äº†! [${bestLabel}] (ç½®ä¿¡åº¦: ${bestConfidence.toFixed(1)}%)`;
                            el.anaMsg.style.color = "#27ae60";
                            log(`Auto-Loop: ${bestResult.start.toFixed(4)}s -> ${bestResult.end.toFixed(4)}s`, 'success');
                        } else if (bestResult) {
                            el.anaMsg.textContent = `âŒ å¥½åƒä¸å¯¹å“¦ï¼Ÿ (æœ€é«˜: ${bestConfidence.toFixed(1)}% < 99%). è¯·å†è°ƒæ•´ A/B ç‚¹è¯•è¯•å§ï¼`;
                            el.anaMsg.style.color = "#e74c3c";
                            log(`All attempts failed. Best: ${bestConfidence.toFixed(1)}%`, 'error');
                        } else {
                            el.anaMsg.textContent = "Could not find a seamless match nearby.";
                            el.anaMsg.style.color = "#e74c3c";
                        }
                    } catch (e) {
                        el.anaMsg.textContent = "Error: " + e.message;
                        console.error(e);
                    }
                }, 50);
            });
        }

        /**
         * å¯»æ‰¾æœ€ä½³å¾ªç¯ç‚¹ (æ”¹è‰¯ç‰ˆ)
         * 1. ç²—ç•¥æœç´¢ï¼šä½¿ç”¨å‡æ–¹å·® (MSE) æ‰¾åˆ°æ³¢å½¢æœ€ç›¸ä¼¼çš„ä½ç½®
         * 2. ç²¾ç»†è°ƒæ•´ï¼šå¯»æ‰¾æœ€è¿‘çš„"è¿‡é›¶ç‚¹ (Zero Crossing)"ï¼Œæ¶ˆé™¤çˆ†éŸ³
         */
        function findBestMatch(buffer, timeA, timeB) {
            const chan0 = buffer.getChannelData(0); 
            // å¦‚æœæ˜¯åŒå£°é“ï¼Œå–ä¸¤ä¸ªå£°é“å¹³å‡å€¼è¿›è¡Œåˆ†æï¼Œæ•ˆæœæ›´å‡†
            let data = chan0;
            if (buffer.numberOfChannels > 1) {
                const chan1 = buffer.getChannelData(1);
                data = new Float32Array(chan0.length);
                for(let i=0; i<chan0.length; i++) data[i] = (chan0[i] + chan1[i]) / 2;
            }

            const sr = buffer.sampleRate;
            
            // å‚æ•°è®¾å®š
            const searchRadius = 3.0; // æœç´¢åŠå¾„æ‰©å¤§åˆ° 3ç§’
            const windowSize = Math.floor(0.15 * sr); // åŒ¹é…çª—å£ 150ms (è¶³å¤Ÿè¯†åˆ«èŠ‚å¥)
            
            const centerB = Math.floor(timeB * sr);
            const centerA = Math.floor(timeA * sr);

            // 1. å®šä¹‰ B ç‚¹çš„ç‰¹å¾æ¨¡æ¿ (å– B ç‚¹ä¹‹å‰çš„ä¸€æ®µå£°éŸ³)
            const templateStart = centerB - windowSize;
            
            // è¾¹ç•Œæ£€æŸ¥
            if (templateStart < 0 || centerB >= data.length) throw new Error("End point out of bounds");
            
            // A ç‚¹æœç´¢èŒƒå›´
            const startIdx = Math.max(0, centerA - Math.floor(searchRadius * sr));
            const endIdx = Math.min(centerB - windowSize * 2, centerA + Math.floor(searchRadius * sr));

            // --- é˜¶æ®µ 1: ç²—ç•¥ MSE æ‰«æ (è·³æ­¥æ‰«æä»¥æå‡é€Ÿåº¦) ---
            let bestOffset = -1;
            let minDiff = Infinity;
            const step = 4; // ç²¾åº¦æ­¥é•¿

            for (let i = startIdx; i < endIdx; i += step) {
                let diff = 0;
                // ä¼˜åŒ–ï¼šåªå¯¹æ¯”éƒ¨åˆ†é‡‡æ ·ç‚¹ä¼°ç®—ç›¸ä¼¼åº¦ï¼Œæå¤§æå‡æ€§èƒ½
                for (let j = 0; j < windowSize; j += 10) { 
                    const delta = data[i + j] - data[templateStart + j];
                    diff += delta * delta;
                    // å¦‚æœå·®å¼‚å·²ç»å¤§äºå½“å‰æœ€å°å€¼ï¼Œæå‰æ”¾å¼ƒ (å‰ªæä¼˜åŒ–)
                    if (diff > minDiff) break;
                }
                
                if (diff < minDiff) {
                    minDiff = diff;
                    bestOffset = i;
                }
            }

            // --- é˜¶æ®µ 2: å±€éƒ¨ç²¾ç»†ä¼˜é€‰ (é€ç‚¹æ‰«æ) ---
            let fineBest = bestOffset;
            let fineMinDiff = Infinity;
            const fineRange = 200; // åœ¨ç²—ç•¥ç‚¹å‰å 200 é‡‡æ ·å†…ç²¾ç»†æ‰¾

            for (let i = bestOffset - fineRange; i <= bestOffset + fineRange; i++) {
                let diff = 0;
                for (let j = 0; j < windowSize; j += 2) { // æé«˜é‡‡æ ·å¯†åº¦
                    const delta = data[i + j] - data[templateStart + j];
                    diff += delta * delta;
                }
                if (diff < fineMinDiff) {
                    fineMinDiff = diff;
                    fineBest = i;
                }
            }

            // è®¡ç®— A ç‚¹ä½ç½®
            let refinedA = fineBest + windowSize; 

            // è®¡ç®—å½’ä¸€åŒ–å·®å¼‚åº¦
            const normalizedDiff = fineMinDiff / (windowSize / 2);
            
            return { 
                start: refinedA / sr, 
                end: timeB,
                diff: normalizedDiff 
            };
        }

        // è¾…åŠ©ï¼šæ•è·å½“å‰æ’­æ”¾æ—¶é—´
        function capturePoint(type) {
            const t = getCurrentTime();
            if(type === 'a') el.anaStart.value = t.toFixed(3);
            else el.anaEnd.value = t.toFixed(3);
        }
        
        // è¾…åŠ©ï¼šè¯•å¬
        function previewPoint(type) {
            const t = parseFloat(type==='a' ? el.anaStart.value : el.anaEnd.value);
            if (!isNaN(t)) {
                // æ’­æ”¾è¯¥ç‚¹å‰åå„3ç§’ (å…±6ç§’)
                startAudio(Math.max(0, t - 3));
                setTimeout(() => stopAudio(), 6000);
            }
        }

        // å¯¼å‡º .sli æ–‡ä»¶
        function exportSLI() {
            if (!loopState.active || loopState.start >= loopState.end) {
                el.anaMsg.textContent = "è¯·å…ˆè®¾ç½®æœ‰æ•ˆçš„å¾ªç¯åŒºé—´å‘¢ï¼";
                el.anaMsg.style.color = "red";
                return;
            }
            
            const rate = parseInt(el.baseRateInput.value) || 44100;
            // SLIæ ¼å¼: From = ç»“æŸé‡‡æ ·ç‚¹; To = å¼€å§‹é‡‡æ ·ç‚¹
            const fromSamples = Math.round(loopState.end * rate);
            const toSamples = Math.round(loopState.start * rate);
            
            const sliContent = `From = ${fromSamples};\nTo = ${toSamples};`;
            
            // åˆ›å»º Blob å¹¶ä¸‹è½½
            const blob = new Blob([sliContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            // ä½¿ç”¨å½“å‰æ›²ç›®åç§°
            const fileName = playlist[curIdx]?.name || 'loop';
            a.download = `${fileName}.sli`;
            
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            el.anaMsg.textContent = `å·²å¯¼å‡º: ${fileName}.sli`;
            el.anaMsg.style.color = "#27ae60";
            log(`SLI Exported: From=${fromSamples}, To=${toSamples}`, 'success');
        }

        async function parseFlacTagsNative(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const buffer = e.target.result;
                    const view = new DataView(buffer);
                    let offset = 0;
                    if (view.getUint32(0) !== 0x664C6143) { resolve(null); return; }
                    offset += 4;
                    log("FLAC Header Found.", 'success');
                    
                    let tags = {};
                    let loopLimit = 0;
                    
                    // éå†æ‰€æœ‰å…ƒæ•°æ®å—
                    while(offset < view.byteLength && loopLimit < 100) {
                        loopLimit++;
                        const header = view.getUint8(offset);
                        const isLast = (header & 0x80) !== 0;
                        const type = header & 0x7F;
                        const len = view.getUint32(offset) & 0x00FFFFFF; 
                        offset += 4;
                        
                        const blockEnd = offset + len;
                        
                        // Type 4: Vorbis Comment (æ ‡ç­¾ä¿¡æ¯)
                        if (type === 4) { 
                            try {
                                let pos = offset;
                                const vendorLen = view.getUint32(pos, true);
                                pos += 4 + vendorLen;
                                const commentListLen = view.getUint32(pos, true);
                                pos += 4;
                                const decoder = new TextDecoder("utf-8");
                                for(let i=0; i<commentListLen; i++) {
                                    const commentLen = view.getUint32(pos, true);
                                    pos += 4;
                                    const commentStr = decoder.decode(new Uint8Array(buffer, pos, commentLen));
                                    pos += commentLen;
                                    const splitIdx = commentStr.indexOf('=');
                                    if(splitIdx > -1) {
                                        const key = commentStr.substring(0, splitIdx).toUpperCase();
                                        const val = commentStr.substring(splitIdx + 1);
                                        if(key === 'LYRICS' || key === 'UNSYNCED LYRICS') tags.lyrics = val;
                                        else if (key === 'TITLE') tags.title = val;
                                        else if (key === 'ARTIST') tags.artist = val;
                                        else if (key === 'ALBUM') tags.album = val;
                                    }
                                }
                                log("FLAC Vorbis Comment parsed.", 'success');
                            } catch(err) { log("Vorbis Comment Parse Error: " + err, 'error'); }
                        }
                        
                        // Type 6: PICTURE (å°é¢å›¾ç‰‡)
                        if (type === 6) {
                            try {
                                let pos = offset;
                                // è·³è¿‡ picture type (4 bytes)
                                pos += 4;
                                // MIME type é•¿åº¦ (big endian)
                                const mimeLen = view.getUint32(pos);
                                pos += 4;
                                // MIME type å­—ç¬¦ä¸²
                                const mimeBytes = new Uint8Array(buffer, pos, mimeLen);
                                const mimeType = new TextDecoder("ascii").decode(mimeBytes);
                                pos += mimeLen;
                                // è·³è¿‡ description é•¿åº¦å’Œå†…å®¹
                                const descLen = view.getUint32(pos);
                                pos += 4 + descLen;
                                // è·³è¿‡ width, height, color depth, indexed colors (å„4å­—èŠ‚)
                                pos += 16;
                                // å›¾ç‰‡æ•°æ®é•¿åº¦
                                const picLen = view.getUint32(pos);
                                pos += 4;
                                // æ£€æŸ¥æ•°æ®æ˜¯å¦å®Œæ•´
                                if (pos + picLen <= buffer.byteLength) {
                                    const picData = new Uint8Array(buffer, pos, picLen);
                                    tags.picture = {
                                        format: mimeType,
                                        data: picData
                                    };
                                    log(`FLAC Picture found: ${mimeType}, ${picLen} bytes`, 'success');
                                } else {
                                    log(`FLAC Picture truncated, need ${pos + picLen} bytes, only have ${buffer.byteLength}`, 'error');
                                }
                            } catch(err) { log("FLAC Picture Parse Error: " + err, 'error'); }
                        }
                        
                        offset = blockEnd;
                        if (isLast) break;
                    }
                    
                    resolve(Object.keys(tags).length > 0 ? tags : null);
                };
                // å¢å¤§è¯»å–å¤§å°åˆ° 5MBï¼Œç¡®ä¿èƒ½è¯»å–åˆ°å¤§å°é¢å›¾ç‰‡
                reader.readAsArrayBuffer(file.slice(0, 5 * 1024 * 1024));
            });
        }

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => document.body.addEventListener(e, ev => { ev.preventDefault(); ev.stopPropagation(); }));
        document.body.addEventListener('dragenter', () => document.body.classList.add('drag-on'));
        document.body.addEventListener('dragleave', (e) => { if(e.clientX===0 && e.clientY===0) document.body.classList.remove('drag-on'); });
        document.body.addEventListener('drop', handleDrop);

        // æ–‡ä»¶å¯¼å…¥æŒ‰é’®äº‹ä»¶
        const fileInput = document.getElementById('file-input');
        document.getElementById('btn-import').addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFiles(Array.from(e.target.files));
                e.target.value = ''; // é‡ç½®ï¼Œå…è®¸é‡å¤é€‰æ‹©åŒä¸€æ–‡ä»¶
            }
        });

        function handleFiles(files) {
            const audios = files.filter(f => f.type.startsWith('audio/') || /\.(mp3|flac|wav|m4a|ogg)$/i.test(f.name));
            const lrcs = {}, slis = {};
            files.forEach(f => {
                if(f.name.endsWith('.lrc')) lrcs[f.name.replace('.lrc','')] = f;
                if(f.name.endsWith('.sli') || f.name.includes('.ogg.sli')) {
                    let base = f.name.replace('.sli','').replace('.ogg','');
                    slis[base] = f;
                }
            });
            if(audios.length) {
                playlist = audios.map(f => {
                    const base = f.name.replace(/\.[^.]+$/, "");
                    return { file: f, name: base, lrcFile: lrcs[base] || null, sliFile: slis[base] || null };
                });
                playlist.sort((a,b) => a.name.localeCompare(b.name));
                renderPlaylist();
                playTrack(0);
            } else if (Object.keys(slis).length > 0 && curIdx !== -1) {
                const cur = playlist[curIdx];
                if(slis[cur.name]) { cur.sliFile = slis[cur.name]; parseSLI(cur); }
            }
        }

        function handleDrop(e) {
            document.body.classList.remove('drag-on');
            handleFiles(Array.from(e.dataTransfer.files));
        }

        async function playTrack(i) {
            if(i < 0 || i >= playlist.length) return;
            curIdx = i; renderPlaylist();
            const track = playlist[i];
            stopAudio();

            el.title.textContent = track.name; el.artist.textContent = "Loading...";
            el.img.style.opacity = 0; el.img.src = ''; el.loadTip.style.display = 'block';
            el.progLine.style.width = '0%'; el.bufferLine.style.width = '0%';
            lyrics = []; isSyncedLyrics = true;
            el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">Parsing...</div>';
            resetLoopUI();
            log(`Track: ${track.name}`);

            try {
                const ab = await track.file.arrayBuffer();
                el.bufferLine.style.width = '30%';
                let meta = null;
                if(track.file.name.toLowerCase().endsWith('.flac')) {
                    log("Detect FLAC. Using Native Parser...");
                    meta = await parseFlacTagsNative(track.file);
                } else {
                    jsmediatags.read(track.file, {
                        onSuccess: (tag) => {
                            const c = {
                                title: tag.tags.title,
                                artist: tag.tags.artist,
                                lyrics: tag.tags.lyrics || (tag.tags.USLT ? tag.tags.USLT.data : ""),
                                picture: tag.tags.picture
                            };
                            applyMetadata(c, "ID3");
                        },
                        onError: () => {
                            updateTheme(null);
                            if(!track.lrcFile) el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">Pure Music</div>';
                        }
                    });
                }
                if(meta) applyMetadata(meta, "Native");

                el.bufferLine.style.width = '60%';
                audioBuffer = await actx.decodeAudioData(ab);
                el.bufferLine.style.width = '100%';
                playbackState.duration = audioBuffer.duration;
                el.totalTime.textContent = fmtTime(playbackState.duration);
                el.loadTip.style.display = 'none';
                
                if(el.artist.textContent === "Loading...") el.artist.textContent = "Ready";
                if(track.sliFile) await parseSLI(track);
                startAudio(0);
                el.coverWrap.classList.add('playing');
                updatePlayIcon();
                updateMediaSession();
                if(track.lrcFile) readLrcFile(track.lrcFile);
            } catch(e) { log("Err: " + e, 'error'); alert("æ’­æ”¾å¤±è´¥ï¼Œè¯·æŸ¥çœ‹Debugçª—å£"); }
        }

        function updateMediaSession() {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: el.title.textContent,
                    artist: el.artist.textContent,
                    artwork: [ { src: el.img.src, sizes: '512x512', type: 'image/png' } ]
                });
                navigator.mediaSession.setActionHandler('play', () => el.playBtn.click());
                navigator.mediaSession.setActionHandler('pause', () => el.playBtn.click());
                navigator.mediaSession.setActionHandler('previoustrack', () => document.getElementById('prev-btn').click());
                navigator.mediaSession.setActionHandler('nexttrack', () => document.getElementById('next-btn').click());
            }
        }

        function applyMetadata(common, source) {
            if(common.title) el.title.textContent = common.title;
            if(common.artist) el.artist.textContent = common.artist;
            if(common.picture && typeof common.picture === 'object') {
                const data = common.picture.data;
                const format = common.picture.format;
                if(data && format) {
                    let base64 = "";
                    for(let j=0; j<data.length; j++) base64 += String.fromCharCode(data[j]);
                    el.img.src = `data:${format};base64,${window.btoa(base64)}`;
                    el.img.onload = () => { el.img.style.opacity = 1; updateTheme(el.img); updateMediaSession(); }
                }
            } else { updateTheme(null); }

            if(common.lyrics) {
                log("Lyrics found.", 'success');
                let clean = common.lyrics.replace(/\/\s*(?=\[\d{2}:)/g, '\n');
                if(!clean.includes('\n') && clean.includes('/')) clean = clean.replace(/\s*\/\s*/g, '\n');
                parseAndRenderLyrics(clean, source);
            } else if(lyrics.length === 0) {
                // æ²¡æœ‰å†…åµŒæ­Œè¯
                if (neteaseSearchEnabled) {
                    // å¼€å¯äº†ç½‘æ˜“äº‘æœç´¢ï¼Œå°è¯•æœç´¢
                    const songName = el.title.textContent;
                    const artistName = common.artist || '';
                    const duration = playbackState.duration || 0;
                    searchNeteaselyrics(songName, artistName, duration);
                } else {
                    el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">Pure Music</div>';
                }
            }
        }

        function readLrcFile(file) {
            const r = new FileReader();
            r.onload = e => parseAndRenderLyrics(e.target.result, "LRC File");
            r.readAsText(file);
        }

        // ç½‘æ˜“äº‘éŸ³ä¹æ­Œè¯æœç´¢åŠŸèƒ½ (ä½¿ç”¨å…¬å¼€APIæœåŠ¡)
        const NETEASE_API_HOSTS = [
            'https://music-api.heheda.top',
            'https://wyy.heheda.top'
        ];
        
        // CORS ä»£ç†åˆ—è¡¨
        const CORS_PROXIES = [
            'https://api.allorigins.win/raw?url=',
            'https://corsproxy.io/?'
        ];
        
        let currentApiIndex = 0;
        let useDirectApi = true; // å…ˆå°è¯•ç›´æ¥APIï¼Œå¤±è´¥åç”¨ä»£ç†

        async function searchNeteaselyrics(songName, artist, duration) {
            try {
                el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">ğŸ” æ­£åœ¨æœç´¢æ­Œè¯...</div>';
                
                // æ™ºèƒ½æå–æ­Œåå’Œæ­Œæ‰‹ - å¤„ç† "æ­Œæ‰‹ - æ­Œå" æ ¼å¼
                let searchSong = songName;
                let searchArtist = artist || '';
                
                // å¦‚æœæ ‡é¢˜åŒ…å« " - "ï¼Œåˆ†ç¦»æ­Œæ‰‹å’Œæ­Œå
                if (songName.includes(' - ')) {
                    const parts = songName.split(' - ');
                    if (parts.length >= 2) {
                        searchArtist = parts[0].trim();
                        searchSong = parts.slice(1).join(' - ').trim();
                    }
                }
                
                log(`Searching lyrics: "${searchSong}" by "${searchArtist}"`);
                
                // å°è¯•å¤šä¸ª API æœåŠ¡
                let searchData = null;
                
                // æ–¹æ³•1: å°è¯•ç›´æ¥ API
                for (let i = 0; i < NETEASE_API_HOSTS.length && !searchData; i++) {
                    const host = NETEASE_API_HOSTS[i];
                    try {
                        const searchUrl = `${host}/search?keywords=${encodeURIComponent(searchSong)}&limit=20`;
                        log(`Trying API: ${host}`);
                        
                        const searchResp = await fetch(searchUrl, { 
                            method: 'GET',
                            headers: { 'Accept': 'application/json' }
                        });
                        if (!searchResp.ok) continue;
                        
                        const data = await searchResp.json();
                        if (data.code === 200 && data.result?.songs?.length > 0) {
                            searchData = data;
                            currentApiIndex = i;
                            useDirectApi = true;
                            log(`API works! Found ${data.result.songs.length} songs`, 'success');
                            break;
                        }
                    } catch (e) {
                        log(`API failed: ${e.message}`);
                    }
                }
                
                // æ–¹æ³•2: ä½¿ç”¨ CORS ä»£ç†è®¿é—®å®˜æ–¹ API
                if (!searchData) {
                    log('Trying official API with CORS proxy...');
                    const officialSearchUrl = `https://music.163.com/api/search/get?s=${encodeURIComponent(searchSong)}&type=1&limit=20&offset=0`;
                    
                    for (const proxy of CORS_PROXIES) {
                        try {
                            const proxyUrl = proxy + encodeURIComponent(officialSearchUrl);
                            const resp = await fetch(proxyUrl);
                            if (!resp.ok) continue;
                            
                            const data = await resp.json();
                            if (data.code === 200 && data.result?.songs?.length > 0) {
                                searchData = data;
                                useDirectApi = false;
                                log(`Proxy works! Found ${data.result.songs.length} songs`, 'success');
                                break;
                            }
                        } catch (e) {
                            log(`Proxy failed: ${e.message}`);
                        }
                    }
                }
                
                if (!searchData || !searchData.result?.songs?.length) {
                    log('No songs found on Netease', 'error');
                    el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">æœªæ‰¾åˆ°åŒ¹é…æ­Œæ›²</div>';
                    return false;
                }
                
                // åŒ¹é…é€»è¾‘ï¼šæ­Œå â†’ æ­Œæ‰‹ â†’ æ—¶é•¿
                const songs = searchData.result.songs;
                log(`Found ${songs.length} candidates`);
                
                // è¾…åŠ©å‡½æ•°ï¼šæ ‡å‡†åŒ–å­—ç¬¦ä¸²
                const normalize = (s) => (s || '').toLowerCase().replace(/\s+/g, '');
                const targetName = normalize(searchSong);
                const targetArtist = normalize(searchArtist);
                
                // 1. å…ˆç­›é€‰æ­ŒååŒ¹é…çš„æ­Œæ›²
                let nameMatched = songs.filter(s => normalize(s.name) === targetName);
                
                // å¦‚æœå®Œå…¨åŒ¹é…æ²¡æœ‰ï¼Œå°è¯•åŒ…å«åŒ¹é…
                if (nameMatched.length === 0) {
                    nameMatched = songs.filter(s => 
                        normalize(s.name).includes(targetName) || 
                        targetName.includes(normalize(s.name))
                    );
                }
                
                let candidates = nameMatched.length > 0 ? nameMatched : songs;
                
                if (nameMatched.length > 0) {
                    log(`${nameMatched.length} songs with matching name`);
                } else {
                    log(`No exact name match, using all candidates`, 'warn');
                }
                
                // 2. ä»æ­ŒååŒ¹é…çš„æ­Œæ›²ä¸­ï¼Œä¼˜å…ˆé€‰æ­Œæ‰‹åŒ¹é…çš„
                let bestMatch = candidates[0];
                
                if (targetArtist && candidates.length > 1) {
                    // æ‰¾æ­Œæ‰‹å®Œå…¨åŒ¹é…çš„
                    const artistMatched = candidates.filter(s => {
                        const songArtists = (s.artists || []).map(a => normalize(a.name));
                        return songArtists.some(a => a === targetArtist || a.includes(targetArtist) || targetArtist.includes(a));
                    });
                    
                    if (artistMatched.length > 0) {
                        log(`${artistMatched.length} songs with matching artist`);
                        candidates = artistMatched;
                        bestMatch = candidates[0];
                    }
                }
                
                // 3. æœ€åæŒ‰æ—¶é•¿é€‰æœ€æ¥è¿‘çš„
                if (duration && duration > 0 && candidates.length > 1) {
                    const targetMs = duration * 1000;
                    let minDiff = Math.abs((bestMatch.duration || 0) - targetMs);
                    
                    for (const song of candidates) {
                        const songDur = song.duration || 0;
                        const diff = Math.abs(songDur - targetMs);
                        if (diff < minDiff) {
                            minDiff = diff;
                            bestMatch = song;
                        }
                    }
                    const diffSec = (minDiff/1000).toFixed(1);
                    log(`Best match: "${bestMatch.name}" by ${bestMatch.artists?.[0]?.name || '?'} (Î”${diffSec}s)`);
                } else {
                    log(`Selected: "${bestMatch.name}" by ${bestMatch.artists?.[0]?.name || '?'}`);
                }
                
                const songId = bestMatch.id;
                log(`Found song ID: ${songId} - ${bestMatch.name}`);
                
                // è·å–æ­Œè¯
                let lyricData = null;
                
                if (useDirectApi) {
                    // ä½¿ç”¨ç›´æ¥ API
                    const host = NETEASE_API_HOSTS[currentApiIndex];
                    const lyricUrl = `${host}/lyric?id=${songId}`;
                    const lyricResp = await fetch(lyricUrl);
                    if (lyricResp.ok) {
                        lyricData = await lyricResp.json();
                    }
                }
                
                // å¦‚æœç›´æ¥ API å¤±è´¥ï¼Œå°è¯•ä»£ç†
                if (!lyricData || !lyricData.lrc) {
                    const officialLyricUrl = `https://music.163.com/api/song/lyric?id=${songId}&lv=1&tv=1`;
                    for (const proxy of CORS_PROXIES) {
                        try {
                            const proxyUrl = proxy + encodeURIComponent(officialLyricUrl);
                            const resp = await fetch(proxyUrl);
                            if (resp.ok) {
                                lyricData = await resp.json();
                                if (lyricData.lrc) break;
                            }
                        } catch (e) { }
                    }
                }
                
                if (lyricData?.lrc?.lyric) {
                    log('Netease lyrics loaded!', 'success');
                    parseAndRenderLyrics(lyricData.lrc.lyric, 'ç½‘æ˜“äº‘');
                    return true;
                } else if (lyricData?.nolyric || lyricData?.uncollected) {
                    log('Song has no lyrics (instrumental)', 'warn');
                    el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">ğŸµ çº¯éŸ³ä¹ï¼Œæ— æ­Œè¯</div>';
                    return false;
                } else {
                    throw new Error('No lyrics in response');
                }
            } catch (e) {
                log('Netease search error: ' + e.message, 'error');
                el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">æ­Œè¯æœç´¢å¤±è´¥</div>';
                return false;
            }
        }

        function parseAndRenderLyrics(text, source) {
            const lines = text.split(/[\r\n]/);
            const reg = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
            lyrics = [];
            let hasTimeTag = false;
            lines.forEach(l => {
                const m = reg.exec(l);
                if(m) {
                    hasTimeTag = true;
                    lyrics.push({ t: parseInt(m[1])*60 + parseInt(m[2]) + parseInt(m[3])/1000, txt: l.replace(reg,'').replace(/\[.*?\]/g, '').trim() });
                } else {
                    const clean = l.trim();
                    if(clean) lyrics.push({ t: -1, txt: clean });
                }
            });
            el.lyricBox.innerHTML = `<div style="height:120px"></div>`;
            isSyncedLyrics = hasTimeTag;
            if(isSyncedLyrics) {
                lyrics.forEach(l => {
                    if(l.t === -1) return;
                    const d = document.createElement('div'); d.className = 'lyric-line'; d.textContent = l.txt; d.onclick = () => startAudio(l.t); el.lyricBox.appendChild(d); 
                });
                el.artist.innerHTML += ` <span class="tag-source">${source}</span>`;
            } else {
                el.lyricBox.innerHTML = `<div style="padding:20px; text-align:center; white-space:pre-wrap; color:var(--text-main); font-size:1rem; line-height:1.8;">${text}</div>`;
                el.artist.innerHTML += ` <span class="tag-source">Unsynced</span>`;
            }
            if(isSyncedLyrics) el.lyricBox.innerHTML += '<div style="height:150px"></div>';
        }

        function startAudio(offset) {
            if(sourceNode) sourceNode.disconnect();
            sourceNode = actx.createBufferSource();
            sourceNode.buffer = audioBuffer;
            sourceNode.connect(gainNode);
            
            const isLooping = loopState.active && loopState.end <= audioBuffer.duration && loopState.start < loopState.end;
            
            if(isLooping) {
                sourceNode.loop = true; 
                sourceNode.loopStart = loopState.start; 
                sourceNode.loopEnd = loopState.end;
                document.getElementById('loop-status').style.display = 'inline';
            } else {
                sourceNode.loop = false; 
                document.getElementById('loop-status').style.display = 'none';
            }
            sourceNode.start(0, offset);
            playbackState.startTime = actx.currentTime - offset;
            playbackState.pauseTime = offset;
            playbackState.isPlaying = true;
            if('mediaSession' in navigator) navigator.mediaSession.playbackState = "playing";
            
            // ä½¿ç”¨é—­åŒ…ä¿å­˜å¾ªç¯çŠ¶æ€ï¼Œé¿å…åç»­çŠ¶æ€å˜åŒ–å½±å“åˆ¤æ–­
            const wasLooping = isLooping;
            sourceNode.onended = () => {
                // å¦‚æœæ˜¯å¾ªç¯æ¨¡å¼ï¼Œonended ä¸åº”è¯¥è§¦å‘åˆ‡æ­Œ
                // ä½†æŸäº›æµè§ˆå™¨å¯èƒ½åœ¨ç²¾åº¦é—®é¢˜ä¸‹æ„å¤–è§¦å‘ï¼Œè¿™é‡Œé‡æ–°å¯åŠ¨å¾ªç¯
                if(wasLooping && loopState.active && playbackState.isPlaying) {
                    log("Loop interrupted, restarting...", 'warn');
                    startAudio(loopState.start);
                    return;
                }
                // éå¾ªç¯æ¨¡å¼ä¸‹ï¼Œæ£€æŸ¥æ˜¯å¦çœŸçš„æ’­æ”¾å®Œäº†
                if(!wasLooping && playbackState.isPlaying && (getCurrentTime() >= playbackState.duration - 0.5)) {
                    handleNext();
                }
            };
        }
        function stopAudio() { 
            if(sourceNode) { try{sourceNode.stop()}catch(e){}; sourceNode.disconnect(); sourceNode=null; } 
            playbackState.isPlaying = false; 
            if('mediaSession' in navigator) navigator.mediaSession.playbackState = "paused";
        }
        function getCurrentTime() {
            if(!playbackState.isPlaying) return playbackState.pauseTime;
            let t = actx.currentTime - playbackState.startTime;
            if(loopState.active && sourceNode.loop && t > loopState.end) { const dur = loopState.end - loopState.start; t = loopState.start + (t - loopState.end) % dur; } 
            else if (t > playbackState.duration) t = playbackState.duration;
            return t;
        }

        function renderLoop() {
            requestAnimationFrame(renderLoop);
            const now = getCurrentTime();
            el.currTime.textContent = fmtTime(now);
            if(playbackState.duration) el.progLine.style.width = (now / playbackState.duration) * 100 + '%';
            if(isSyncedLyrics && lyrics.length) {
                let idx = lyrics.findIndex(l => l.t > now) - 1;
                if(idx < 0) idx = lyrics.length - 1; if(now < lyrics[0]?.t) idx = -1;
                const activeLine = el.lyricBox.children[idx + 1];
                if(activeLine && !activeLine.classList.contains('active')) {
                    document.querySelectorAll('.lyric-line').forEach(l => l.classList.remove('active'));
                    activeLine.classList.add('active');
                    const offset = activeLine.offsetTop - el.lyricBox.parentNode.offsetHeight/2 + activeLine.offsetHeight/2;
                    el.lyricBox.style.transform = `translateY(-${offset}px)`;
                }
            }
            renderVisuals();
        }
        renderLoop();

        el.playBtn.onclick = () => {
            if(actx.state === 'suspended') actx.resume();
            if(playbackState.isPlaying) { playbackState.pauseTime = getCurrentTime(); stopAudio(); el.coverWrap.classList.remove('playing'); updatePlayIcon(); }
            else { if(audioBuffer) { startAudio(playbackState.pauseTime); el.coverWrap.classList.add('playing'); updatePlayIcon(); } }
        };
        
        // è¿›åº¦æ¡æ‹–åŠ¨æ”¯æŒ
        let isDraggingProgress = false;
        let wasPlayingBeforeDrag = false;
        
        function handleProgressSeek(e) {
            if(!playbackState.duration) return;
            const rect = el.progBg.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const pct = Math.max(0, Math.min(1, x / rect.width));
            const target = pct * playbackState.duration;
            el.progLine.style.width = pct * 100 + '%';
            el.currTime.textContent = fmtTime(target);
            return target;
        }
        
        el.progBg.onmousedown = e => {
            if(!playbackState.duration) return;
            isDraggingProgress = true;
            wasPlayingBeforeDrag = playbackState.isPlaying;
            if(wasPlayingBeforeDrag) stopAudio();
            playbackState.pauseTime = handleProgressSeek(e);
        };
        
        document.addEventListener('mousemove', e => {
            if(!isDraggingProgress) return;
            playbackState.pauseTime = handleProgressSeek(e);
        });
        
        document.addEventListener('mouseup', e => {
            if(!isDraggingProgress) return;
            isDraggingProgress = false;
            if(wasPlayingBeforeDrag) {
                startAudio(playbackState.pauseTime);
                el.coverWrap.classList.add('playing');
            }
        });
        
        // è§¦æ‘¸å±æ”¯æŒ
        el.progBg.ontouchstart = e => {
            if(!playbackState.duration) return;
            isDraggingProgress = true;
            wasPlayingBeforeDrag = playbackState.isPlaying;
            if(wasPlayingBeforeDrag) stopAudio();
            playbackState.pauseTime = handleProgressSeek(e);
        };
        
        el.progBg.ontouchmove = e => {
            if(!isDraggingProgress) return;
            e.preventDefault();
            playbackState.pauseTime = handleProgressSeek(e);
        };
        
        el.progBg.ontouchend = e => {
            if(!isDraggingProgress) return;
            isDraggingProgress = false;
            if(wasPlayingBeforeDrag) {
                startAudio(playbackState.pauseTime);
                el.coverWrap.classList.add('playing');
            }
        };
        
        el.volBtn.onclick = () => { el.volPopup.classList.toggle('show'); };
        el.volRange.oninput = () => { gainNode.gain.value = el.volRange.value; };

        document.addEventListener('keydown', (e) => {
            if(e.target.tagName === 'INPUT') return;
            if(e.code === 'Space') { e.preventDefault(); el.playBtn.click(); } 
            else if (e.code === 'ArrowLeft') { if (audioBuffer) { const t = Math.max(0, getCurrentTime() - 5); if (playbackState.isPlaying) startAudio(t); else { playbackState.pauseTime = t; updateUI(t); } } } 
            else if (e.code === 'ArrowRight') { if (audioBuffer) { const t = Math.min(playbackState.duration, getCurrentTime() + 5); if (playbackState.isPlaying) startAudio(t); else { playbackState.pauseTime = t; updateUI(t); } } } 
            else if (e.code === 'ArrowUp') { e.preventDefault(); el.volRange.value = Math.min(1, parseFloat(el.volRange.value) + 0.05); gainNode.gain.value = el.volRange.value; el.volPopup.classList.add('show'); clearTimeout(window.volTimer); window.volTimer = setTimeout(() => el.volPopup.classList.remove('show'), 2000); } 
            else if (e.code === 'ArrowDown') { e.preventDefault(); el.volRange.value = Math.max(0, parseFloat(el.volRange.value) - 0.05); gainNode.gain.value = el.volRange.value; el.volPopup.classList.add('show'); clearTimeout(window.volTimer); window.volTimer = setTimeout(() => el.volPopup.classList.remove('show'), 2000); }
        });
        function updateUI(t) { el.currTime.textContent = fmtTime(t); el.progLine.style.width = (t / playbackState.duration) * 100 + '%'; }

        function handleNext() {
            if(playMode === 1) playTrack(Math.floor(Math.random()*playlist.length));
            else if(playMode === 2) startAudio(0);
            else playTrack(curIdx + 1 >= playlist.length ? 0 : curIdx + 1);
        }
        document.getElementById('prev-btn').onclick = () => playTrack(curIdx - 1 < 0 ? playlist.length-1 : curIdx - 1);
        document.getElementById('next-btn').onclick = handleNext;
        el.modeBtn.onclick = () => {
            playMode = (playMode + 1) % 3;
            ['icon-list-loop', 'icon-random', 'icon-single'].forEach(id => document.getElementById(id).style.display = 'none');
            document.getElementById(['icon-list-loop', 'icon-random', 'icon-single'][playMode]).style.display = 'block';
        };

        async function parseSLI(track) {
            return new Promise(resolve => {
                const r = new FileReader();
                r.onload = e => {
                    const m = e.target.result.match(/From\s*=\s*(\d+)\s*;\s*To\s*=\s*(\d+)/i);
                    if(m) {
                        const rate = parseInt(el.baseRateInput.value) || 44100;
                        applyLoop(parseInt(m[2])/rate, parseInt(m[1])/rate);
                        el.loopMsg.textContent = `SLI Loaded`;
                    }
                    resolve();
                };
                r.readAsText(track.sliFile);
            });
        }
        function applyLoop(s, e) {
            el.loopStart.value = s.toFixed(3); el.loopEnd.value = e.toFixed(3);
            el.loopEnable.checked = true; loopState = { active: true, start: s, end: e };
            updateLoopMarkers();
        }
        window.setLoopPoint = function(t) {
            const now = getCurrentTime();
            if(t==='a') el.loopStart.value=now.toFixed(3); else el.loopEnd.value=now.toFixed(3);
            el.loopEnable.checked = true; el.loopEnable.dispatchEvent(new Event('change'));
        };
        el.loopEnable.addEventListener('change', e => {
            if(e.target.checked) {
                const s = parseFloat(el.loopStart.value), e_val = parseFloat(el.loopEnd.value);
                if(e_val > s) { loopState = { active: true, start: s, end: e_val }; if(playbackState.isPlaying) startAudio(getCurrentTime()); }
            } else { loopState.active = false; if(playbackState.isPlaying) startAudio(getCurrentTime()); }
            updateLoopMarkers();
        });
        function resetLoopUI() { loopState.active=false; el.loopEnable.checked=false; updateLoopMarkers(); }
        function updateLoopMarkers() {
            if(!loopState.active) { el.markerA.style.display='none'; el.markerB.style.display='none'; document.getElementById('loop-status').style.display='none'; return; }
            const d = playbackState.duration || 1;
            el.markerA.style.left = (loopState.start/d)*100+'%'; el.markerB.style.left = (loopState.end/d)*100+'%';
            el.markerA.style.display='block'; el.markerB.style.display='block'; document.getElementById('loop-status').style.display='inline';
        }

        function updatePlayIcon() { el.playBtn.innerHTML = playbackState.isPlaying ? '<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>' : '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>'; }
        function fmtTime(s) { const m = Math.floor(s/60); const sc = Math.floor(s%60); return `${m.toString().padStart(2,'0')}:${sc.toString().padStart(2,'0')}`; }
        function renderPlaylist() {
            el.plContainer.innerHTML = '';
            playlist.forEach((t, i) => {
                const d = document.createElement('div'); d.className = `pl-item ${i === curIdx ? 'active' : ''}`;
                d.innerHTML = `<span style="width:20px; opacity:0.5">${i+1}</span> ${t.name}`;
                d.onclick = () => playTrack(i); el.plContainer.appendChild(d);
            });
        }
        function updateTheme(img) {
            let c1 = "#e0c3fc", c2 = "#8ec5fc";
            if(img) { try { const rgb = colorThief.getColor(img); c1 = `rgb(${Math.floor((rgb[0]+255)/2)},${Math.floor((rgb[1]+255)/2)},${Math.floor((rgb[2]+255)/2)})`; c2 = `rgb(${Math.floor((rgb[0]+200)/2)},${Math.floor((rgb[1]+220)/2)},${Math.floor((rgb[2]+255)/2)})`; } catch(e){} }
            document.body.style.setProperty('--bg-1', c1); document.body.style.setProperty('--bg-2', c2);
        }
        function renderVisuals() {
            const mode = el.effectSel.value, w = el.canvas.width = window.innerWidth, h = el.canvas.height = window.innerHeight;
            canvasCtx.clearRect(0,0,w,h); if(mode==='none') return;
            let data = new Uint8Array(analyser.frequencyBinCount); analyser.getByteFrequencyData(data);
            if(mode==='bars') { const bw=(w/data.length)*2.5; let x=0; for(let i=0;i<data.length;i++){ const H=data[i]*1.5; canvasCtx.fillStyle=`rgba(255,255,255,0.3)`; canvasCtx.fillRect(x,h-H/2,bw,H/2); x+=bw+1; } }
            else if(mode==='snow') {
                if(particles.length<100) particles.push({x:Math.random()*w,y:0,r:Math.random()*3+1,s:Math.random()*2+1});
                const bass=data[10]; canvasCtx.fillStyle="rgba(255,255,255,0.8)";
                particles.forEach((p,i)=>{ p.y+=p.s*(1+bass/256*5)*0.5; p.x+=Math.sin(p.y*0.01); canvasCtx.beginPath(); canvasCtx.arc(p.x,p.y,p.r,0,Math.PI*2); canvasCtx.fill(); if(p.y>h) particles[i].y=-10; });
            } else if(mode==='waves') {
                canvasCtx.beginPath(); canvasCtx.moveTo(0,h/2);
                for(let i=0;i<data.length;i++){ canvasCtx.lineTo((i/data.length)*w, h/2+Math.sin(i*0.1+performance.now()/1000)*data[i]+Math.cos(i*0.05)*50); }
                canvasCtx.strokeStyle="rgba(255,255,255,0.4)"; canvasCtx.lineWidth=2; canvasCtx.stroke();
            }
        }

        document.getElementById('toggle-list').onclick = () => document.getElementById('playlist-sidebar').classList.toggle('show');
        document.getElementById('toggle-loop-panel').onclick = () => document.getElementById('loop-panel').classList.toggle('show');
        document.getElementById('toggle-analyze').onclick = () => document.getElementById('analyze-panel').classList.toggle('show');
        document.getElementById('toggle-debug').onclick = () => {
            const dbg = document.getElementById('debug-console');
            dbg.style.display = (dbg.style.display === 'none' || dbg.style.display === '') ? 'block' : 'none';
        };
        
        // ç½‘æ˜“äº‘æ­Œè¯å¼€å…³
        const neteaseBtn = document.getElementById('toggle-netease');
        neteaseBtn.onclick = () => {
            neteaseSearchEnabled = !neteaseSearchEnabled;
            neteaseBtn.style.background = neteaseSearchEnabled ? '#27ae60' : '';
            neteaseBtn.style.color = neteaseSearchEnabled ? '#fff' : '';
            log(`Netease lyrics search: ${neteaseSearchEnabled ? 'ON' : 'OFF'}`);
        };
        
        // ç§»åŠ¨ç«¯é«˜çº§èœå•
        const advancedBtn = document.getElementById('toggle-advanced');
        const advancedMenu = document.getElementById('advanced-menu');
        if (advancedBtn && advancedMenu) {
            advancedBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                advancedMenu.classList.toggle('show');
            });
            
            // ç‚¹å‡»èœå•é¡¹
            advancedMenu.querySelectorAll('.advanced-menu-item').forEach(item => {
                item.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const action = this.dataset.action;
                    advancedMenu.classList.remove('show');
                    
                    if (action === 'debug') {
                        const dbg = document.getElementById('debug-console');
                        dbg.style.display = (dbg.style.display === 'none' || dbg.style.display === '') ? 'block' : 'none';
                    } else if (action === 'analyze') {
                        document.getElementById('analyze-panel').classList.toggle('show');
                    } else if (action === 'loop') {
                        document.getElementById('loop-panel').classList.toggle('show');
                    }
                });
            });
            
            // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­èœå•
            document.addEventListener('click', function(e) {
                if (!advancedBtn.contains(e.target) && !advancedMenu.contains(e.target)) {
                    advancedMenu.classList.remove('show');
                }
            });
        } else {
            console.log('Advanced menu elements not found:', { advancedBtn, advancedMenu });
        }
        
        updateTheme(null);
    </script>
</body>
</html>
