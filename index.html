<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aurora Player</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.4.0/color-thief.min.js"></script>
    <script>
        //å…¨å±€ API åœ°å€
        window.API_BASE_URL = ''|| 'https://minorimusicapi.zeabur.app';
        // ä¸‹è½½ä»£ç† Worker çš„åœ°å€
        window.DOWNLOAD_PROXY_URL = ''||'https://proxy.minori0721.dpdns.org';
    </script>
    <!-- åŠ¨æ€æ·»åŠ  Preconnect/DNS prefetchï¼Œä½¿ç”¨å¯ä¿®æ”¹çš„ window.API_BASE_URL -->
    <script>
        (function(){
            const base = (window.API_BASE_URL ).replace(/\/$/, '');
            try{
                const pre = document.createElement('link');
                pre.rel = 'preconnect';
                pre.href = base;
                pre.crossOrigin = 'anonymous';
                document.head.appendChild(pre);
            }catch(e){}
            try{
                const host = base.replace(/^https?:\/\//, '');
                const dns = document.createElement('link');
                dns.rel = 'dns-prefetch';
                dns.href = '//' + host;
                document.head.appendChild(dns);
            }catch(e){}
        })();
    </script>

    <style>
        :root {
            --bg-1: #e0c3fc; --bg-2: #8ec5fc;
            --text-main: #2c3e50; --text-sub: rgba(44, 62, 80, 0.6);
            --glass: rgba(255, 255, 255, 0.4);
            --glass-strong: rgba(255, 255, 255, 0.95);
            --border: rgba(255, 255, 255, 0.6);
            --accent: #2980b9;
        }

        body {
            margin: 0; height: 100vh;
            background-color: #f5f7fa;
            background-image: 
                radial-gradient(circle at 10% 20%, var(--bg-1) 0%, transparent 50%),
                radial-gradient(circle at 90% 80%, var(--bg-2) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, #fff 0%, transparent 60%);
            background-size: 150% 150%;
            animation: bgMove 15s infinite alternate;
            color: var(--text-main); font-family: 'Segoe UI', sans-serif;
            overflow: hidden; display: flex; justify-content: center; align-items: center;
            transition: --bg-1 1s, --bg-2 1s;
        }
        @keyframes bgMove { 0% { background-position: 0% 0%; } 100% { background-position: 100% 100%; } }

        #visual-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none; }

        .top-bar { position: absolute; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; z-index: 100; }
        .tool-group { display: flex; gap: 10px; }
        .glass-btn {
            background: var(--glass); backdrop-filter: blur(10px); border: 1px solid var(--border);
            padding: 8px 15px; border-radius: 20px; cursor: pointer; font-size: 0.9rem; color: var(--text-main);
            display: flex; align-items: center; gap: 5px; transition: 0.2s; outline: none; white-space: nowrap;
        }
        .glass-btn:hover { background: #fff; transform: translateY(-2px); }

        /* é€šç”¨é¢æ¿æ ·å¼ */
        .panel-float {
            position: absolute; top: 70px; right: 20px; background: var(--glass-strong); padding: 20px; border-radius: 15px;
            border: 1px solid var(--border); width: 320px; 
            transform: translateX(120%); transition: transform 0.3s cubic-bezier(0.19, 1, 0.22, 1);
            z-index: 90; box-shadow: 0 10px 30px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 12px;
        }
        .panel-float.show { transform: translateX(0); }
        
        .panel-row { display: flex; align-items: center; justify-content: space-between; font-size: 0.9rem; }
        .panel-input { width: 80px; border: 1px solid #ccc; border-radius: 5px; padding: 4px; text-align: center; font-family: monospace; }
        .panel-title { margin: 0; border-bottom: 1px solid rgba(0,0,0,0.1); padding-bottom: 10px; font-size: 1rem; font-weight: bold; position: relative; }
        
        /* é¢æ¿å…³é—­æŒ‰é’® */
        .panel-close {
            position: absolute; right: 0; top: 50%; transform: translateY(-50%);
            background: none; border: none; font-size: 1.5rem; color: var(--text-sub);
            cursor: pointer; padding: 0 5px; line-height: 1; display: none;
        }
        .panel-close:hover { color: var(--text-main); }

        /* åˆ†æé¢æ¿ç‰¹åˆ«æ ·å¼ */
        #analyze-panel { right: 350px; width: 300px; } /* æ”¾åœ¨å¾ªç¯é¢æ¿å·¦è¾¹ */
        #analyze-panel:not(.show) { transform: translateX(calc(100% + 370px)); } /* ç¡®ä¿èƒ½å®Œå…¨æ»‘å‡ºå±å¹• */
        .analyze-btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 5px; }
        .big-btn { width: 100%; justify-content: center; background: var(--accent); color: white; border: none; }
        .big-btn:hover { background: #1a5276; }

        .main-container { width: 85vw; height: 80vh; display: grid; grid-template-columns: 450px 1fr; gap: 80px; position: relative; z-index: 10; }
        .left-panel { display: flex; flex-direction: column; justify-content: center; position: relative; }
        .cover-wrapper { width: 100%; padding-bottom: 100%; position: relative; margin-bottom: 40px; filter: drop-shadow(0 20px 30px rgba(0,0,0,0.1)); }
        .default-disc {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 50%;
            background: conic-gradient(from 0deg, #e0e0e0, #ffffff, #e0e0e0, #d0d0d0, #ffffff, #e0e0e0);
            box-shadow: inset 0 0 0 5px rgba(255,255,255,0.8); display: flex; justify-content: center; align-items: center;
            animation: spin 10s linear infinite paused;
        }
        .default-disc::after { content:''; width:20%; height:20%; background:#f5f7fa; border-radius:50%; border:5px solid rgba(255,255,255,0.5); }
        .playing .default-disc { animation-play-state: running; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .album-img { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; border-radius: 20px; opacity: 0; transition: opacity 0.5s; }
        
        .progress-section { margin-top: auto; }
        .time-display { font-size: 0.9rem; color: var(--text-sub); margin-bottom: 12px; font-weight: 500; display: flex; justify-content: space-between;}
        .progress-bar-bg { width: 100%; height: 8px; background: rgba(0,0,0,0.05); border-radius: 4px; position: relative; cursor: pointer; transition: height 0.2s; overflow: visible;}
        .progress-bar-bg:hover { height: 12px; }
        .progress-line { position: absolute; top: 0; left: 0; width: 0%; height: 100%; background: var(--text-main); border-radius: 4px; }
        .buffer-line { position: absolute; top: 0; left: 0; width: 0%; height: 100%; background: rgba(255,255,255,0.6); border-radius: 4px; transition: width 0.2s; }
        
        .loop-marker { 
            position: absolute; top: -6px; width: 2px; height: 20px; background: #e74c3c; 
            z-index: 20; pointer-events: none; display: none; box-shadow: 0 0 5px rgba(231, 76, 60, 0.5);
        }
        .loop-marker::after { content: attr(data-label); position: absolute; top: -15px; left: -50%; color: #e74c3c; font-size: 10px; font-weight: bold; }

        .right-panel { display: flex; flex-direction: column; justify-content: center; position: relative; }
        .track-header { margin-bottom: 20px; }
        .track-title { font-size: 3rem; font-weight: 800; margin: 0 0 10px 0; line-height: 1.1; }
        .track-artist { font-size: 1.2rem; color: var(--text-sub); font-weight: 500; }
        
        .lyrics-box { 
            height: 350px; overflow: hidden; margin-bottom: 30px; position: relative; 
            padding-left: 20px;
            mask-image: linear-gradient(to bottom, transparent, black 15%, black 85%, transparent); 
            -webkit-mask-image: linear-gradient(to bottom, transparent, black 15%, black 85%, transparent); 
        }
        .lyrics-scroll { transition: transform 0.3s ease-out; width: 100%; text-align: left; }
        .lyric-line { font-size: 1.1rem; color: var(--text-sub); margin: 14px 0; cursor: pointer; opacity: 0.6; transition: 0.2s; line-height: 1.4; }
        .lyric-line.active { color: var(--text-main); font-size: 1.4rem; font-weight: 800; opacity: 1; transform-origin: left center; }

        /* ç¿»è¯‘è¡Œæ ·å¼ï¼ˆæ˜¾ç¤ºåœ¨åŸæ­Œè¯ä¸‹æ–¹ï¼Œå­—ä½“è¾ƒå°ä¸”é¢œè‰²åæ·¡ï¼‰ */
        .lyric-translation { font-size: 0.9rem; color: var(--text-sub); margin-top: 4px; line-height: 1.2; }

        .controls-row { display: flex; align-items: center; justify-content: flex-start; gap: 25px; padding-top: 20px; }
        .btn { background: var(--glass); backdrop-filter: blur(10px); border: 1px solid var(--border); color: var(--text-main); cursor: pointer; width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: 0.2s; position: relative; }
        .btn:hover { background: #fff; transform: translateY(-3px); }
        .btn svg { width: 20px; height: 20px; fill: currentColor; }
        .btn-play { width: 70px; height: 70px; background: var(--text-main); color: #fff; }
        .btn-play:hover { background: #000; }

        .playlist-sidebar { position: fixed; right: 0; top: 0; bottom: 0; width: 320px; background: var(--glass-strong); backdrop-filter: blur(30px); box-shadow: -10px 0 40px rgba(0,0,0,0.05); transform: translateX(100%); transition: transform 0.4s; z-index: 95; padding: 80px 30px 30px 30px; overflow-y: auto; }
        .playlist-sidebar.show { transform: translateX(0); }
        .pl-item { padding: 12px; border-radius: 8px; cursor: pointer; font-size: 0.95rem; color: var(--text-sub); margin-bottom: 5px; display: flex; align-items: center; }
        .pl-item:hover { background: rgba(0,0,0,0.05); }
        .pl-item.active { background: #fff; color: var(--text-main); font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.05); }

        .drag-mask { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.9); z-index: 999; display: flex; flex-direction: column; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: 0.3s; }
        body.drag-on .drag-mask { opacity: 1; pointer-events: all; }
        .loading-tip { position: absolute; bottom: 20px; font-size: 0.8rem; color: #2980b9; display: none; font-weight: bold; }
        .tag-source { font-size: 0.7rem; padding: 2px 6px; border-radius: 4px; background: rgba(0,0,0,0.1); margin-left: 10px; vertical-align: middle;}
        .tag-quality { font-size: 0.65rem; padding: 2px 6px; border-radius: 4px; background: linear-gradient(135deg, #3498db, #2980b9); color: white; margin-left: 8px; vertical-align: middle; font-weight: 600; letter-spacing: 0.5px; text-transform: uppercase; }

        #debug-console {
            position: fixed; top: 70px; left: 20px; width: 350px; max-height: 200px;
            background: rgba(0,0,0,0.85); color: #0f0; font-family: monospace; font-size: 11px;
            overflow-y: auto; z-index: 9999; padding: 10px; border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); pointer-events: all;
            display: none; border: 1px solid rgba(255,255,255,0.2);
        }
        .log-warn { color: yellow; } .log-err { color: #ff5555; font-weight: bold; } .log-suc { color: #55ff55; font-weight: bold; }

        .vol-container { position: relative; display: flex; align-items: center; justify-content: center; }
        .vol-popup {
            position: absolute; bottom: 65px; left: 50%; transform: translateX(-50%);
            width: 40px; height: 120px;
            background: var(--glass-strong); backdrop-filter: blur(10px);
            border-radius: 20px; border: 1px solid var(--border);
            display: flex; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: all 0.3s cubic-bezier(0.19, 1, 0.22, 1);
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }
        .vol-popup.show { opacity: 1; pointer-events: all; bottom: 70px; }
        input[type=range].vol-range {
            writing-mode: vertical-lr; direction: rtl;
            width: 8px; height: 90px; background: rgba(0,0,0,0.1);
            cursor: pointer; accent-color: var(--text-main);
        }

        /* ç½‘æ˜“äº‘æœç´¢é¢æ¿ */
        .netease-panel {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5); z-index: 200;
            display: none; justify-content: center; align-items: center;
        }
        .netease-panel.show { display: flex; }
        .netease-content {
            background: var(--glass-strong); backdrop-filter: blur(30px);
            border-radius: 20px; padding: 25px; width: 90%; max-width: 500px;
            max-height: 80vh; display: flex; flex-direction: column;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        .netease-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid rgba(0,0,0,0.1);
        }
        .netease-header h3 { margin: 0; font-size: 1.1rem; }
        .netease-close {
            background: none; border: none; font-size: 1.5rem;
            cursor: pointer; color: var(--text-sub); padding: 0 5px;
        }
        .netease-close:hover { color: var(--text-main); }
        .netease-tabs { display: flex; gap: 10px; margin-bottom: 15px; }
        .netease-tab {
            flex: 1; padding: 10px; border: none; border-radius: 10px;
            background: rgba(0,0,0,0.05); cursor: pointer; font-size: 0.9rem;
            transition: 0.2s;
        }
        .netease-tab.active { background: var(--accent); color: white; }
        .netease-tab:hover:not(.active) { background: rgba(0,0,0,0.1); }
        .netease-tab-content {
            flex: 1; display: flex; flex-direction: column;
            overflow: hidden; min-height: 0;
        }
        .netease-search-box {
            display: flex; gap: 10px; margin-bottom: 15px;
        }
        .netease-input {
            flex: 1; padding: 12px 15px; border: 1px solid rgba(0,0,0,0.15);
            border-radius: 10px; font-size: 0.95rem; outline: none;
            background: rgba(255,255,255,0.8);
        }
        .netease-input:focus { border-color: var(--accent); }
        .netease-search-btn {
            padding: 12px 20px; border: none; border-radius: 10px;
            background: var(--accent); color: white; cursor: pointer;
            font-size: 0.9rem; white-space: nowrap;
        }
        .netease-search-btn:hover { background: #1a5276; }
        .netease-search-btn:disabled { background: #ccc; cursor: not-allowed; }
        .netease-results {
            flex: 1; overflow-y: auto; min-height: 0; max-height: 45vh;
            border: 1px solid rgba(0,0,0,0.1); border-radius: 10px;
            background: rgba(255,255,255,0.5);
        }
        .netease-item {
            padding: 12px 15px; cursor: pointer; border-bottom: 1px solid rgba(0,0,0,0.05);
            display: flex; align-items: center; gap: 12px; transition: 0.15s;
        }
        .netease-item:hover { background: rgba(0,0,0,0.05); }
        .netease-item:last-child { border-bottom: none; }
        .netease-item-cover {
            width: 45px; height: 45px; border-radius: 6px;
            object-fit: cover; background: #eee; flex-shrink: 0;
        }
        .netease-item-info { flex: 1; min-width: 0; }
        .netease-item-name {
            font-weight: 600; font-size: 0.95rem; color: var(--text-main);
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .netease-item-artist {
            font-size: 0.8rem; color: var(--text-sub); margin-top: 3px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .netease-item-duration {
            font-size: 0.75rem; color: var(--text-sub); flex-shrink: 0;
        }
        .netease-item-play {
            width: 32px; height: 32px; border-radius: 50%;
            background: var(--accent); color: white; border: none;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            flex-shrink: 0; opacity: 0; transition: 0.15s;
        }
        .netease-item:hover .netease-item-play { opacity: 1; }
        .netease-item-play:hover { transform: scale(1.1); }
        .netease-loading, .netease-empty {
            text-align: center; padding: 40px; color: var(--text-sub);
        }
        .netease-playlist-info {
            display: flex; gap: 15px; padding: 15px;
            background: rgba(0,0,0,0.03); border-radius: 10px; margin-bottom: 15px;
        }
        .netease-playlist-cover {
            width: 80px; height: 80px; border-radius: 10px; object-fit: cover; background: #eee;
        }
        .netease-playlist-meta { flex: 1; }
        .netease-playlist-name { font-weight: bold; font-size: 1rem; margin-bottom: 5px; }
        .netease-playlist-desc { font-size: 0.8rem; color: var(--text-sub); }
        .netease-import-btn {
            width: 100%; padding: 12px; border: none; border-radius: 10px;
            background: #27ae60; color: white; cursor: pointer;
            font-size: 0.95rem; margin-top: 10px;
        }
        .netease-import-btn:hover { background: #219a52; }
        .netease-import-btn:disabled { background: #ccc; }
        
        /* ç™»å½•ç›¸å…³ */
        .netease-user-bar {
            display: flex; align-items: center; gap: 10px;
            padding: 10px 15px; background: rgba(0,0,0,0.03);
            border-radius: 10px; margin-bottom: 15px;
        }
        .netease-avatar {
            width: 40px; height: 40px; border-radius: 50%;
            object-fit: cover; background: #eee;
        }
        .netease-user-info { flex: 1; min-width: 0; }
        .netease-nickname { font-weight: 600; font-size: 0.95rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .netease-user-type { 
            display: inline-block; font-size: 0.7rem; padding: 2px 6px; 
            border-radius: 4px; margin-top: 2px;
        }
        .netease-user-type.vip { background: linear-gradient(135deg, #f39c12, #e74c3c); color: white; }
        .netease-user-type.svip { background: linear-gradient(135deg, #9b59b6, #8e44ad); color: white; }
        .netease-user-type.music-pack { background: linear-gradient(135deg, #1abc9c, #16a085); color: white; }
        .netease-user-type.normal { background: #95a5a6; color: white; }
        .netease-quality-bar {
            display: flex; align-items: center; gap: 8px;
            padding: 8px 12px; background: rgba(0,0,0,0.03);
            border-radius: 8px; margin-bottom: 15px; font-size: 0.85rem;
        }
        .netease-quality-bar label { color: var(--text-sub); white-space: nowrap; }
        .netease-quality-select {
            flex: 1; padding: 6px 10px; border: 1px solid rgba(0,0,0,0.1);
            border-radius: 6px; background: white; font-size: 0.85rem; cursor: pointer;
        }
        .netease-logout-btn {
            padding: 6px 12px; border: none; border-radius: 6px;
            background: #e74c3c; color: white; cursor: pointer; font-size: 0.8rem;
        }
        .netease-logout-btn:hover { background: #c0392b; }
        .netease-login-btn {
            width: 100%; padding: 12px; border: none; border-radius: 10px;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white; cursor: pointer; font-size: 0.95rem;
            margin-bottom: 15px; transition: 0.2s;
        }
        .netease-login-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(231,76,60,0.3); }
        .qrcode-container {
            text-align: center; padding: 20px;
        }
        .qrcode-container img {
            width: 180px; height: 180px; border-radius: 10px;
            border: 2px solid #eee;
        }
        .qrcode-tip {
            margin-top: 15px; font-size: 0.85rem; color: var(--text-sub);
        }
        .qrcode-status {
            margin-top: 10px; font-size: 0.9rem; font-weight: 600;
        }
        .qrcode-status.waiting { color: #f39c12; }
        .qrcode-status.scanned { color: #3498db; }
        .qrcode-status.success { color: #27ae60; }
        .qrcode-status.expired { color: #e74c3c; }
        .my-playlists { margin-top: 10px; }
        .my-playlists-title {
            font-size: 0.85rem; color: var(--text-sub);
            margin-bottom: 8px; padding-left: 5px;
        }

        /* ä¸‹è½½æ¨¡æ€æ ·å¼ */
        .download-modal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.45); z-index: 10000; }
        .download-modal.show { display: flex; }
        .download-panel { width: 420px; max-width: 92%; background: var(--glass-strong); border: 1px solid var(--border); padding: 16px; border-radius: 12px; box-shadow: 0 20px 60px rgba(0,0,0,0.4); }
        .download-header { display:flex; align-items:center; justify-content:space-between; font-weight:700; font-size:1rem; margin-bottom:6px }
        .download-panel .panel-close { display:inline-block; background:none; border:none; font-size:1.4rem; cursor:pointer; color:var(--text-sub) }
        .quality-item { display:flex; align-items:center; justify-content:space-between; padding:8px 10px; border-radius:8px; background: rgba(255,255,255,0.6); }
        .quality-item > div:first-child { flex: 1 1 auto; min-width: 0; }
        .quality-action button { padding:6px 10px; }
        .quality-item.disabled { opacity:0.45; pointer-events:none; filter:grayscale(0.4); }
        .quality-meta { color:var(--text-sub); font-size:0.9rem }
        .quality-action { min-width:90px; display:flex; gap:8px; justify-content:flex-end }

        /* é«˜çº§èœå• */
        .advanced-menu-container { position: relative; }
        .advanced-menu {
            position: absolute; top: 45px; right: 0;
            background: var(--glass-strong); backdrop-filter: blur(20px);
            border-radius: 12px; border: 1px solid var(--border);
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            min-width: 140px; padding: 8px 0;
            opacity: 0; pointer-events: none; transform: translateY(-10px);
            transition: all 0.2s ease;
            z-index: 9999;
        }
        .advanced-menu.show { opacity: 1; pointer-events: all; transform: translateY(0); }
        .advanced-menu-item {
            display: block; width: 100%; padding: 10px 15px;
            background: none; border: none; text-align: left;
            font-size: 0.85rem; color: var(--text-main); cursor: pointer;
            transition: background 0.15s;
        }
        .advanced-menu-item:hover { background: rgba(0,0,0,0.05); }
        .advanced-menu-item:active { background: rgba(0,0,0,0.1); }
        
        /* æ¡Œé¢ç«¯éšè—é«˜çº§æŒ‰é’® */
        .mobile-only { display: none; }
        .desktop-only { display: flex; }

        /* ========== ç§»åŠ¨ç«¯å“åº”å¼ ========== */
        @media screen and (max-width: 900px) {
            html, body { 
                overflow-x: hidden; 
                overflow-y: auto;
                height: auto; 
                min-height: 100vh;
                max-width: 100vw;
            }
            
            .main-container {
                width: 100%; height: auto;
                grid-template-columns: 1fr; gap: 15px;
                padding: 70px 15px 100px 15px;
                box-sizing: border-box;
            }
            
            .left-panel { order: 1; }
            .right-panel { order: 2; }
            
            .cover-wrapper { 
                width: 55vw; max-width: 250px; padding-bottom: 55vw; 
                margin: 0 auto 15px auto; 
            }
            
            .progress-section { padding: 0; }
            
            .track-header { text-align: center; padding: 0 10px; }
            .track-title { font-size: 1.5rem; word-break: break-word; }
            .track-artist { font-size: 0.95rem; }
            
            .lyrics-box { 
                height: 180px; padding: 0 10px;
                mask-image: linear-gradient(to bottom, transparent, black 10%, black 90%, transparent);
                -webkit-mask-image: linear-gradient(to bottom, transparent, black 10%, black 90%, transparent);
            }
            .lyric-line { font-size: 0.9rem; margin: 8px 0; text-align: center; }
            .lyric-line.active { font-size: 1.1rem; }
            .lyrics-scroll { text-align: center; }
            
            .controls-row { justify-content: center; gap: 12px; padding: 10px 0; }
            .btn { width: 42px; height: 42px; }
            .btn svg { width: 16px; height: 16px; }
            .btn-play { width: 56px; height: 56px; }
            
            /* é¡¶éƒ¨å·¥å…·æ  - ç§»åŠ¨ç«¯é‡æ–°å¸ƒå±€ */
            .top-bar { 
                top: 8px; left: 8px; right: 8px;
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                gap: 5px;
                overflow: visible;
            }
            .tool-group { 
                gap: 5px; 
                flex-wrap: nowrap;
                overflow: visible;
            }
            .tool-group::-webkit-scrollbar { display: none; }
            .glass-btn { 
                padding: 5px 8px; font-size: 0.7rem; 
                border-radius: 12px;
                flex-shrink: 0;
            }
            /* ç§»åŠ¨ç«¯éšè—éƒ¨åˆ†æŒ‰é’®æ–‡å­—ï¼Œåªæ˜¾ç¤ºå›¾æ ‡ */
            .glass-btn .btn-text { display: none; }
            
            /* é¢æ¿ */
            .panel-float { 
                position: fixed;
                top: auto; bottom: 0; left: 0; right: 0;
                width: 100%; max-width: 100%;
                border-radius: 20px 20px 0 0;
                max-height: 70vh; overflow-y: auto;
                transform: translateY(100%);
                box-sizing: border-box;
            }
            .panel-float.show { transform: translateY(0); }
            
            /* ç§»åŠ¨ç«¯æ˜¾ç¤ºå…³é—­æŒ‰é’® */
            .panel-close { display: block; }
            
            #analyze-panel { 
                position: fixed;
                top: auto; bottom: 0; left: 0; right: 0;
                width: 100%;
            }
            #analyze-panel:not(.show) { transform: translateY(100%); }
            
            .playlist-sidebar { 
                width: 100%; max-width: 100%; 
                padding: 60px 15px 15px 15px; 
                box-sizing: border-box;
            }
            
            #debug-console { 
                position: fixed;
                width: calc(100% - 20px); left: 10px; right: 10px;
                top: auto; bottom: 10px; max-height: 120px;
            }
            
            .vol-popup { bottom: 50px; }
            .vol-popup.show { bottom: 55px; }
            
            /* æ‹–æ‹½é®ç½© */
            .drag-mask h1 { font-size: 1.5rem; }
            .drag-mask p { font-size: 0.9rem; }
            
            /* ç§»åŠ¨ç«¯ï¼šæ˜¾ç¤ºé«˜çº§æŒ‰é’®ï¼Œéšè—åŸæ¥çš„ä¸‰ä¸ª */
            .mobile-only { display: block; }
            .desktop-only { display: none !important; }
            .advanced-menu { right: 0; left: auto; }
        }
        
        /* è¶…å°å±å¹• */
        @media screen and (max-width: 400px) {
            .main-container { padding: 60px 10px 90px 10px; }
            .cover-wrapper { width: 60vw; padding-bottom: 60vw; max-width: 220px; }
            .track-title { font-size: 1.3rem; }
            .glass-btn { padding: 4px 6px; font-size: 0.65rem; }
            .controls-row { gap: 10px; }
            .btn { width: 38px; height: 38px; }
            .btn-play { width: 50px; height: 50px; }
            .lyrics-box { height: 150px; }
        }
    </style>
</head>
<body id="body">
    
    <div id="debug-console"><div>> Debugger Ready.</div></div>
    <canvas id="visual-canvas"></canvas>
    <div class="drag-mask"><h1>æŠ•å–‚éŸ³ä¹</h1><p>MP3 / FLAC / OGG / SLI</p></div>

    <!-- ä¸‹è½½æ¨¡æ€çª—å£ï¼ˆéšè—ï¼Œç‚¹å‡»ä¸‹è½½æŒ‰é’®å¼¹å‡ºï¼‰ -->
    <div id="download-modal" class="download-modal" style="display:none;">
        <div class="download-panel">
            <div class="download-header">
                <span id="download-title">ä¸‹è½½éŸ³è´¨</span>
                <button class="panel-close" id="download-close">&times;</button>
            </div>
            <div id="download-track-info" style="margin:8px 0;color:var(--text-sub);font-size:0.95rem"></div>
            <div id="download-list" style="display:flex;flex-direction:column;gap:8px;margin-bottom:12px"></div>
            <div style="text-align:right"><button class="glass-btn" id="download-cancel">å…³é—­</button></div>
        </div>
    </div>

    <!-- ç½‘æ˜“äº‘æœç´¢é¢æ¿ -->
    <div class="netease-panel" id="netease-panel">
        <div class="netease-content">
            <div class="netease-header">
                <h3>ğŸµ ç½‘æ˜“äº‘éŸ³ä¹</h3>
                <button class="netease-close" onclick="document.getElementById('netease-panel').classList.remove('show')">&times;</button>
            </div>
            <!-- ç”¨æˆ·çŠ¶æ€æ  -->
            <div id="netease-user-bar" class="netease-user-bar" style="display:none">
                <img class="netease-avatar" id="netease-avatar" src="">
                <div class="netease-user-info">
                    <div class="netease-nickname" id="netease-nickname">ç”¨æˆ·å</div>
                    <small class="netease-user-id" id="netease-user-id">ID: </small>
                    <span class="netease-user-type normal" id="netease-user-type">æ™®é€šç”¨æˆ·</span>
                </div>
                <button class="netease-logout-btn" onclick="neteaseLogout()">é€€å‡º</button>
            </div>
            <!-- éŸ³è´¨é€‰æ‹© -->
            <div id="netease-quality-bar" class="netease-quality-bar" style="display:none">
                <label for="netease-quality-select">ğŸ§ éŸ³è´¨:</label>
                <select id="netease-quality-select" class="netease-quality-select">
                    <option value="standard">æ ‡å‡† (128kbps)</option>
                    <option value="higher">è¾ƒé«˜ (192kbps)</option>
                    <option value="exhigh">æé«˜ (320kbps)</option>
                    <option value="lossless">æ— æŸ (FLAC)</option>
                    <option value="hires">Hi-Res</option>
                </select>
            </div>
            <button id="netease-login-btn" class="netease-login-btn" onclick="showQRLogin()">ğŸ” æ‰«ç ç™»å½•ç½‘æ˜“äº‘è´¦å·</button>
            
            <div class="netease-tabs">
                <button class="netease-tab active" data-tab="search">ğŸ” æœç´¢æ­Œæ›²</button>
                <button class="netease-tab" data-tab="playlist">ğŸ“‹ å¯¼å…¥æ­Œå•</button>
                <button class="netease-tab" data-tab="mylist">â¤ï¸ æˆ‘çš„æ­Œå•</button>
            </div>
            <!-- æœç´¢æ­Œæ›² -->
            <div class="netease-tab-content" id="tab-search">
                <div class="netease-search-box">
                    <input type="text" class="netease-input" id="netease-search-input" placeholder="è¾“å…¥æ­Œåã€æ­Œæ‰‹...">
                    <button class="netease-search-btn" id="netease-search-btn">æœç´¢</button>
                </div>
                <div class="netease-results" id="netease-search-results">
                    <div class="netease-empty">è¾“å…¥å…³é”®è¯æœç´¢æ­Œæ›²</div>
                </div>
            </div>
            <!-- å¯¼å…¥æ­Œå• -->
            <div class="netease-tab-content" id="tab-playlist" style="display:none">
                <div class="netease-search-box">
                    <input type="text" class="netease-input" id="netease-playlist-input" placeholder="ç²˜è´´æ­Œå•é“¾æ¥æˆ–ID...">
                    <button class="netease-search-btn" id="netease-playlist-btn">è·å–</button>
                </div>
                <div id="netease-playlist-preview"></div>
                <div class="netease-results" id="netease-playlist-results">
                    <div class="netease-empty">æ”¯æŒæ ¼å¼ï¼š<br>https://music.163.com/playlist?id=xxx<br>æˆ–ç›´æ¥è¾“å…¥æ­Œå•ID</div>
                </div>
            </div>
            <!-- æˆ‘çš„æ­Œå• -->
            <div class="netease-tab-content" id="tab-mylist" style="display:none">
                <div id="mylist-content" class="netease-results" style="border:none;background:none">
                    <div class="netease-empty">è¯·å…ˆç™»å½•ç½‘æ˜“äº‘è´¦å·</div>
                </div>
            </div>
            <!-- äºŒç»´ç ç™»å½• -->
            <div class="netease-tab-content" id="tab-qrlogin" style="display:none">
                <div class="qrcode-container">
                    <div id="qrcode-img-wrap"><div class="netease-loading">ç”ŸæˆäºŒç»´ç ä¸­...</div></div>
                    <div class="qrcode-tip">è¯·ä½¿ç”¨ç½‘æ˜“äº‘éŸ³ä¹APPæ‰«æäºŒç»´ç ç™»å½•</div>
                    <div class="qrcode-status waiting" id="qrcode-status">ç­‰å¾…æ‰«æ...</div>
                    <button class="glass-btn" style="margin-top:15px" onclick="refreshQRCode()">ğŸ”„ åˆ·æ–°äºŒç»´ç </button>
                </div>
            </div>
        </div>
    </div>

    <div class="top-bar">
        <div class="tool-group">
            <button id="btn-import" class="glass-btn mobile-only" title="å¯¼å…¥éŸ³ä¹æ–‡ä»¶">ğŸ“‚ å¯¼å…¥</button>
            <input type="file" id="file-input" multiple accept="audio/*,.lrc,.sli" style="display:none">
            <button id="toggle-netease-panel" class="glass-btn" title="æœç´¢ç½‘æ˜“äº‘éŸ³ä¹">â˜ï¸ <span class="btn-text">äº‘éŸ³ä¹</span></button>
            <!-- ç§»åŠ¨ç«¯ä¸‹è½½æŒ‰é’®ï¼Œæ”¾åœ¨äº‘éŸ³ä¹å³ä¾§ -->
            <button id="download-btn-mobile" class="glass-btn mobile-only" title="ä¸‹è½½">â¬‡ï¸</button>
            <button id="toggle-netease" class="glass-btn desktop-only" title="è‡ªåŠ¨ä»ç½‘æ˜“äº‘æœç´¢æ­Œè¯">ğŸ“ <span class="btn-text">äº‘è¯</span></button>
            <select id="effect-select" class="glass-btn desktop-only">
                <option value="none">âœ¨ æ— ç‰¹æ•ˆ</option>
                <option value="snow">â„ï¸ å‡›å†¬é£é›ª</option>
                <option value="bars">ğŸ“Š å¾‹åŠ¨é¢‘è°±</option>
                <option value="waves">ğŸŒŠ æå…‰æ³¢æµª</option>
            </select>
            <button id="toggle-debug" class="glass-btn desktop-only">ğŸ Debug</button>
        </div>
        <div class="tool-group">
            <button id="toggle-analyze" class="glass-btn desktop-only">ğŸ” æ™ºèƒ½åˆ†æ</button>
            <button id="toggle-loop-panel" class="glass-btn desktop-only">ğŸ” å¾ªç¯è®¾å®š</button>
            <button id="toggle-list" class="glass-btn">ğŸ“œ <span class="btn-text">åˆ—è¡¨</span></button>
            <!-- ç§»åŠ¨ç«¯é«˜çº§èœå• -->
            <div class="advanced-menu-container mobile-only">
                <button id="toggle-advanced" class="glass-btn">âš™ï¸ é«˜çº§</button>
                <div class="advanced-menu" id="advanced-menu">
                    <button class="advanced-menu-item" data-action="debug">ğŸ Debug</button>
                    <button class="advanced-menu-item" data-action="analyze">ğŸ” æ™ºèƒ½åˆ†æ</button>
                    <button class="advanced-menu-item" data-action="loop">ğŸ” å¾ªç¯è®¾å®š</button>
                    <button class="advanced-menu-item" data-action="netease-lyrics">ğŸ“ äº‘è¯å¼€å…³</button>
                    <button class="advanced-menu-item" data-action="lyric-toggle">ğŸˆ‚ï¸ åˆ‡æ¢æ­Œè¯ç¿»è¯‘</button>
                    <button class="advanced-menu-item" data-action="effects">âœ¨ è§†è§‰ç‰¹æ•ˆ</button>
                </div>
            </div>
        </div>
    </div>

    <div class="panel-float" id="analyze-panel">
        <h4 class="panel-title">Loop Analyzer (æ™ºèƒ½å¯¹é½åˆ†æ)<button class="panel-close" onclick="this.closest('.panel-float').classList.remove('show')">&times;</button></h4>
        <div style="font-size:0.8rem; color:#666; margin-bottom:10px;">
            ä¸çŸ¥é“åœ¨å“ªé‡Œè®¾ç½®å¾ªç¯ç‚¹ï¼Ÿè¯•è¯•æ™ºèƒ½åˆ†æï¼<br>
            1. ç²—ç•¥è®¾ç½® A/B ç‚¹ (å‰åè¯¯å·®<2s)<br>
            2. ç‚¹å‡»â€œå¼€å§‹åŒ¹é…â€ä¼šè‡ªåŠ¨å¯»æ‰¾æœ€ä½³æ¥ç¼å“¦ï¼
        </div>
        <div class="panel-row">
            <span>Rough Start (A)</span>
            <input type="number" id="ana-start" class="panel-input" step="0.1" placeholder="0.0">
        </div>
        <div class="panel-row">
            <span>Rough End (B)</span>
            <input type="number" id="ana-end" class="panel-input" step="0.1" placeholder="0.0">
        </div>
        
        <div class="analyze-btn-group">
            <button class="glass-btn" onclick="capturePoint('a')">ğŸ“ å®šä½ A</button>
            <button class="glass-btn" onclick="capturePoint('b')">ğŸ“ å®šä½ B</button>
        </div>
        <div class="analyze-btn-group">
            <button class="glass-btn" onclick="previewPoint('a')">ğŸ”Š è¯•å¬ A</button>
            <button class="glass-btn" onclick="previewPoint('b')">ğŸ”Š è¯•å¬ B</button>
        </div>
        
        <button class="glass-btn big-btn" onclick="runAnalysis()" style="margin-top:10px;">âœ¨ å¼€å§‹ç²¾ç¡®åŒ¹é…</button>
        <button class="glass-btn big-btn" onclick="exportSLI()" style="margin-top:8px; background:#27ae60;">ğŸ’¾ å¯¼å‡º .sli æ–‡ä»¶</button>
        <div id="ana-msg" style="font-size:0.75rem; text-align:center; min-height:1.2em; margin-top:5px;"></div>
    </div>

    <div class="loop-panel panel-float" id="loop-panel">
        <h4 class="panel-title">Loop Controller<button class="panel-close" onclick="this.closest('.panel-float').classList.remove('show')">&times;</button></h4>
        <div class="panel-row"><span>å¼€å¯å¾ªç¯</span><input type="checkbox" id="loop-enable"></div>
        <div class="panel-row" style="background:rgba(0,0,0,0.05); padding:5px; border-radius:5px;"><span title="ä¿®æ­£é‡‡æ ·ç‡">Base Rate (Hz)</span><input type="number" id="base-rate" class="panel-input" value="44100" step="100"></div>
        <div class="panel-row"><span>Start (A)</span><input type="number" id="loop-start" class="panel-input" step="0.001" value="0"></div>
        <div class="panel-row"><span>End (B)</span><input type="number" id="loop-end" class="panel-input" step="0.001" value="0"></div>
        <div style="display:flex; gap:10px; margin-top:5px;">
            <button class="glass-btn" style="flex:1; justify-content:center;" onclick="setLoopPoint('a')">Set A</button>
            <button class="glass-btn" style="flex:1; justify-content:center;" onclick="setLoopPoint('b')">Set B</button>
        </div>
        <div id="loop-msg" style="font-size:0.7rem; color:green; height:15px; text-align:right;"></div>
    </div>

    <div class="playlist-sidebar" id="playlist-sidebar"><h3 style="margin-top:0;">PLAYLIST</h3><div id="pl-container"></div></div>

    <div class="main-container">
        <div class="left-panel">
            <div class="cover-wrapper" id="cover-wrap">
                <div class="default-disc"></div>
                <img src="" class="album-img" id="album-img" crossorigin="anonymous">
                <div class="loading-tip" id="loading-tip">Decoding Audio...</div>
            </div>
            <div class="progress-section">
                <div class="time-display">
                    <span id="curr-time">00:00</span>
                    <span id="loop-status" style="color:#e74c3c; display:none; font-weight:bold; font-size:0.8rem">âˆ SEAMLESS</span>
                    <span id="total-time">00:00</span>
                </div>
                <div class="progress-bar-bg" id="prog-bg">
                    <div class="buffer-line" id="buffer-line"></div>
                    <div class="progress-line" id="prog-line"></div>
                    <div class="loop-marker" id="marker-a" data-label="A"></div>
                    <div class="loop-marker" id="marker-b" data-label="B"></div>
                </div>
            </div>
        </div>

        <div class="right-panel">
            <div class="track-header">
                <div class="track-title" id="track-title">Aurora Player</div>
                <div class="track-artist" id="track-artist">System Ready</div>
            </div>
            <div class="lyrics-box" id="lyrics-box">
                <div class="lyrics-scroll" id="lyrics-content"><div class="lyric-line active" style="margin-top: 100px;">Ready.</div></div>
            </div>
            <div class="controls-row">
                <button class="btn" id="mode-btn"><svg id="icon-list-loop" viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/></svg><svg id="icon-random" style="display:none" viewBox="0 0 24 24"><path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/></svg><svg id="icon-single" style="display:none" viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4zm-4-2V9h-1l-2 1v1h1.5v4H13z"/></svg></button>
                <button class="btn" id="prev-btn"><svg viewBox="0 0 24 24"><path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/></svg></button>
                <button class="btn btn-play" id="play-btn"><svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></button>
                <button class="btn" id="next-btn"><svg viewBox="0 0 24 24"><path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/></svg></button>
                <div class="vol-container">
                    <div class="vol-popup" id="vol-popup"><input type="range" class="vol-range" id="vol-range" min="0" max="1" step="0.01" value="1"></div>
                    <button class="btn" id="vol-btn" title="Volume"><svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg></button>
                </div>
                <button class="btn desktop-only" id="download-btn" title="ä¸‹è½½" style="margin-left:8px"><svg viewBox="0 0 24 24"><path d="M5 20h14v-2H5v2zm7-18L5.33 9h3.67v6h6V9h3.67L12 2z"/></svg></button>
                <button class="btn desktop-only" id="lyric-toggle-btn" title="åˆ‡æ¢æ­Œè¯æ˜¾ç¤º(åŸæ–‡/åŸ+è¯‘)" style="margin-left:8px; opacity:0.45"><svg viewBox="0 0 24 24"><path d="M4 6h16v2H4zM4 12h16v2H4zM4 18h16v2H4z"/></svg></button>
            </div>
        </div>
    </div>

    <script>
        const debugConsole = document.getElementById('debug-console');
        function log(msg, type='') {
            console.log(msg);
            const div = document.createElement('div');
            div.className = `log-item ${type==='error'?'log-err':(type==='success'?'log-suc':'')}`;
            div.textContent = `> ${msg}`;
            debugConsole.appendChild(div);
            debugConsole.scrollTop = debugConsole.scrollHeight;
        }

        // æ¸…æ´— Cookieï¼Œåªä¿ç•™æ ¸å¿ƒå‡­è¯ï¼ˆå¦‚ MUSIC_Uã€__csrfï¼‰ï¼Œå»æ‰æµè§ˆå™¨æŒ‡ä»¤ï¼ˆMax-Age/Expires/Path/Domain/SameSite/Secure/HttpOnlyï¼‰
        function cleanCookie(cookieStr) {
            if (!cookieStr) return '';
            return cookieStr.split(';')
                .map(part => part.trim())
                .filter(part => {
                    const lower = part.toLowerCase();
                    return !lower.startsWith('max-age=') && 
                           !lower.startsWith('expires=') && 
                           !lower.startsWith('path=') && 
                           !lower.startsWith('domain=') &&
                           !lower.startsWith('samesite=') &&
                           !lower.startsWith('httponly') &&
                           !lower.startsWith('secure');
                })
                .join('; ');
        }

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let actx = new AudioContext();
        let audioBuffer = null, sourceNode = null, gainNode = actx.createGain(), analyser = actx.createAnalyser();
        gainNode.connect(analyser); analyser.connect(actx.destination); analyser.fftSize = 512;

        let playbackState = { startTime: 0, pauseTime: 0, isPlaying: false, duration: 0 };
        let playlist = [], curIdx = -1, playMode = 0;
        let lyrics = [], isSyncedLyrics = true;
        let neteaseSearchEnabled = false; // ç½‘æ˜“äº‘æ­Œè¯æœç´¢å¼€å…³ï¼Œé»˜è®¤å…³é—­
        let loopState = { active: false, start: 0, end: 0 };
        let particles = [];
        let currentAbortController = null; // ç”¨äºå–æ¶ˆä¹‹å‰çš„ç½‘ç»œè¯·æ±‚
        // ---- ä¸‹ä¸€é¦–é¢„åŠ è½½ç›¸å…³ ----
        let nextSongRawData = null; // å­˜æ”¾é¢„åŠ è½½çš„ ArrayBufferï¼ˆä¸‹ä¸€é¦–ï¼‰
        let nextSongAbortController = null; // AbortControllerï¼ˆç”¨äºå–æ¶ˆé¢„åŠ è½½è¯·æ±‚ï¼‰
        let hasPreloaded = false; // æ˜¯å¦å·²å®Œæˆé¢„åŠ è½½
        let nextPreloadIndex = null; // é¢„åŠ è½½å¯¹åº”çš„æ’­æ”¾åˆ—è¡¨ç´¢å¼•
        let prefetchAttempted = false; // æ˜¯å¦å°è¯•è¿‡é¢„å–
        let prefetchInProgress = false; // é˜²æ­¢é‡å¤å‘èµ·é¢„å–
        let nextSongFetchPromise = null; // å¦‚æœé¢„å–æ­£åœ¨è¿›è¡Œï¼Œä¿å­˜å…¶ Promiseï¼ˆç”¨äºæ’­æ”¾æ—¶å¤ç”¨ï¼‰

        // ç­‰å¾…é¢„å–å®Œæˆï¼ˆçŸ­ç­‰å¾…ï¼‰ï¼Œè¿”å› true è¡¨ç¤ºé¢„å–å·²å®Œæˆä¸”æ•°æ®å¯ç”¨
        async function waitForPrefetchCompletion(timeoutMs = 3000) {
            if (hasPreloaded && nextSongRawData) return true;
            if (!prefetchInProgress) return false;
            return await new Promise(resolve => {
                const intervalMs = 50;
                let elapsed = 0;
                const iv = setInterval(() => {
                    if (hasPreloaded && nextSongRawData) {
                        clearInterval(iv); clearTimeout(to);
                        resolve(true);
                    } else if (!prefetchInProgress) {
                        clearInterval(iv); clearTimeout(to);
                        resolve(false);
                    }
                    elapsed += intervalMs;
                }, intervalMs);
                const to = setTimeout(() => {
                    clearInterval(iv);
                    resolve(false);
                }, timeoutMs);
            });
        }

        // ç­‰å¾…ä»»æ„ Promise åœ¨é™å®šæ—¶é—´å†…è§£æï¼ˆè¿”å› {ok, value}ï¼‰
        function waitForPromiseWithTimeout(promise, timeoutMs) {
            if (!promise) return Promise.resolve({ ok: false });
            let timer;
            return Promise.race([
                promise.then(v => ({ ok: true, value: v })).catch(e => ({ ok: false, err: e })),
                new Promise(res => { timer = setTimeout(() => res({ ok: false, timeout: true }), timeoutMs); })
            ]).then(r => { if (timer) clearTimeout(timer); return r; });
        }
        let currentPlaylistSongs = []; // å½“å‰æ­Œå•çš„æ‰€æœ‰æ­Œæ›²
        let currentPage = 0; // å½“å‰é¡µç 
        const SONGS_PER_PAGE = 50; // æ¯é¡µæ˜¾ç¤ºçš„æ­Œæ›²æ•°é‡

        // --- è¯·æ±‚é˜Ÿåˆ—ä¸ç¼“å­˜å·¥å…· ---
        // å¹¶å‘é˜Ÿåˆ—ï¼ˆé€šç”¨è¯·æ±‚ï¼Œé»˜è®¤å¹¶å‘3ï¼‰
        const requestQueue = [];
        let requestActive = 0;
        const REQUEST_CONCURRENCY = 3;
        function _processQueue() {
            if (requestActive >= REQUEST_CONCURRENCY) return;
            const task = requestQueue.shift();
            if (!task) return;
            requestActive++;
            const {fn, resolve, reject} = task;
            Promise.resolve().then(() => fn()).then(r => { resolve(r); }).catch(e => { reject(e); }).finally(() => { requestActive--; _processQueue(); });
        }
        function qFetch(url, options={}) {
            return new Promise((resolve, reject) => {
                requestQueue.push({ fn: () => fetch(url, options), resolve, reject });
                _processQueue();
            });
        }


        // ç®€å• IndexedDB ç¼“å­˜ï¼ˆmetadata onlyï¼‰
        const IDB_DB = 'aurora-cache';
        const IDB_STORE = 'metadata';
        function openIdb() {
            return new Promise((res, rej) => {
                const rq = indexedDB.open(IDB_DB, 1);
                rq.onupgradeneeded = () => { rq.result.createObjectStore(IDB_STORE); };
                rq.onsuccess = () => res(rq.result);
                rq.onerror = () => rej(rq.error);
            });
        }
        async function idbGet(key) {
            try {
                const db = await openIdb();
                return new Promise((res, rej) => {
                    const tx = db.transaction(IDB_STORE, 'readonly');
                    const store = tx.objectStore(IDB_STORE);
                    const r = store.get(key);
                    r.onsuccess = () => res(r.result);
                    r.onerror = () => rej(r.error);
                });
            } catch (e) { return null; }
        }
        async function idbSet(key, value) {
            try {
                const db = await openIdb();
                return new Promise((res, rej) => {
                    const tx = db.transaction(IDB_STORE, 'readwrite');
                    const store = tx.objectStore(IDB_STORE);
                    const r = store.put(value, key);
                    r.onsuccess = () => res(true);
                    r.onerror = () => rej(r.error);
                });
            } catch (e) { return false; }
        }

        // åˆ é™¤ IDB ä¸­çš„é”®ï¼ˆç”¨äºåˆ·æ–° cachedFetchJson çš„ç¼“å­˜ï¼‰
        async function idbDelete(key) {
            try {
                const db = await openIdb();
                return await new Promise((res, rej) => {
                    const tx = db.transaction(IDB_STORE, 'readwrite');
                    const store = tx.objectStore(IDB_STORE);
                    const r = store.delete(key);
                    r.onsuccess = () => res(true);
                    r.onerror = () => rej(r.error);
                });
            } catch (e) { return false; }
        }

        // cachedFetch: å°è¯•ä»IDBè·å– JSON ç¼“å­˜ï¼Œå¦åˆ™èµ°é˜Ÿåˆ—è¯·æ±‚å¹¶ç¼“å­˜
        async function cachedFetchJson(url, options = {}, ttl = 3600_000) {
            const key = 'json|' + url;
            try {
                const entry = await idbGet(key);
                const now = Date.now();
                if (entry && entry.ts && (now - entry.ts) < ttl) {
                    return entry.data;
                }
            } catch (e) {}
            // é€‰æ‹©é˜Ÿåˆ—æˆ–æ™®é€š fetch
            const useQueue = options.useQueue !== false;
            const fetchFn = useQueue ? qFetch : fetch;
            const resp = await fetchFn(url, options);
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const data = await resp.json();
            try { await idbSet(key, { ts: Date.now(), data }); } catch (e) {}
            return data;
        }

        // å–æ¶ˆä¸‹ä¸€é¦–é¢„åŠ è½½
        function cancelNextPreload() {
            try {
                if (nextSongAbortController) {
                    try { if (typeof nextSongAbortController.abort === 'function') nextSongAbortController.abort(); }
                    catch(e) {}
                    nextSongAbortController = null;
                }
            } finally {
                nextSongRawData = null;
                hasPreloaded = false;
                nextPreloadIndex = null;
                prefetchAttempted = false; // <--- åˆ‡æ­Œæ—¶é‡ç½®ä¸º false
                prefetchInProgress = false;
                try { nextSongFetchPromise = null; } catch (e) {}
            }
            log('Next-song preload cancelled', 'warn');
        }

        // é¢„åŠ è½½ä¸‹ä¸€é¦–åŸå§‹æ•°æ®ï¼ˆArrayBufferï¼‰ï¼Œæ”¯æŒæœ¬åœ°ä¸ç½‘æ˜“äº‘
        async function prefetchNextSong() {
            try {
                if (!playlist || playlist.length === 0 || curIdx < 0) return;
                
                // å•æ›²å¾ªç¯æ¨¡å¼ä¸‹ï¼Œä¸è¦é¢„åŠ è½½ä¸‹ä¸€é¦–ï¼Œçœæµ
                if (playMode === 2) return; 

                // å†³å®šä¸‹ä¸€é¦–ç´¢å¼•
                let nextIdx;
                if (playMode === 1) {
                    if (playlist.length === 1) return; 
                    // éšæœºæ¨¡å¼ï¼šé¢„åˆ¤ä¸‹ä¸€é¦–
                    nextIdx = Math.floor(Math.random() * playlist.length);
                    if (nextIdx === curIdx) nextIdx = (nextIdx + 1) % playlist.length;
                } else {
                    nextIdx = curIdx + 1 >= playlist.length ? 0 : curIdx + 1;
                }

                if (hasPreloaded && nextPreloadIndex === nextIdx) return; 
                if (prefetchInProgress) return; 
                prefetchInProgress = true;

                // å–æ¶ˆæ—§çš„
                if (nextSongAbortController) {
                    try { nextSongAbortController.abort(); } catch(e) {}
                    nextSongAbortController = null;
                }
                nextSongRawData = null; hasPreloaded = false; nextPreloadIndex = null; prefetchAttempted = false; // <--- åˆ‡æ­Œæ—¶é‡ç½®ä¸º false

                const nextTrack = playlist[nextIdx];
                if (!nextTrack) { prefetchInProgress = false; return; }

                let controller = null;

                // --- æœ¬åœ°æ–‡ä»¶é¢„åŠ è½½ ---
                if (nextTrack.file) {
                    controller = { aborted: false, abort() { this.aborted = true; } };
                    nextSongAbortController = controller;
                    try {
                        const ab = await nextTrack.file.arrayBuffer();
                        if (controller.aborted) return;
                        nextSongRawData = ab;
                        hasPreloaded = true;
                        nextPreloadIndex = nextIdx;
                        log(`Preloaded local file: ${nextTrack.name}`, 'success');
                    } catch (e) {
                        log('Local prefetch error', 'warn');
                    }
                    prefetchInProgress = false;
                    return;
                }

                // --- ç½‘æ˜“äº‘åœ¨çº¿é¢„åŠ è½½ ---
                controller = new AbortController();
                nextSongAbortController = controller;
                // ç«‹å³è®°å½•é¢„åŠ è½½ç›®æ ‡ç´¢å¼•ï¼Œä¾¿äºæ’­æ”¾è·¯å¾„å¤ç”¨æ­£åœ¨è¿›è¡Œçš„ Promise
                nextPreloadIndex = nextIdx;
                prefetchAttempted = true;
                // æ„é€  fetch promise å¹¶ä¿å­˜åˆ° nextSongFetchPromiseï¼Œä¾›æ’­æ”¾æ—¶å¤ç”¨
                try {
                    const songId = nextTrack.songId || nextTrack.songData?.id;
                    if (!songId) throw new Error('No ID');

                    const cookieParam = neteaseCookie ? `&cookie=${encodeURIComponent(cleanCookie(neteaseCookie))}` : '';
                    const apiUrl = buildApiUrl(`/song/url/v1?id=${songId}&level=${neteaseQuality}&os=pc${cookieParam}`);

                    // ä¿å­˜ Promiseï¼ˆåŒ…å«è·å–é“¾æ¥ä¸ä¸‹è½½ ArrayBuffer çš„å®Œæ•´æµç¨‹ï¼‰
                    nextSongFetchPromise = (async () => {
                        prefetchInProgress = true;
                        try {
                            const json = await cachedFetchJson(apiUrl, { signal: controller.signal, useQueue: true }, 30_000);
                            const audioUrl = json?.data?.[0]?.url?.replace('http://', 'https://');
                            if (!audioUrl) throw new Error('No URL (May need VIP)');
                            const br = json?.data?.[0]?.br || 0;
                            const size = json?.data?.[0]?.size || 0;
                            const sizeMB = (size / 1024 / 1024).toFixed(1);

                            const resp = await fetch(audioUrl, { signal: controller.signal });
                            if (!resp.ok) throw new Error('Fetch failed');
                            const ab = await resp.arrayBuffer();
                            return { ab, br, sizeMB };
                        } finally {
                            // ä¸åœ¨è¿™é‡Œæ¸…ç† prefetchInProgress â€” è®©è°ƒç”¨æ–¹æ ¹æ®çŠ¶æ€å¤„ç†
                        }
                    })();

                    // å¤„ç† Promise ç»“æœï¼šå¡«å……ç¼“å­˜å¹¶è®°å½•ä¿¡æ¯
                    nextSongFetchPromise.then(res => {
                        if (!res || controller.signal.aborted) return;
                        nextSongRawData = res.ab;
                        hasPreloaded = true;
                        nextPreloadIndex = nextIdx;
                        log(`Preloaded: ${nextTrack.name} [${res.br>0 ? Math.round(res.br/1000)+'k' : 'Unknown'}] ${res.sizeMB}MB`, 'success');
                        // å†™å…¥è¾…åŠ©ç¼“å­˜ä»¥ä¾¿ metadata å¯ç”¨
                        cachedFetchJson(buildApiUrl(`/song/detail?ids=${songId}${cookieParam}`), { useQueue: true }).catch(()=>{});
                        cachedFetchJson(buildApiUrl(`/lyric?id=${songId}${cookieParam}`), { useQueue: true }).catch(()=>{});
                    }).catch(e => {
                        if (e && e.name === 'AbortError') {
                            // aborted by cancelNextPreload
                        } else {
                            log('Prefetch net error: ' + (e && e.message), 'warn');
                        }
                    }).finally(() => {
                        prefetchInProgress = false;
                        // ä¿ç•™ nextSongFetchPromise until consumed or cancelled
                    });

                } catch (e) {
                    if (e.name !== 'AbortError') log('Prefetch setup error: ' + e.message, 'warn');
                    prefetchInProgress = false;
                    nextSongFetchPromise = null;
                }
            } catch (e) {
                prefetchInProgress = false;
            }
        }

        const el = {
            img: document.getElementById('album-img'), coverWrap: document.getElementById('cover-wrap'),
            title: document.getElementById('track-title'), artist: document.getElementById('track-artist'),
            lyricBox: document.getElementById('lyrics-content'),
            progBg: document.getElementById('prog-bg'), progLine: document.getElementById('prog-line'), bufferLine: document.getElementById('buffer-line'),
            currTime: document.getElementById('curr-time'), totalTime: document.getElementById('total-time'),
            plContainer: document.getElementById('pl-container'), playBtn: document.getElementById('play-btn'),
            effectSel: document.getElementById('effect-select'), canvas: document.getElementById('visual-canvas'),
            loopPanel: document.getElementById('loop-panel'), loopStart: document.getElementById('loop-start'), loopEnd: document.getElementById('loop-end'), loopEnable: document.getElementById('loop-enable'),
            baseRateInput: document.getElementById('base-rate'), loopMsg: document.getElementById('loop-msg'),
            markerA: document.getElementById('marker-a'), markerB: document.getElementById('marker-b'),
            modeBtn: document.getElementById('mode-btn'), loadTip: document.getElementById('loading-tip'),
            volBtn: document.getElementById('vol-btn'), volPopup: document.getElementById('vol-popup'), volRange: document.getElementById('vol-range'),
            // Analyze UI
            anaPanel: document.getElementById('analyze-panel'), anaStart: document.getElementById('ana-start'), anaEnd: document.getElementById('ana-end'), anaMsg: document.getElementById('ana-msg')
        };
        // ä¸‹è½½ UI å…ƒç´ 
        const downloadBtn = document.getElementById('download-btn');
        const downloadBtnMobile = document.getElementById('download-btn-mobile');
        const downloadModal = document.getElementById('download-modal');
        const downloadClose = document.getElementById('download-close');
        const downloadCancel = document.getElementById('download-cancel');
        const downloadListEl = document.getElementById('download-list');
        const downloadTitle = document.getElementById('download-title');
        const downloadTrackInfo = document.getElementById('download-track-info');

        // æ­Œè¯æ˜¾ç¤ºåˆ‡æ¢æ§ä»¶ä¸çŠ¶æ€
        const lyricToggleBtn = document.getElementById('lyric-toggle-btn');
        let lyricDisplayMode = localStorage.getItem('lyric_mode') || 'original'; // 'original' or 'both'
        let originalLyricsText = '';
        let translatedLyricsText = '';
        let originalLyricsArr = [];
        let translatedLyricsArr = [];

        function parseLyricsToArray(text) {
            if(!text) return [];
            const lines = text.split(/\r?\n/);
            const timeReg = /\[(\d{1,2}):(\d{2})(?:[:.](\d{2,3}))?\]/g;
            const out = [];
            lines.forEach(l => {
                const line = l.trim(); if(!line) return;
                const times = []; let match;
                while ((match = timeReg.exec(line)) !== null) {
                    const min = parseInt(match[1]); const sec = parseInt(match[2]); let ms = match[3] ? parseInt(match[3]) : 0;
                    if (match[3] && match[3].length === 2) ms *= 10;
                    times.push(min*60 + sec + ms/1000);
                }
                timeReg.lastIndex = 0;
                const txt = line.replace(/\[\d{1,2}:\d{2}(?:[:.\d]+)?\]/g, '').replace(/\[[a-zA-Z]+:.*?\]/g, '').trim();
                if(times.length > 0 && txt) { times.forEach(t => out.push({t, txt})); }
                else if (txt) out.push({t: -1, txt});
            });
            out.sort((a,b)=>a.t - b.t);
            return out;
        }

        function updateLyricToggleUI(enabled) {
            if(!lyricToggleBtn) return;
            lyricToggleBtn.disabled = !enabled;
            lyricToggleBtn.style.opacity = enabled ? '' : '0.45';
            if(!enabled) lyricToggleBtn.title = 'æš‚æ— æ­Œè¯ç¿»è¯‘';
            else lyricToggleBtn.title = lyricDisplayMode === 'original' ? 'åˆ‡æ¢ä¸ºï¼šåŸæ–‡ + ç¿»è¯‘' : 'åˆ‡æ¢ä¸ºï¼šä»…åŸæ–‡';
        }

        // Safe set artist tags (avoid duplicate appends)
        function setArtistTag(sourceText, qualityText) {
            const artistEl = el.artist;
            // Remove existing tag spans
            const existingSource = artistEl.querySelector('.tag-source');
            if (existingSource) existingSource.remove();
            const existingQuality = artistEl.querySelector('.tag-quality');
            if (existingQuality) existingQuality.remove();
            // Append new ones if provided
            if (sourceText) {
                const sp = document.createElement('span');
                sp.className = 'tag-source';
                sp.textContent = sourceText;
                artistEl.appendChild(document.createTextNode(' '));
                artistEl.appendChild(sp);
            }
            if (qualityText) {
                const sp2 = document.createElement('span');
                sp2.className = 'tag-quality';
                sp2.textContent = qualityText;
                artistEl.appendChild(document.createTextNode(' '));
                artistEl.appendChild(sp2);
            }
        }

        // æ¸²æŸ“å‡½æ•°ï¼ˆåœ¨åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼æ—¶å¤ç”¨ï¼‰
        function renderLyricsFromArrays(source) {
            const hasSynced = originalLyricsArr.some(l=>l.t>=0) || translatedLyricsArr.some(l=>l.t>=0);
            isSyncedLyrics = hasSynced;
            // åˆå¹¶æ—¶é—´ç‚¹ï¼ˆä¿ç•™ä¸‰ä½å°æ•°ä½œä¸ºkeyï¼‰
            const timeSet = new Set();
            originalLyricsArr.filter(l=>l.t>=0).forEach(l=>timeSet.add(l.t.toFixed(3)));
            translatedLyricsArr.filter(l=>l.t>=0).forEach(l=>timeSet.add(l.t.toFixed(3)));
            const times = Array.from(timeSet).map(t=>parseFloat(t)).sort((a,b)=>a-b);
            // æ„å»ºä¸» lyrics æ•°ç»„ï¼ˆç”¨äºé«˜äº®ä¸æ»šåŠ¨ï¼‰
            lyrics = [];
            el.lyricBox.innerHTML = `<div style="height:120px"></div>`;

            if(hasSynced && times.length) {
                times.forEach(t => {
                    const orig = originalLyricsArr.find(x => Math.abs(x.t - t) < 0.05);
                    const trans = translatedLyricsArr.find(x => Math.abs(x.t - t) < 0.05);
                    const otext = orig ? orig.txt : (trans ? trans.txt : '');
                    const ttext = trans ? trans.txt : '';

                    lyrics.push({ t, txt: otext });

                    const container = document.createElement('div');
                    container.className = 'lyric-line';
                    container.dataset.time = t;
                    container.onclick = () => startAudio(t);

                    if(lyricDisplayMode === 'original') {
                        container.textContent = otext || ttext || '';
                    } else {
                        const odiv = document.createElement('div'); odiv.textContent = otext || '';
                        const tdiv = document.createElement('div'); tdiv.className = 'lyric-translation'; tdiv.textContent = ttext || '';
                        container.appendChild(odiv); container.appendChild(tdiv);
                    }
                    el.lyricBox.appendChild(container);
                });
                el.lyricBox.innerHTML += '<div style="height:150px"></div>';
                // è®¾ç½®æ¥æºå’ŒéŸ³è´¨æ ‡ç­¾ï¼ˆé¿å…é‡å¤ï¼‰
                setArtistTag(source || '', currentAudioQuality || '');
            } else if(!hasSynced) {
                // æ— æ—¶é—´æ ‡ç­¾çš„çº¯æ–‡æœ¬æ­Œè¯
                const origText = originalLyricsArr.map(l=>l.txt).join('\n');
                const transText = translatedLyricsArr.map(l=>l.txt).join('\n');
                if(lyricDisplayMode === 'original') {
                    el.lyricBox.innerHTML = `<div style="padding:20px; text-align:center; white-space:pre-wrap; color:var(--text-main); font-size:1rem; line-height:1.8;">${origText || transText || 'æš‚æ— æ­Œè¯'}</div>`;
                } else {
                    el.lyricBox.innerHTML = `<div style="padding:20px; text-align:center; white-space:pre-wrap; color:var(--text-main); font-size:1rem; line-height:1.4;">${origText}</div><div style="padding:8px 20px;text-align:center;white-space:pre-wrap;color:var(--text-sub);font-size:0.95rem;line-height:1.6;">${transText}</div>`;
                }
            } else {
                el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">æš‚æ— æ­Œè¯</div>';
            }
            // å°è¯•ç«‹å³åˆ·æ–°é«˜äº®å¹¶å±…ä¸­å½“å‰æ’­æ”¾ä½ç½®
            try { refreshLyricHighlightAndCenter(); } catch(e) {}
        }

        if(lyricToggleBtn) {
            lyricToggleBtn.onclick = () => {
                lyricDisplayMode = lyricDisplayMode === 'original' ? 'both' : 'original';
                localStorage.setItem('lyric_mode', lyricDisplayMode);

                // If lyrics are time-synced, perform incremental DOM update to avoid layout jitter
                const lines = el.lyricBox.querySelectorAll('.lyric-line');
                if (lines && lines.length && (originalLyricsArr.some(l=>l.t>=0) || translatedLyricsArr.some(l=>l.t>=0))) {
                    if (lyricDisplayMode === 'both') {
                        // Add translation divs under each corresponding line if available
                        lines.forEach(lineEl => {
                            if (lineEl.querySelector('.lyric-translation')) return; // already added
                            const t = parseFloat(lineEl.dataset.time || -1);
                            if (isNaN(t) || t < 0) return;
                            const trans = translatedLyricsArr.find(x => Math.abs(x.t - t) < 0.05);
                            if (trans && trans.txt) {
                                const tdiv = document.createElement('div');
                                tdiv.className = 'lyric-translation';
                                tdiv.textContent = trans.txt;
                                lineEl.appendChild(tdiv);
                            }
                        });
                    } else {
                        // Remove all translation divs
                        el.lyricBox.querySelectorAll('.lyric-translation').forEach(n => n.remove());
                    }
                    updateLyricToggleUI(true);
                    return;
                }

                // Fallback: non-synced or no existing DOM lines â€” rebuild
                renderLyricsFromArrays();
                updateLyricToggleUI(true);
            };
            updateLyricToggleUI(false);
        }

        const QUALITY_LEVELS = [
            { key: 'standard', label: 'æ ‡å‡† (128kbps)' },
            { key: 'higher', label: 'è¾ƒé«˜ (192kbps)' },
            { key: 'exhigh', label: 'æé«˜ (320kbps)' },
            { key: 'lossless', label: 'æ— æŸ (FLAC)' },
            { key: 'hires', label: 'Hi-Res' }
        ];

        function closeDownloadModal() {
            downloadModal.classList.remove('show');
            downloadModal.style.display = 'none';
            downloadListEl.innerHTML = '';
        }

        downloadClose.onclick = closeDownloadModal;
        downloadCancel.onclick = closeDownloadModal;

        // ç§»åŠ¨ç«¯æŒ‰é’®è§¦å‘æ¡Œé¢ä¸‹è½½é€»è¾‘ï¼ˆå¤ç”¨åŒä¸€é€»è¾‘ï¼‰
        if (downloadBtnMobile) {
            downloadBtnMobile.onclick = () => { if (downloadBtn) downloadBtn.click(); };
        }

        // å¼¹å‡ºä¸‹è½½æ¨¡æ€å¹¶æ£€æµ‹å„éŸ³è´¨å¯ç”¨æ€§
        downloadBtn.onclick = async function() {
            const playing = window._currentPlaying || null;
            if (!playing) {
                alert('å½“å‰æ²¡æœ‰æ­£åœ¨æ’­æ”¾çš„å¯ä¸‹è½½æ­Œæ›²');
                return;
            }
            if (!playing.netease) {
                alert('å½“å‰ä»…æ”¯æŒç½‘æ˜“äº‘åœ¨çº¿æ­Œæ›²ä¸‹è½½');
                return;
            }
            const songId = playing.songId || playing.id || (playing.songData && (playing.songData.id || playing.songData.songId));
            const songName = playing.songData?.name || playing.name || 'Unknown';
            const artists = (playing.songData?.ar || playing.songData?.artists || []).map ? (playing.songData?.ar || playing.songData?.artists).map(a=>a.name).join(', ') : (playing.artists || '');

            downloadTitle.textContent = 'ä¸‹è½½éŸ³è´¨';
            downloadTrackInfo.textContent = `${songName}${artists ? ' â€” ' + artists : ''}`;
            downloadModal.style.display = 'flex';
            setTimeout(()=>downloadModal.classList.add('show'), 10);

            downloadListEl.innerHTML = '';
            const cookieParam = neteaseCookie ? `&cookie=${encodeURIComponent(cleanCookie(neteaseCookie))}` : '';

            for (const q of QUALITY_LEVELS) {
                const item = document.createElement('div');
                item.className = 'quality-item';
                item.dataset.level = q.key;
                const left = document.createElement('div');
                left.innerHTML = `<div style="font-weight:600">${q.label}</div><div class="quality-meta">æ£€æµ‹ä¸­â€¦</div>`;
                const right = document.createElement('div');
                right.className = 'quality-action';
                const checkBtn = document.createElement('button');
                checkBtn.className = 'glass-btn';
                checkBtn.textContent = 'æ£€æµ‹';
                right.appendChild(checkBtn);
                item.appendChild(left);
                item.appendChild(right);
                downloadListEl.appendChild(item);

                (async function(it, level){
                    try {
                        // === 1. æ„å»ºè·å–é“¾æ¥çš„ URL (åˆ†å±‚ç­–ç•¥) ===
                        // VIPç”¨æˆ·ï¼šä¼ªè£…æˆ PC å®¢æˆ·ç«¯ (os=pc)ï¼Œèµ°æ­£è§„æµç¨‹
                        // æ™®é€šç”¨æˆ· & é«˜éŸ³è´¨ï¼šè£¸å¥” (ä¸å¸¦ os=pc)ï¼Œè§¦å‘ API æ¼æ´æ‹¿ FLAC
                        // æ™®é€šç”¨æˆ· & ä½éŸ³è´¨ï¼šä¼ªè£… (os=pc)ï¼Œæ­£å¸¸æ‹¿ MP3
                        const isVipUser = neteaseUser && neteaseVipType > 0;
                        const isHighResTarget = (level === 'lossless' || level === 'hires');
                        
                        let apiUrl;
                        if (isVipUser) {
                            apiUrl = buildApiUrl(`/song/url/v1?id=${songId}&level=${level}&os=pc${cookieParam}`);
                        } else {
                            if (isHighResTarget) {
                                // å…³é”®ï¼šæ™®é€šç”¨æˆ·ä¸‹é«˜éŸ³è´¨ï¼Œç›´æ¥æ‹¼ URLï¼Œä¸èµ° buildApiUrl (é¿å… randomCNIP)ï¼Œä¹Ÿä¸å¸¦ os=pc
                                apiUrl = `${NETEASE_API_HOST}/song/url/v1?id=${songId}&level=${level}${cookieParam}`;
                            } else {
                                apiUrl = buildApiUrl(`/song/url/v1?id=${songId}&level=${level}&os=pc${cookieParam}`);
                            }
                        }
                        
                        // === 2. è·å–ç›´é“¾ ===
                        const json = await cachedFetchJson(apiUrl, { useQueue: true }, 30_000);
                        const data = json?.data && json.data[0] ? json.data[0] : null;
                        const metaEl = it.querySelector('.quality-meta');
                        const rightArea = it.querySelector('.quality-action');
                        
                        // åˆ¤æ–­è¯·æ±‚æ˜¯å¦æˆåŠŸä¸”æœ‰æ•°æ®
                        if (json && json.code === 200 && data && data.url) {
                            // ----------------- æˆåŠŸè·å–é“¾æ¥ -----------------
                            
                            // 1. ç§»é™¤ç¦ç”¨çŠ¶æ€ï¼ˆé˜²æ­¢é‡è¯•æ—¶çŠ¶æ€æ®‹ç•™ï¼‰
                            it.classList.remove('disabled');

                            // 2. æ™ºèƒ½æ¨æ–­çœŸå®æ ¼å¼
                            const urlLower = data.url.toLowerCase();
                            const br = data.br || 0;
                            const size = data.size || 0;
                            
                            let realExt = 'mp3'; // é»˜è®¤æ ¼å¼
                            let isLossless = false;

                            // åˆ¤å®šé€»è¾‘ï¼šURLå«flac / APIç±»å‹ä¸ºflac / æ–‡ä»¶ä½“ç§¯å·¨å¤§
                            if (urlLower.includes('.flac')) { realExt = 'flac'; isLossless = true; } 
                            else if (data.type && data.type.toLowerCase() === 'flac') { realExt = 'flac'; isLossless = true; }
                            else if (size > 20 * 1024 * 1024) { realExt = 'flac'; isLossless = true; }

                            // 3. æ„å»ºç”¨æˆ·æ˜“è¯»çš„ä¿¡æ¯æ–‡æœ¬
                            let metaText = realExt.toUpperCase();
                            
                            // æ£€æµ‹æ˜¯å¦å‘ç”Ÿäº†â€œè¶Šçº§â€è·å–ï¼ˆä¾‹å¦‚ç‚¹æ ‡å‡†éŸ³è´¨ï¼Œå®é™…ç»™äº†æ— æŸï¼‰
                            const isUpgrade = (level === 'standard' || level === 'higher') && isLossless;
                            if (isUpgrade) {
                                metaText += " (è‡ªåŠ¨å‡çº§)"; // æç¤º
                            }
                            
                            // æ‹¼æ¥ç ç‡ (ä¾‹å¦‚: 320kbps)
                            if (br > 0) metaText += ` ${Math.round(br/1000)}kbps`;
                            
                            // æ‹¼æ¥å¤§å° (ä¾‹å¦‚: 12.5MB)
                            if (size > 0) {
                                const sizeMB = (size / 1024 / 1024).toFixed(1);
                                metaText += ` ${sizeMB}MB`;
                            }
                            
                            // 4. æ›´æ–°ç•Œé¢æ˜¾ç¤º
                            metaEl.textContent = metaText;
                            // å¦‚æœæ˜¯å‡çº§éŸ³è´¨ï¼Œç”¨é†’ç›®é¢œè‰²ï¼ˆä¾‹å¦‚çº¢è‰²æˆ–ä¸»é¢˜è‰²ï¼‰æç¤º
                            metaEl.style.color = isUpgrade ? '#e74c3c' : 'var(--text-sub)';

                            // 5. ç”Ÿæˆä¸‹è½½æŒ‰é’®
                            rightArea.innerHTML = '';
                            const dlBtn = document.createElement('button');
                            dlBtn.className = 'glass-btn';
                            dlBtn.textContent = 'ä¸‹è½½';
                            
                            // ç»‘å®šä¸‹è½½äº‹ä»¶ (ä¿æŒä½ ä¹‹å‰çš„ Worker ä»£ç†é€»è¾‘)
                            dlBtn.onclick = () => {
                                const safeName = (songName + ' - ' + artists).replace(/[\\/:*?"<>|]+/g, '_').slice(0,120);
                                const fileName = `${safeName} [${level}].${realExt}`;
                                
                                // ä½¿ç”¨é…ç½®å¥½çš„ Worker åœ°å€ï¼Œå¦‚æœæ²¡æœ‰åˆ™å›é€€åˆ°ç›¸å¯¹è·¯å¾„
                                const baseUrl = window.DOWNLOAD_PROXY_URL || '/proxy-download'; 
                                const proxyUrl = `${baseUrl}?url=${encodeURIComponent(data.url)}&filename=${encodeURIComponent(fileName)}`;
                                
                                const a = document.createElement('a');
                                a.href = proxyUrl;
                                a.target = '_blank';
                                a.download = fileName;
                                document.body.appendChild(a);
                                a.click();
                                a.remove();
                            };
                            rightArea.appendChild(dlBtn);

                        } else {
                            // ----------------- è·å–å¤±è´¥ (å˜ç°å¤„ç†) -----------------
                            
                            // 1. ç»™æ•´è¡Œæ·»åŠ  disabled ç±» (CSSä¸­éœ€è®¾ç½® opacity: 0.5; pointer-events: none;)
                            it.classList.add('disabled');
                            
                            // 2. æ›´æ–°æ–‡æœ¬æç¤º
                            metaEl.textContent = 'æš‚æ— èµ„æº / éœ€VIP';
                            metaEl.style.color = 'var(--text-sub)'; // æ¢å¤é»˜è®¤é¢œè‰²
                            
                            // 3. æ˜¾ç¤ºä¸å¯ç”¨æŒ‰é’®
                            rightArea.innerHTML = '';
                            const noBtn = document.createElement('button');
                            noBtn.className = 'glass-btn';
                            noBtn.textContent = 'ä¸å¯ç”¨';
                            noBtn.disabled = true; // ç¦ç”¨æŒ‰é’®äº¤äº’
                            noBtn.style.background = 'rgba(0,0,0,0.05)'; // æŒ‰é’®é¢œè‰²ç¨å¾®å˜æ·¡
                            rightArea.appendChild(noBtn);
                        }
                    } catch (e) {
                        it.classList.add('disabled');
                        const metaEl = it.querySelector('.quality-meta'); if (metaEl) metaEl.textContent = 'Err';
                        const rightArea = it.querySelector('.quality-action'); rightArea.innerHTML = '';
                    }
                })(item, q.key);
            }
        };
        const colorThief = new ColorThief();
        const canvasCtx = el.canvas.getContext('2d');

        // --- æ ¸å¿ƒï¼šè‡ªåŠ¨æ³¢å½¢åŒ¹é…ç®—æ³• (å‡çº§ç‰ˆï¼šMSE + è¿‡é›¶ç‚¹ä¼˜åŒ–) ---
        function runAnalysis() {
            if (!audioBuffer) { el.anaMsg.textContent = "Please load audio first!"; return; }
            
            const roughA = parseFloat(el.anaStart.value);
            const roughB = parseFloat(el.anaEnd.value);
            if (isNaN(roughA) || isNaN(roughB) || roughB <= roughA) {
                el.anaMsg.textContent = "Invalid range (A must < B)"; return;
            }

            el.anaMsg.textContent = "Analyzing... (This may take a moment)";
            el.anaMsg.style.color = "var(--accent)";

            requestAnimationFrame(() => {
                setTimeout(() => {
                    try {
                        // å°è¯•ä¸‰æ¬¡ï¼šåŸå§‹Bç‚¹ã€B+0.1sã€B-0.1s
                        const attempts = [
                            { bOffset: 0, label: "åŸå§‹" },
                            { bOffset: 0.1, label: "B+0.1s" },
                            { bOffset: -0.1, label: "B-0.1s" }
                        ];
                        
                        let bestResult = null;
                        let bestConfidence = 0;
                        let bestLabel = "";
                        
                        for (const attempt of attempts) {
                            const adjustedB = roughB + attempt.bOffset;
                            if (adjustedB <= roughA) continue; // è·³è¿‡æ— æ•ˆèŒƒå›´
                            
                            const result = findBestMatch(audioBuffer, roughA, adjustedB);
                            if (result) {
                                const confidence = Math.max(0, (1 - result.diff) * 100);
                                log(`å°è¯• ${attempt.label}: ç½®ä¿¡åº¦ ${confidence.toFixed(1)}%`);
                                
                                // å¦‚æœç½®ä¿¡åº¦ >= 99%ï¼Œç«‹å³é‡‡ç”¨
                                if (confidence >= 99) {
                                    bestResult = result;
                                    bestConfidence = confidence;
                                    bestLabel = attempt.label;
                                    break; // æ‰¾åˆ°æ»¡æ„ç»“æœï¼Œåœæ­¢å°è¯•
                                }
                                
                                // è®°å½•æœ€ä½³ç»“æœ
                                if (confidence > bestConfidence) {
                                    bestResult = result;
                                    bestConfidence = confidence;
                                    bestLabel = attempt.label;
                                }
                            }
                        }
                        
                        // åˆ¤æ–­æœ€ç»ˆç»“æœ
                        if (bestResult && bestConfidence >= 99) {
                            applyLoop(bestResult.start, bestResult.end);
                            el.anaMsg.textContent = `âœ¨ æ¬¸å˜¿å˜¿ æ‰¾åˆ°äº†! [${bestLabel}] (ç½®ä¿¡åº¦: ${bestConfidence.toFixed(1)}%)`;
                            el.anaMsg.style.color = "#27ae60";
                            log(`Auto-Loop: ${bestResult.start.toFixed(4)}s -> ${bestResult.end.toFixed(4)}s`, 'success');
                        } else if (bestResult) {
                            el.anaMsg.textContent = `âŒ å¥½åƒä¸å¯¹å“¦ï¼Ÿ (æœ€é«˜: ${bestConfidence.toFixed(1)}% < 99%). è¯·å†è°ƒæ•´ A/B ç‚¹è¯•è¯•å§ï¼`;
                            el.anaMsg.style.color = "#e74c3c";
                            log(`All attempts failed. Best: ${bestConfidence.toFixed(1)}%`, 'error');
                        } else {
                            el.anaMsg.textContent = "Could not find a seamless match nearby.";
                            el.anaMsg.style.color = "#e74c3c";
                        }
                    } catch (e) {
                        el.anaMsg.textContent = "Error: " + e.message;
                        console.error(e);
                    }
                }, 50);
            });
        }

        /**
         * å¯»æ‰¾æœ€ä½³å¾ªç¯ç‚¹ (æ”¹è‰¯ç‰ˆ)
         * 1. ç²—ç•¥æœç´¢ï¼šä½¿ç”¨å‡æ–¹å·® (MSE) æ‰¾åˆ°æ³¢å½¢æœ€ç›¸ä¼¼çš„ä½ç½®
         * 2. ç²¾ç»†è°ƒæ•´ï¼šå¯»æ‰¾æœ€è¿‘çš„"è¿‡é›¶ç‚¹ (Zero Crossing)"ï¼Œæ¶ˆé™¤çˆ†éŸ³
         */
        function findBestMatch(buffer, timeA, timeB) {
            const chan0 = buffer.getChannelData(0); 
            // å¦‚æœæ˜¯åŒå£°é“ï¼Œå–ä¸¤ä¸ªå£°é“å¹³å‡å€¼è¿›è¡Œåˆ†æï¼Œæ•ˆæœæ›´å‡†
            let data = chan0;
            if (buffer.numberOfChannels > 1) {
                const chan1 = buffer.getChannelData(1);
                data = new Float32Array(chan0.length);
                for(let i=0; i<chan0.length; i++) data[i] = (chan0[i] + chan1[i]) / 2;
            }

            const sr = buffer.sampleRate;
            
            // å‚æ•°è®¾å®š
            const searchRadius = 3.0; // æœç´¢åŠå¾„æ‰©å¤§åˆ° 3ç§’
            const windowSize = Math.floor(0.15 * sr); // åŒ¹é…çª—å£ 150ms (è¶³å¤Ÿè¯†åˆ«èŠ‚å¥)
            
            const centerB = Math.floor(timeB * sr);
            const centerA = Math.floor(timeA * sr);

            // 1. å®šä¹‰ B ç‚¹çš„ç‰¹å¾æ¨¡æ¿ (å– B ç‚¹ä¹‹å‰çš„ä¸€æ®µå£°éŸ³)
            const templateStart = centerB - windowSize;
            
            // è¾¹ç•Œæ£€æŸ¥
            if (templateStart < 0 || centerB >= data.length) throw new Error("End point out of bounds");
            
            // A ç‚¹æœç´¢èŒƒå›´
            const startIdx = Math.max(0, centerA - Math.floor(searchRadius * sr));
            const endIdx = Math.min(centerB - windowSize * 2, centerA + Math.floor(searchRadius * sr));

            // --- é˜¶æ®µ 1: ç²—ç•¥ MSE æ‰«æ (è·³æ­¥æ‰«æä»¥æå‡é€Ÿåº¦) ---
            let bestOffset = -1;
            let minDiff = Infinity;
            const step = 4; // ç²¾åº¦æ­¥é•¿

            for (let i = startIdx; i < endIdx; i += step) {
                let diff = 0;
                // ä¼˜åŒ–ï¼šåªå¯¹æ¯”éƒ¨åˆ†é‡‡æ ·ç‚¹ä¼°ç®—ç›¸ä¼¼åº¦ï¼Œæå¤§æå‡æ€§èƒ½
                for (let j = 0; j < windowSize; j += 10) { 
                    const delta = data[i + j] - data[templateStart + j];
                    diff += delta * delta;
                    // å¦‚æœå·®å¼‚å·²ç»å¤§äºå½“å‰æœ€å°å€¼ï¼Œæå‰æ”¾å¼ƒ (å‰ªæä¼˜åŒ–)
                    if (diff > minDiff) break;
                }
                
                if (diff < minDiff) {
                    minDiff = diff;
                    bestOffset = i;
                }
            }

            // --- é˜¶æ®µ 2: å±€éƒ¨ç²¾ç»†ä¼˜é€‰ (é€ç‚¹æ‰«æ) ---
            let fineBest = bestOffset;
            let fineMinDiff = Infinity;
            const fineRange = 200; // åœ¨ç²—ç•¥ç‚¹å‰å 200 é‡‡æ ·å†…ç²¾ç»†æ‰¾

            for (let i = bestOffset - fineRange; i <= bestOffset + fineRange; i++) {
                let diff = 0;
                for (let j = 0; j < windowSize; j += 2) { // æé«˜é‡‡æ ·å¯†åº¦
                    const delta = data[i + j] - data[templateStart + j];
                    diff += delta * delta;
                }
                if (diff < fineMinDiff) {
                    fineMinDiff = diff;
                    fineBest = i;
                }
            }

            // è®¡ç®— A ç‚¹ä½ç½®
            let refinedA = fineBest + windowSize; 

            // è®¡ç®—å½’ä¸€åŒ–å·®å¼‚åº¦
            const normalizedDiff = fineMinDiff / (windowSize / 2);
            
            return { 
                start: refinedA / sr, 
                end: timeB,
                diff: normalizedDiff 
            };
        }

        // è¾…åŠ©ï¼šæ•è·å½“å‰æ’­æ”¾æ—¶é—´
        function capturePoint(type) {
            const t = getCurrentTime();
            if(type === 'a') el.anaStart.value = t.toFixed(3);
            else el.anaEnd.value = t.toFixed(3);
        }
        
        // è¾…åŠ©ï¼šè¯•å¬
        function previewPoint(type) {
            const t = parseFloat(type==='a' ? el.anaStart.value : el.anaEnd.value);
            if (!isNaN(t)) {
                // æ’­æ”¾è¯¥ç‚¹å‰åå„3ç§’ (å…±6ç§’)
                startAudio(Math.max(0, t - 3));
                setTimeout(() => stopAudio(), 6000);
            }
        }

        // å¯¼å‡º .sli æ–‡ä»¶
        function exportSLI() {
            if (!loopState.active || loopState.start >= loopState.end) {
                el.anaMsg.textContent = "è¯·å…ˆè®¾ç½®æœ‰æ•ˆçš„å¾ªç¯åŒºé—´å‘¢ï¼";
                el.anaMsg.style.color = "red";
                return;
            }
            
            const rate = parseInt(el.baseRateInput.value) || 44100;
            // SLIæ ¼å¼: From = ç»“æŸé‡‡æ ·ç‚¹; To = å¼€å§‹é‡‡æ ·ç‚¹
            const fromSamples = Math.round(loopState.end * rate);
            const toSamples = Math.round(loopState.start * rate);
            
            const sliContent = `From = ${fromSamples};\nTo = ${toSamples};`;
            
            // åˆ›å»º Blob å¹¶ä¸‹è½½
            const blob = new Blob([sliContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            // ä½¿ç”¨å½“å‰æ›²ç›®åç§°
            const fileName = playlist[curIdx]?.name || 'loop';
            a.download = `${fileName}.sli`;
            
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            el.anaMsg.textContent = `å·²å¯¼å‡º: ${fileName}.sli`;
            el.anaMsg.style.color = "#27ae60";
            log(`SLI Exported: From=${fromSamples}, To=${toSamples}`, 'success');
        }

        async function parseFlacTagsNative(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const buffer = e.target.result;
                    const view = new DataView(buffer);
                    let offset = 0;
                    if (view.getUint32(0) !== 0x664C6143) { resolve(null); return; }
                    offset += 4;
                    log("FLAC Header Found.", 'success');
                    
                    let tags = {};
                    let loopLimit = 0;
                    
                    // éå†æ‰€æœ‰å…ƒæ•°æ®å—
                    while(offset < view.byteLength && loopLimit < 100) {
                        loopLimit++;
                        const header = view.getUint8(offset);
                        const isLast = (header & 0x80) !== 0;
                        const type = header & 0x7F;
                        const len = view.getUint32(offset) & 0x00FFFFFF; 
                        offset += 4;
                        
                        const blockEnd = offset + len;
                        
                        // Type 0: STREAMINFO (é‡‡æ ·ç‡ã€ä½æ·±åº¦ç­‰)
                        if (type === 0 && len >= 18) {
                            try {
                                // Bytes 10-13: é‡‡æ ·ç‡(20bits) + é€šé“æ•°(3bits) + ä½æ·±åº¦(5bits) + æ€»é‡‡æ ·æ•°é«˜4ä½
                                const byte10 = view.getUint8(offset + 10);
                                const byte11 = view.getUint8(offset + 11);
                                const byte12 = view.getUint8(offset + 12);
                                
                                // é‡‡æ ·ç‡: å‰20ä½ (byte10å…¨éƒ¨ + byte11å…¨éƒ¨ + byte12å‰4ä½)
                                const sampleRate = (byte10 << 12) | (byte11 << 4) | (byte12 >> 4);
                                // ä½æ·±åº¦: byte12å1ä½ + byte13å‰4ä½ (5ä½æ€»å…±), +1å¾—åˆ°å®é™…å€¼
                                const byte13 = view.getUint8(offset + 13);
                                const bitsPerSample = (((byte12 & 0x01) << 4) | (byte13 >> 4)) + 1;
                                
                                tags.sampleRate = sampleRate;
                                tags.bitsPerSample = bitsPerSample;
                                log(`FLAC: ${sampleRate}Hz ${bitsPerSample}bit`, 'success');
                            } catch(err) { log("STREAMINFO Parse Error: " + err, 'error'); }
                        }
                        
                        // Type 4: Vorbis Comment (æ ‡ç­¾ä¿¡æ¯)
                        if (type === 4) { 
                            try {
                                let pos = offset;
                                const vendorLen = view.getUint32(pos, true);
                                pos += 4 + vendorLen;
                                const commentListLen = view.getUint32(pos, true);
                                pos += 4;
                                const decoder = new TextDecoder("utf-8");
                                for(let i=0; i<commentListLen; i++) {
                                    const commentLen = view.getUint32(pos, true);
                                    pos += 4;
                                    const commentStr = decoder.decode(new Uint8Array(buffer, pos, commentLen));
                                    pos += commentLen;
                                    const splitIdx = commentStr.indexOf('=');
                                    if(splitIdx > -1) {
                                        const key = commentStr.substring(0, splitIdx).toUpperCase();
                                        const val = commentStr.substring(splitIdx + 1);
                                        if(key === 'LYRICS' || key === 'UNSYNCED LYRICS') tags.lyrics = val;
                                        else if (key === 'TITLE') tags.title = val;
                                        else if (key === 'ARTIST') tags.artist = val;
                                        else if (key === 'ALBUM') tags.album = val;
                                    }
                                }
                                log("FLAC Vorbis Comment parsed.", 'success');
                            } catch(err) { log("Vorbis Comment Parse Error: " + err, 'error'); }
                        }
                        
                        // Type 6: PICTURE (å°é¢å›¾ç‰‡)
                        if (type === 6) {
                            try {
                                let pos = offset;
                                // è·³è¿‡ picture type (4 bytes)
                                pos += 4;
                                // MIME type é•¿åº¦ (big endian)
                                const mimeLen = view.getUint32(pos);
                                pos += 4;
                                // MIME type å­—ç¬¦ä¸²
                                const mimeBytes = new Uint8Array(buffer, pos, mimeLen);
                                const mimeType = new TextDecoder("ascii").decode(mimeBytes);
                                pos += mimeLen;
                                // è·³è¿‡ description é•¿åº¦å’Œå†…å®¹
                                const descLen = view.getUint32(pos);
                                pos += 4 + descLen;
                                // è·³è¿‡ width, height, color depth, indexed colors (å„4å­—èŠ‚)
                                pos += 16;
                                // å›¾ç‰‡æ•°æ®é•¿åº¦
                                const picLen = view.getUint32(pos);
                                pos += 4;
                                // æ£€æŸ¥æ•°æ®æ˜¯å¦å®Œæ•´
                                if (pos + picLen <= buffer.byteLength) {
                                    const picData = new Uint8Array(buffer, pos, picLen);
                                    tags.picture = {
                                        format: mimeType,
                                        data: picData
                                    };
                                    log(`FLAC Picture found: ${mimeType}, ${picLen} bytes`, 'success');
                                } else {
                                    log(`FLAC Picture truncated, need ${pos + picLen} bytes, only have ${buffer.byteLength}`, 'error');
                                }
                            } catch(err) { log("FLAC Picture Parse Error: " + err, 'error'); }
                        }
                        
                        offset = blockEnd;
                        if (isLast) break;
                    }
                    
                    resolve(Object.keys(tags).length > 0 ? tags : null);
                };
                // å¢å¤§è¯»å–å¤§å°åˆ° 5MBï¼Œç¡®ä¿èƒ½è¯»å–åˆ°å¤§å°é¢å›¾ç‰‡
                reader.readAsArrayBuffer(file.slice(0, 5 * 1024 * 1024));
            });
        }

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => document.body.addEventListener(e, ev => { ev.preventDefault(); ev.stopPropagation(); }));
        document.body.addEventListener('dragenter', () => document.body.classList.add('drag-on'));
        document.body.addEventListener('dragleave', (e) => { if(e.clientX===0 && e.clientY===0) document.body.classList.remove('drag-on'); });
        document.body.addEventListener('drop', handleDrop);

        // æ–‡ä»¶å¯¼å…¥æŒ‰é’®äº‹ä»¶
        const fileInput = document.getElementById('file-input');
        document.getElementById('btn-import').addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFiles(Array.from(e.target.files));
                e.target.value = ''; // é‡ç½®ï¼Œå…è®¸é‡å¤é€‰æ‹©åŒä¸€æ–‡ä»¶
            }
        });

        function handleFiles(files) {
            const audios = files.filter(f => f.type.startsWith('audio/') || /\.(mp3|flac|wav|m4a|ogg)$/i.test(f.name));
            const lrcs = {}, slis = {};
            files.forEach(f => {
                if(f.name.endsWith('.lrc')) lrcs[f.name.replace('.lrc','')] = f;
                if(f.name.endsWith('.sli') || f.name.includes('.ogg.sli')) {
                    let base = f.name.replace('.sli','').replace('.ogg','');
                    slis[base] = f;
                }
            });
            if(audios.length) {
                playlist = audios.map(f => {
                    const base = f.name.replace(/\.[^.]+$/, "");
                    return { file: f, name: base, lrcFile: lrcs[base] || null, sliFile: slis[base] || null };
                });
                playlist.sort((a,b) => a.name.localeCompare(b.name));
                renderPlaylist();
                playTrack(0);
            } else if (Object.keys(slis).length > 0 && curIdx !== -1) {
                const cur = playlist[curIdx];
                if(slis[cur.name]) { cur.sliFile = slis[cur.name]; parseSLI(cur); }
            }
        }

        function handleDrop(e) {
            document.body.classList.remove('drag-on');
            handleFiles(Array.from(e.dataTransfer.files));
        }

        async function playTrack(i) {
            if(i < 0 || i >= playlist.length) return;
            prefetchAttempted = false; // æ–°å¢ï¼šæ— è®ºæ€ä¹ˆåˆ‡æ­Œï¼Œå…ˆé‡ç½®é¢„åŠ è½½çŠ¶æ€
            curIdx = i; renderPlaylist();
            // æ ‡è®°å½“å‰æ’­æ”¾æ›²ç›®ä¿¡æ¯ï¼Œä¾›ä¸‹è½½æŒ‰é’®ä½¿ç”¨ï¼ˆå¯èƒ½æ¥æºäºæ’­æ”¾åˆ—è¡¨æˆ–æœ¬åœ°æ–‡ä»¶ï¼‰
            try{
                const trackInfo = playlist[i];
                window._currentPlaying = {
                    netease: !!trackInfo.netease,
                    songData: trackInfo.songData || null,
                    songId: trackInfo.songId || trackInfo.id || null,
                    name: trackInfo.name || trackInfo.songData?.name || '',
                    artists: (trackInfo.songData?.ar || trackInfo.artists || trackInfo.ar || []).map ? (trackInfo.songData?.ar || trackInfo.ar || trackInfo.artists).map(a=>a.name).join(', ') : (trackInfo.artists || '') ,
                    file: trackInfo.file || null
                };
            }catch(e){}
            const track = playlist[i];
            stopAudio();
            currentAudioQuality = ''; // å…ˆæ¸…é™¤ï¼Œåé¢ä¼šæ ¹æ®æ–‡ä»¶ä¿¡æ¯è®¾ç½®

            el.title.textContent = track.name; el.artist.textContent = "Loading...";
            el.img.style.opacity = 0; el.img.src = ''; el.loadTip.style.display = 'block';
            el.progLine.style.width = '0%'; el.bufferLine.style.width = '0%';
            lyrics = []; isSyncedLyrics = true;
            el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">Parsing...</div>';
            resetLoopUI();
            log(`Track: ${track.name}`);

            try {
                let ab = null;
                // å¦‚æœè¯¥ç´¢å¼•æ˜¯å·²é¢„åŠ è½½çš„ä¸‹ä¸€é¦–ï¼Œå°è¯•çŸ­ç­‰å¾…é¢„å–å®Œæˆï¼ˆæœ€å¤š800msï¼‰ï¼Œå¦åˆ™å–æ¶ˆé¢„å–å¹¶èµ°æœ¬åœ°è¯»å–
                if (nextPreloadIndex === i) {
                    try {
                        if (hasPreloaded && nextSongRawData) {
                            // ç›´æ¥ä½¿ç”¨
                        } else if (prefetchInProgress) {
                            const ok = await waitForPrefetchCompletion(800);
                            if (!ok || !hasPreloaded || !nextSongRawData) {
                                try { cancelNextPreload(); } catch(e) {}
                            }
                        }

                        if (hasPreloaded && nextSongRawData) {
                            ab = nextSongRawData;
                            // é‡Šæ”¾é¢„åŠ è½½çŠ¶æ€ï¼Œè§£ç åé‡Šæ”¾å†…å­˜
                            nextSongRawData = null; hasPreloaded = false; nextPreloadIndex = null; prefetchAttempted = false;
                            if (nextSongAbortController) { try { if (typeof nextSongAbortController.abort === 'function') nextSongAbortController.abort(); } catch(e) {} nextSongAbortController = null; }
                            log('Using preloaded raw data for local track', 'success');
                        } else {
                            ab = await track.file.arrayBuffer();
                        }
                    } catch (e) {
                        log('Error while attempting to use preloaded local data, fallback: ' + (e && e.message), 'warn');
                        try { cancelNextPreload(); } catch(_) {}
                        ab = await track.file.arrayBuffer();
                    }
                } else {
                    ab = await track.file.arrayBuffer();
                }
                el.bufferLine.style.width = '30%';
                let meta = null;
                if(track.file.name.toLowerCase().endsWith('.flac')) {
                    log("Detect FLAC. Using Native Parser...");
                    meta = await parseFlacTagsNative(track.file);
                    // è®¡ç®—FLACæ¯”ç‰¹ç‡ï¼ˆæ–‡ä»¶å¤§å° / æ—¶é•¿ï¼‰
                    if (meta) {
                        meta.fileSize = track.file.size;
                    }
                } else {
                    // å¯¹äºMP3ç­‰æ–‡ä»¶ï¼Œè®¡ç®—æ¯”ç‰¹ç‡
                    const fileSize = track.file.size;
                    const ext = track.file.name.split('.').pop().toUpperCase();
                    
                    jsmediatags.read(track.file, {
                        onSuccess: (tag) => {
                            const c = {
                                title: tag.tags.title,
                                artist: tag.tags.artist,
                                lyrics: tag.tags.lyrics || (tag.tags.USLT ? tag.tags.USLT.data : ""),
                                picture: tag.tags.picture,
                                fileSize: fileSize,
                                fileExt: ext
                            };
                            applyMetadata(c, "ID3");
                        },
                        onError: () => {
                            updateTheme(null);
                            // æ²¡æœ‰ID3æ ‡ç­¾ï¼Œå°è¯•ç½‘æ˜“äº‘æœç´¢æˆ–æ˜¾ç¤º Pure Music
                            if(!track.lrcFile) {
                                if (neteaseSearchEnabled) {
                                    const songName = el.title.textContent;
                                    // ç«‹å³å¹¶è¡Œå°è¯•è·å–æ­Œè¯ï¼ˆå³ä½¿ duration è¿˜æœªå‡†å¤‡å¥½ï¼‰
                                    // å¦‚æœä¹‹å duration å¯ç”¨ï¼Œå†ä»¥å‡†ç¡®æ—¶é•¿é‡è¯•ä¸€æ¬¡ä»¥æé«˜åŒ¹é…å‡†ç¡®åº¦
                                    searchNeteaselyrics(songName, '', playbackState.duration || 0);
                                    if (!playbackState.duration) {
                                        let attempts = 0;
                                        const reTry = () => {
                                            attempts++;
                                            if (playbackState.duration > 0) {
                                                searchNeteaselyrics(songName, '', playbackState.duration);
                                            } else if (attempts < 30) {
                                                setTimeout(reTry, 100);
                                            }
                                        };
                                        reTry();
                                    }
                                } else {
                                    el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">Pure Music</div>';
                                }
                            }
                        }
                    });
                }
                if(meta) applyMetadata(meta, "Native");

                el.bufferLine.style.width = '60%';
                audioBuffer = await actx.decodeAudioData(ab);
                el.bufferLine.style.width = '100%';
                playbackState.duration = audioBuffer.duration;
                el.totalTime.textContent = fmtTime(playbackState.duration);
                el.loadTip.style.display = 'none';
                
                // æ ¹æ®ä¸åŒæ ¼å¼è®¡ç®—å¹¶æ˜¾ç¤ºéŸ³è´¨ä¿¡æ¯
                if (pendingQualityInfo && playbackState.duration > 0) {
                    const ext = pendingQualityInfo.ext;
                    const bitrateKbps = Math.round((pendingQualityInfo.size * 8) / playbackState.duration / 1000);
                    const sampleRate = audioBuffer.sampleRate;
                    const channels = audioBuffer.numberOfChannels;
                    const srKhz = sampleRate >= 1000 ? (sampleRate / 1000).toFixed(sampleRate % 1000 === 0 ? 0 : 1) + 'kHz' : sampleRate + 'Hz';
                    
                    // æ ¹æ®æ ¼å¼æ˜¾ç¤ºä¸åŒçš„ä¿¡æ¯
                    switch(ext) {
                        case 'WAV':
                        case 'AIFF':
                        case 'AIF':
                            // æ— æŸæ ¼å¼ - æ˜¾ç¤ºé‡‡æ ·ç‡å’Œå£°é“
                            const chStr = channels === 1 ? 'Mono' : (channels === 2 ? 'Stereo' : `${channels}ch`);
                            currentAudioQuality = `${ext} ${srKhz} ${chStr}`;
                            break;
                        case 'OGG':
                        case 'OPUS':
                            // OGG/Opus - æ˜¾ç¤ºæ¯”ç‰¹ç‡ï¼ˆæœ‰æŸï¼‰
                            currentAudioQuality = `${ext} ~${bitrateKbps}kbps`;
                            break;
                        case 'AAC':
                        case 'M4A':
                        case 'MP4':
                            // AAC - æ˜¾ç¤ºæ¯”ç‰¹ç‡
                            currentAudioQuality = `AAC ${bitrateKbps}kbps`;
                            break;
                        case 'WMA':
                            currentAudioQuality = `WMA ${bitrateKbps}kbps`;
                            break;
                        case 'APE':
                        case 'TTA':
                        case 'TAK':
                            // æ— æŸå‹ç¼©æ ¼å¼ - æ˜¾ç¤ºé‡‡æ ·ç‡
                            currentAudioQuality = `${ext} ${srKhz}`;
                            break;
                        case 'MP3':
                        default:
                            // MP3å’Œå…¶ä»–æ ¼å¼ - æ˜¾ç¤ºæ¯”ç‰¹ç‡
                            currentAudioQuality = `${ext} ${bitrateKbps}kbps`;
                            break;
                    }
                    log(`Audio: ${currentAudioQuality}, ${sampleRate}Hz, ${channels}ch`);
                    pendingQualityInfo = null;
                }
                
                if(el.artist.textContent === "Loading...") el.artist.textContent = "Ready";
                if(track.sliFile) await parseSLI(track);
                startAudio(0);
                el.coverWrap.classList.add('playing');
                updatePlayIcon();
                updateMediaSession();
                if(track.lrcFile) readLrcFile(track.lrcFile);
            } catch(e) { log("Err: " + e, 'error'); alert("æ’­æ”¾å¤±è´¥ï¼Œè¯·æŸ¥çœ‹Debugçª—å£"); }
        }

        function updateMediaSession() {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: el.title.textContent,
                    artist: el.artist.textContent,
                    artwork: [ { src: el.img.src, sizes: '512x512', type: 'image/png' } ]
                });
                navigator.mediaSession.setActionHandler('play', () => el.playBtn.click());
                navigator.mediaSession.setActionHandler('pause', () => el.playBtn.click());
                navigator.mediaSession.setActionHandler('previoustrack', () => document.getElementById('prev-btn').click());
                navigator.mediaSession.setActionHandler('nexttrack', () => document.getElementById('next-btn').click());
            }
        }

        function applyMetadata(common, source) {
            if(common.title) el.title.textContent = common.title;
            if(common.artist) el.artist.textContent = common.artist;
            
            // è®¾ç½®æœ¬åœ°æ–‡ä»¶éŸ³è´¨æ ‡ç­¾
            if (common.sampleRate && common.bitsPerSample) {
                // FLACæ–‡ä»¶ - æ˜¾ç¤ºä½æ·±åº¦å’Œé‡‡æ ·ç‡
                const srKhz = common.sampleRate >= 1000 ? (common.sampleRate / 1000).toFixed(common.sampleRate % 1000 === 0 ? 0 : 1) + 'kHz' : common.sampleRate + 'Hz';
                currentAudioQuality = `FLAC ${common.bitsPerSample}bit/${srKhz}`;
            } else if (common.fileSize && common.fileExt) {
                // å…¶ä»–æ ¼å¼ - ç¨ååœ¨è§£ç å®Œæˆåæ ¹æ®æ ¼å¼æ˜¾ç¤ºåˆé€‚ä¿¡æ¯
                pendingQualityInfo = { size: common.fileSize, ext: common.fileExt };
            }
            if(common.picture && typeof common.picture === 'object') {
                const data = common.picture.data;
                const format = common.picture.format;
                if(data && format) {
                    let base64 = "";
                    for(let j=0; j<data.length; j++) base64 += String.fromCharCode(data[j]);
                    el.img.src = `data:${format};base64,${window.btoa(base64)}`;
                    el.img.onload = () => { el.img.style.opacity = 1; updateTheme(el.img); updateMediaSession(); }
                }
            } else { updateTheme(null); }

            if(common.lyrics) {
                log("Lyrics found.", 'success');
                let clean = common.lyrics.replace(/\/\s*(?=\[\d{2}:)/g, '\n');
                if(!clean.includes('\n') && clean.includes('/')) clean = clean.replace(/\s*\/\s*/g, '\n');
                parseAndRenderLyrics(clean, source);
            } else if(lyrics.length === 0) {
                // æ²¡æœ‰å†…åµŒæ­Œè¯
                if (neteaseSearchEnabled) {
                    // å¼€å¯äº†ç½‘æ˜“äº‘æœç´¢ï¼Œç«‹å³å¹¶è¡Œå°è¯•æœç´¢ï¼ˆä¸å†é˜»å¡ç­‰å¾… durationï¼‰
                    const songName = el.title.textContent;
                    const artistName = common.artist || '';
                    searchNeteaselyrics(songName, artistName, playbackState.duration || 0);
                    // è‹¥å½“å‰æ—¶é•¿å°šæœªå‡†å¤‡å¥½ï¼Œç¨åé‡è¯•ä¸€æ¬¡ä»¥æé«˜åŒ¹é…å‡†ç¡®åº¦
                    if (!playbackState.duration) {
                        let attempts = 0;
                        const reTry = () => {
                            attempts++;
                            if (playbackState.duration > 0) {
                                searchNeteaselyrics(songName, artistName, playbackState.duration);
                            } else if (attempts < 30) {
                                setTimeout(reTry, 100);
                            }
                        };
                        reTry();
                    }
                } else {
                    el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">Pure Music</div>';
                }
            }
        }

        function readLrcFile(file) {
            const r = new FileReader();
            r.onload = e => parseAndRenderLyrics(e.target.result, "LRC File");
            r.readAsText(file);
        }

        // ç½‘æ˜“äº‘éŸ³ä¹APIæœåŠ¡ï¼ˆä½¿ç”¨å…¨å±€å¯ä¿®æ”¹çš„ API åœ°å€ï¼‰
        const NETEASE_API_HOST = (window.API_BASE_URL ).replace(/\/$/, '');
        
        // Verceléƒ¨ç½²éœ€è¦æ·»åŠ çš„å‚æ•°ï¼ˆç»•è¿‡IPé™åˆ¶ï¼‰
        function buildApiUrl(path) {
            const separator = path.includes('?') ? '&' : '?';
            return `${NETEASE_API_HOST}${path}${separator}randomCNIP=true`;
        }

        async function searchNeteaselyrics(songName, artist, duration) {
            try {
                el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">ğŸ” æ­£åœ¨æœç´¢æ­Œè¯...</div>';
                
                // æ™ºèƒ½æå–æ­Œåå’Œæ­Œæ‰‹ - å¤„ç† "æ­Œæ‰‹ - æ­Œå" æ ¼å¼
                let searchSong = songName;
                let searchArtist = artist || '';
                
                // å¦‚æœæ ‡é¢˜åŒ…å« " - "ï¼Œåˆ†ç¦»æ­Œæ‰‹å’Œæ­Œå
                if (songName.includes(' - ')) {
                    const parts = songName.split(' - ');
                    if (parts.length >= 2) {
                        searchArtist = parts[0].trim();
                        searchSong = parts.slice(1).join(' - ').trim();
                    }
                }
                
                log(`Searching lyrics: "${searchSong}" by "${searchArtist}"`);
                
                // æœç´¢æ­Œæ›²
                const searchResp = await fetch(buildApiUrl(`/search?keywords=${encodeURIComponent(searchSong)}&limit=20`));
                if (!searchResp.ok) throw new Error('æœç´¢è¯·æ±‚å¤±è´¥');
                
                const searchData = await searchResp.json();
                if (searchData.code !== 200 || !searchData.result?.songs?.length) {
                    log('No songs found on Netease', 'error');
                    el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">æœªæ‰¾åˆ°åŒ¹é…æ­Œæ›²</div>';
                    return false;
                }
                
                log(`Found ${searchData.result.songs.length} songs`, 'success');
                
                // åŒ¹é…é€»è¾‘ï¼šæ­Œå â†’ æ­Œæ‰‹ â†’ æ—¶é•¿
                const songs = searchData.result.songs;
                log(`Found ${songs.length} candidates`);
                
                // è¾…åŠ©å‡½æ•°ï¼šæ ‡å‡†åŒ–å­—ç¬¦ä¸²
                const normalize = (s) => (s || '').toLowerCase().replace(/\s+/g, '');
                const targetName = normalize(searchSong);
                const targetArtist = normalize(searchArtist);
                
                // 1. å…ˆç­›é€‰æ­ŒååŒ¹é…çš„æ­Œæ›²
                let nameMatched = songs.filter(s => normalize(s.name) === targetName);
                
                // å¦‚æœå®Œå…¨åŒ¹é…æ²¡æœ‰ï¼Œå°è¯•åŒ…å«åŒ¹é…
                if (nameMatched.length === 0) {
                    nameMatched = songs.filter(s => 
                        normalize(s.name).includes(targetName) || 
                        targetName.includes(normalize(s.name))
                    );
                }
                
                let candidates = nameMatched.length > 0 ? nameMatched : songs;
                
                if (nameMatched.length > 0) {
                    log(`${nameMatched.length} songs with matching name`);
                } else {
                    log(`No exact name match, using all candidates`, 'warn');
                }
                
                // 2. ä»æ­ŒååŒ¹é…çš„æ­Œæ›²ä¸­ï¼Œä¼˜å…ˆé€‰æ­Œæ‰‹åŒ¹é…çš„
                let bestMatch = candidates[0];
                
                if (targetArtist && candidates.length > 1) {
                    // æ‰¾æ­Œæ‰‹å®Œå…¨åŒ¹é…çš„
                    const artistMatched = candidates.filter(s => {
                        const songArtists = (s.artists || []).map(a => normalize(a.name));
                        return songArtists.some(a => a === targetArtist || a.includes(targetArtist) || targetArtist.includes(a));
                    });
                    
                    if (artistMatched.length > 0) {
                        log(`${artistMatched.length} songs with matching artist`);
                        candidates = artistMatched;
                        bestMatch = candidates[0];
                    }
                }
                
                // 3. æœ€åæŒ‰æ—¶é•¿é€‰æœ€æ¥è¿‘çš„
                if (duration && duration > 0 && candidates.length > 1) {
                    const targetMs = duration * 1000;
                    let minDiff = Math.abs((bestMatch.duration || 0) - targetMs);
                    
                    for (const song of candidates) {
                        const songDur = song.duration || 0;
                        const diff = Math.abs(songDur - targetMs);
                        if (diff < minDiff) {
                            minDiff = diff;
                            bestMatch = song;
                        }
                    }
                    const diffSec = (minDiff/1000).toFixed(1);
                    log(`Best match: "${bestMatch.name}" by ${bestMatch.artists?.[0]?.name || '?'} (Î”${diffSec}s)`);
                } else {
                    log(`Selected: "${bestMatch.name}" by ${bestMatch.artists?.[0]?.name || '?'}`);
                }
                
                const songId = bestMatch.id;
                log(`Found song ID: ${songId} - ${bestMatch.name}`);
                
                // è·å–æ­Œè¯
                const lyricResp = await fetch(buildApiUrl(`/lyric?id=${songId}`));
                if (!lyricResp.ok) throw new Error('è·å–æ­Œè¯å¤±è´¥');
                
                const lyricData = await lyricResp.json();
                
                if (lyricData?.lrc?.lyric) {
                    log('Netease lyrics loaded!', 'success');
                    const trans = lyricData?.tlyric?.lyric || lyricData?.trans?.lyric || '';
                    parseAndRenderLyrics(lyricData.lrc.lyric, 'ç½‘æ˜“äº‘', trans);
                    return true;
                } else if (lyricData?.nolyric || lyricData?.uncollected) {
                    log('Song has no lyrics (instrumental)', 'warn');
                    el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">ğŸµ çº¯éŸ³ä¹ï¼Œæ— æ­Œè¯</div>';
                    return false;
                } else {
                    throw new Error('No lyrics in response');
                }
            } catch (e) {
                log('Netease search error: ' + e.message, 'error');
                el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">æ­Œè¯æœç´¢å¤±è´¥</div>';
                return false;
            }
        }
        
        // ç›´æ¥é€šè¿‡æ­Œæ›²IDè·å–æ­Œè¯ï¼ˆç”¨äºå·²çŸ¥IDçš„ç½‘æ˜“äº‘æ­Œæ›²ï¼‰
        async function fetchLyricById(songId) {
            // æ”¯æŒå¤–éƒ¨ä¼ å…¥AbortController
            let lyricSignal;
            if (arguments.length > 1 && arguments[1] && arguments[1].signal) {
                lyricSignal = arguments[1].signal;
            } else {
                if (window.neteaseLyricAbortController) window.neteaseLyricAbortController.abort();
                window.neteaseLyricAbortController = new AbortController();
                lyricSignal = window.neteaseLyricAbortController.signal;
            }
            try {
                el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">ğŸ” è·å–æ­Œè¯...</div>';
                // ä½¿ç”¨ç¼“å­˜é˜Ÿåˆ—è·å–æ­Œè¯ï¼ˆttl 1 hourï¼‰
                const data = await cachedFetchJson(buildApiUrl(`/lyric?id=${songId}`), { signal: lyricSignal, useQueue: true }, 3600_000);
                if (data) {
                    if (data?.lrc?.lyric) {
                        log('Lyrics loaded!', 'success');
                        const trans = data?.tlyric?.lyric || data?.trans?.lyric || '';
                        parseAndRenderLyrics(data.lrc.lyric, 'ç½‘æ˜“äº‘', trans);
                        return true;
                    } else if (data?.nolyric || data?.uncollected) {
                        el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">ğŸµ çº¯éŸ³ä¹ï¼Œæ— æ­Œè¯</div>';
                        return false;
                    }
                }
                el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">æš‚æ— æ­Œè¯</div>';
                return false;
            } catch (e) {
                if (e.name === 'AbortError') {
                    // åˆ‡æ­Œæ—¶ä¸­æ–­ä¸æŠ¥é”™
                    return false;
                }
                log('Lyric fetch error: ' + e.message, 'error');
                el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">æ­Œè¯è·å–å¤±è´¥</div>';
                return false;
            }
        }

        function parseAndRenderLyrics(text, source, transText) {
            // ä¿å­˜åŸæ–‡ä¸ç¿»è¯‘æ–‡æœ¬ï¼Œä¾›åˆ‡æ¢æ—¶å¤ç”¨
            originalLyricsText = text || '';
            translatedLyricsText = transText || '';
            originalLyricsArr = parseLyricsToArray(originalLyricsText);
            translatedLyricsArr = parseLyricsToArray(translatedLyricsText);

            const hasTranslation = translatedLyricsArr.length > 0;
            // å¦‚æœæ£€æµ‹åˆ°ç¿»è¯‘å¯ç”¨ï¼Œå¯ç”¨åˆ‡æ¢æŒ‰é’®
            updateLyricToggleUI(hasTranslation);

            renderLyricsFromArrays(source);
            log(`Lyrics parsed. Original lines: ${originalLyricsArr.length}, Trans lines: ${translatedLyricsArr.length}` + (hasTranslation ? ' (translation available)' : ''), 'success');
        }

        function startAudio(offset) {
            if(sourceNode) sourceNode.disconnect();
            sourceNode = actx.createBufferSource();
            sourceNode.buffer = audioBuffer;
            sourceNode.connect(gainNode);
            
            const isLooping = loopState.active && loopState.end <= audioBuffer.duration && loopState.start < loopState.end;
            
            if(isLooping) {
                sourceNode.loop = true; 
                sourceNode.loopStart = loopState.start; 
                sourceNode.loopEnd = loopState.end;
                document.getElementById('loop-status').style.display = 'inline';
            } else {
                sourceNode.loop = false; 
                document.getElementById('loop-status').style.display = 'none';
            }
            sourceNode.start(0, offset);
            playbackState.startTime = actx.currentTime - offset;
            playbackState.pauseTime = offset;
            playbackState.isPlaying = true;
            if('mediaSession' in navigator) navigator.mediaSession.playbackState = "playing";
            
            // ä½¿ç”¨é—­åŒ…ä¿å­˜å¾ªç¯çŠ¶æ€ï¼Œé¿å…åç»­çŠ¶æ€å˜åŒ–å½±å“åˆ¤æ–­
            const wasLooping = isLooping;
            sourceNode.onended = () => {
                // å¦‚æœæ˜¯å¾ªç¯æ¨¡å¼ï¼Œonended ä¸åº”è¯¥è§¦å‘åˆ‡æ­Œ
                // ä½†æŸäº›æµè§ˆå™¨å¯èƒ½åœ¨ç²¾åº¦é—®é¢˜ä¸‹æ„å¤–è§¦å‘ï¼Œè¿™é‡Œé‡æ–°å¯åŠ¨å¾ªç¯
                if(wasLooping && loopState.active && playbackState.isPlaying) {
                    log("Loop interrupted, restarting...", 'warn');
                    startAudio(loopState.start);
                    return;
                }
                // éå¾ªç¯æ¨¡å¼ä¸‹ï¼Œæ£€æŸ¥æ˜¯å¦çœŸçš„æ’­æ”¾å®Œäº†
                if(!wasLooping && playbackState.isPlaying && (getCurrentTime() >= playbackState.duration - 0.5)) {
                    handleNext();
                }
            };
        }
        function stopAudio() { 
            if(sourceNode) { try{sourceNode.stop()}catch(e){}; sourceNode.disconnect(); sourceNode=null; } 
            playbackState.isPlaying = false; 
            if('mediaSession' in navigator) navigator.mediaSession.playbackState = "paused";
            // å–æ¶ˆå½“å‰çš„ç½‘ç»œè¯·æ±‚
            if(currentAbortController) {
                currentAbortController.abort();
                currentAbortController = null;
            }
        }
        function getCurrentTime() {
            if(!playbackState.isPlaying) return playbackState.pauseTime;
            let t = actx.currentTime - playbackState.startTime;
            if(loopState.active && sourceNode.loop && t > loopState.end) { const dur = loopState.end - loopState.start; t = loopState.start + (t - loopState.end) % dur; } 
            else if (t > playbackState.duration) t = playbackState.duration;
            return t;
        }

        // åˆ·æ–°å½“å‰é«˜äº®è¡Œå¹¶å°†å…¶å±…ä¸­ï¼ˆå¯è¢«å¤–éƒ¨è°ƒç”¨ä»¥ç«‹å³æ›´æ–°ï¼‰
        function refreshLyricHighlightAndCenter() {
            if(!isSyncedLyrics || !lyrics || !lyrics.length) return;
            const now = getCurrentTime();
            let idx = lyrics.findIndex(l => l.t > now) - 1;
            if(idx < 0) idx = lyrics.length - 1; if(now < lyrics[0]?.t) idx = -1;
            const activeLine = el.lyricBox.children[idx + 1];
            if(!activeLine) return;
            // æ€»æ˜¯æ›´æ–°é«˜äº®å¹¶å±…ä¸­ï¼ˆé¿å…å¿…é¡»ç­‰å¾…ä¸‹ä¸€å¥ï¼‰
            document.querySelectorAll('.lyric-line').forEach(l => l.classList.remove('active'));
            activeLine.classList.add('active');
            const parentHeight = el.lyricBox.parentNode.offsetHeight || (window.innerHeight * 0.5);
            const offset = activeLine.offsetTop - parentHeight/2 + activeLine.offsetHeight/2;
            el.lyricBox.style.transform = `translateY(-${offset}px)`;
        }

        function renderLoop() {
            requestAnimationFrame(renderLoop);
            const now = getCurrentTime();
            el.currTime.textContent = fmtTime(now);
            if(playbackState.duration) {
                const pct = (now / playbackState.duration) * 100;
                el.progLine.style.width = pct + '%';
                // å½“å‰©ä½™æ’­æ”¾æ—¶é—´ <= 10 ç§’æ—¶ï¼Œéé˜»å¡åœ°é¢„å–ä¸‹ä¸€é¦–åŸå§‹æ•°æ®ï¼ˆæ¯”æŒ‰ç™¾åˆ†æ¯”æ›´ç¨³å®šï¼‰
                if (playbackState.duration && (playbackState.duration - now) <= 10 && !hasPreloaded && !prefetchAttempted) {
                    prefetchAttempted = true; // ç«‹å³æ ‡è®°ä¸ºå·²å°è¯•ï¼Œé˜²æ­¢é‡å¤å‘èµ·
                    try { prefetchNextSong(); } catch(e) {}
                }
            }
            // åˆ·æ–°æ­Œè¯é«˜äº®ä¸å±…ä¸­ï¼ˆä¼šåšé˜²æŠ–åˆ¤æ–­ï¼‰
            try { refreshLyricHighlightAndCenter(); } catch(e) {}
            renderVisuals();
        }
        renderLoop();

        el.playBtn.onclick = () => {
            if(actx.state === 'suspended') actx.resume();
            if(playbackState.isPlaying) {
                playbackState.pauseTime = getCurrentTime();
                stopAudio();
                el.coverWrap.classList.remove('playing');
                updatePlayIcon();
            } else {
                if (audioBuffer) {
                    startAudio(playbackState.pauseTime);
                    el.coverWrap.classList.add('playing');
                    updatePlayIcon();
                } else {
                    // å¦‚æœæ²¡æœ‰å·²è§£ç éŸ³é¢‘ï¼Œå°è¯•ä»å½“å‰ç´¢å¼•åŠ è½½å¹¶æ’­æ”¾ï¼ˆä¾‹å¦‚æ¢å¤åçš„åˆ—è¡¨ï¼‰
                    if (typeof curIdx === 'number' && curIdx >= 0 && curIdx < playlist.length) {
                        playTrackFromPlaylist(curIdx);
                    } else if (playlist.length > 0) {
                        playTrackFromPlaylist(0);
                    }
                }
            }
        };
        
        // è¿›åº¦æ¡æ‹–åŠ¨æ”¯æŒ
        let isDraggingProgress = false;
        let wasPlayingBeforeDrag = false;
        
        function handleProgressSeek(e) {
            if(!playbackState.duration) return;
            const rect = el.progBg.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const pct = Math.max(0, Math.min(1, x / rect.width));
            const target = pct * playbackState.duration;
            el.progLine.style.width = pct * 100 + '%';
            el.currTime.textContent = fmtTime(target);
            return target;
        }
        
        el.progBg.onmousedown = e => {
            if(!playbackState.duration) return;
            isDraggingProgress = true;
            wasPlayingBeforeDrag = playbackState.isPlaying;
            if(wasPlayingBeforeDrag) stopAudio();
            playbackState.pauseTime = handleProgressSeek(e);
        };
        
        document.addEventListener('mousemove', e => {
            if(!isDraggingProgress) return;
            playbackState.pauseTime = handleProgressSeek(e);
        });
        
        document.addEventListener('mouseup', e => {
            if(!isDraggingProgress) return;
            isDraggingProgress = false;
            if(wasPlayingBeforeDrag) {
                startAudio(playbackState.pauseTime);
                el.coverWrap.classList.add('playing');
            }
        });
        
        // è§¦æ‘¸å±æ”¯æŒ
        el.progBg.ontouchstart = e => {
            if(!playbackState.duration) return;
            isDraggingProgress = true;
            wasPlayingBeforeDrag = playbackState.isPlaying;
            if(wasPlayingBeforeDrag) stopAudio();
            playbackState.pauseTime = handleProgressSeek(e);
        };
        
        el.progBg.ontouchmove = e => {
            if(!isDraggingProgress) return;
            e.preventDefault();
            playbackState.pauseTime = handleProgressSeek(e);
        };
        
        el.progBg.ontouchend = e => {
            if(!isDraggingProgress) return;
            isDraggingProgress = false;
            if(wasPlayingBeforeDrag) {
                startAudio(playbackState.pauseTime);
                el.coverWrap.classList.add('playing');
            }
        };
        
        el.volBtn.onclick = () => { el.volPopup.classList.toggle('show'); };
        el.volRange.oninput = () => { gainNode.gain.value = el.volRange.value; };

        document.addEventListener('keydown', (e) => {
            if(e.target.tagName === 'INPUT') return;
            if(e.code === 'Space') { e.preventDefault(); el.playBtn.click(); } 
            else if (e.code === 'ArrowLeft') { if (audioBuffer) { const t = Math.max(0, getCurrentTime() - 5); if (playbackState.isPlaying) startAudio(t); else { playbackState.pauseTime = t; updateUI(t); } } } 
            else if (e.code === 'ArrowRight') { if (audioBuffer) { const t = Math.min(playbackState.duration, getCurrentTime() + 5); if (playbackState.isPlaying) startAudio(t); else { playbackState.pauseTime = t; updateUI(t); } } } 
            else if (e.code === 'ArrowUp') { e.preventDefault(); el.volRange.value = Math.min(1, parseFloat(el.volRange.value) + 0.05); gainNode.gain.value = el.volRange.value; el.volPopup.classList.add('show'); clearTimeout(window.volTimer); window.volTimer = setTimeout(() => el.volPopup.classList.remove('show'), 2000); } 
            else if (e.code === 'ArrowDown') { e.preventDefault(); el.volRange.value = Math.max(0, parseFloat(el.volRange.value) - 0.05); gainNode.gain.value = el.volRange.value; el.volPopup.classList.add('show'); clearTimeout(window.volTimer); window.volTimer = setTimeout(() => el.volPopup.classList.remove('show'), 2000); }
        });
        function updateUI(t) { el.currTime.textContent = fmtTime(t); el.progLine.style.width = (t / playbackState.duration) * 100 + '%'; }

        function handleNext() {
            if(playMode === 1) playTrack(Math.floor(Math.random()*playlist.length));
            else if(playMode === 2) startAudio(0);
            else playTrack(curIdx + 1 >= playlist.length ? 0 : curIdx + 1);
        }
        document.getElementById('prev-btn').onclick = () => playTrack(curIdx - 1 < 0 ? playlist.length-1 : curIdx - 1);
        document.getElementById('next-btn').onclick = handleNext;
        el.modeBtn.onclick = () => {
            playMode = (playMode + 1) % 3;
            ['icon-list-loop', 'icon-random', 'icon-single'].forEach(id => document.getElementById(id).style.display = 'none');
            document.getElementById(['icon-list-loop', 'icon-random', 'icon-single'][playMode]).style.display = 'block';
        };

        async function parseSLI(track) {
            return new Promise(resolve => {
                const r = new FileReader();
                r.onload = e => {
                    const m = e.target.result.match(/From\s*=\s*(\d+)\s*;\s*To\s*=\s*(\d+)/i);
                    if(m) {
                        const rate = parseInt(el.baseRateInput.value) || 44100;
                        applyLoop(parseInt(m[2])/rate, parseInt(m[1])/rate);
                        el.loopMsg.textContent = `SLI Loaded`;
                    }
                    resolve();
                };
                r.readAsText(track.sliFile);
            });
        }
        function applyLoop(s, e) {
            el.loopStart.value = s.toFixed(3); el.loopEnd.value = e.toFixed(3);
            el.loopEnable.checked = true; loopState = { active: true, start: s, end: e };
            updateLoopMarkers();
        }
        window.setLoopPoint = function(t) {
            const now = getCurrentTime();
            if(t==='a') el.loopStart.value=now.toFixed(3); else el.loopEnd.value=now.toFixed(3);
            el.loopEnable.checked = true; el.loopEnable.dispatchEvent(new Event('change'));
        };
        el.loopEnable.addEventListener('change', e => {
            if(e.target.checked) {
                const s = parseFloat(el.loopStart.value), e_val = parseFloat(el.loopEnd.value);
                if(e_val > s) { loopState = { active: true, start: s, end: e_val }; if(playbackState.isPlaying) startAudio(getCurrentTime()); }
            } else { loopState.active = false; if(playbackState.isPlaying) startAudio(getCurrentTime()); }
            updateLoopMarkers();
        });
        function resetLoopUI() { loopState.active=false; el.loopEnable.checked=false; updateLoopMarkers(); }
        function updateLoopMarkers() {
            if(!loopState.active) { el.markerA.style.display='none'; el.markerB.style.display='none'; document.getElementById('loop-status').style.display='none'; return; }
            const d = playbackState.duration || 1;
            el.markerA.style.left = (loopState.start/d)*100+'%'; el.markerB.style.left = (loopState.end/d)*100+'%';
            el.markerA.style.display='block'; el.markerB.style.display='block'; document.getElementById('loop-status').style.display='inline';
        }

        function updatePlayIcon() { el.playBtn.innerHTML = playbackState.isPlaying ? '<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>' : '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>'; }
        function fmtTime(s) { const m = Math.floor(s/60); const sc = Math.floor(s%60); return `${m.toString().padStart(2,'0')}:${sc.toString().padStart(2,'0')}`; }
        function renderPlaylist() {
            el.plContainer.innerHTML = '';
            playlist.forEach((t, i) => {
                const d = document.createElement('div'); d.className = `pl-item ${i === curIdx ? 'active' : ''}`;
                const icon = t.netease ? 'â˜ï¸ ' : '';
                d.innerHTML = `<span style="width:20px; opacity:0.5">${i+1}</span> ${icon}${t.name}`;
                d.onclick = () => { try { cancelNextPreload(); } catch(e) {} ; playTrackFromPlaylist(i); };
                el.plContainer.appendChild(d);
            });
        }
        function updateTheme(img) {
            let c1 = "#e0c3fc", c2 = "#8ec5fc";
            if(img) { try { const rgb = colorThief.getColor(img); c1 = `rgb(${Math.floor((rgb[0]+255)/2)},${Math.floor((rgb[1]+255)/2)},${Math.floor((rgb[2]+255)/2)})`; c2 = `rgb(${Math.floor((rgb[0]+200)/2)},${Math.floor((rgb[1]+220)/2)},${Math.floor((rgb[2]+255)/2)})`; } catch(e){} }
            document.body.style.setProperty('--bg-1', c1); document.body.style.setProperty('--bg-2', c2);
        }
        function renderVisuals() {
            const mode = el.effectSel.value, w = el.canvas.width = window.innerWidth, h = el.canvas.height = window.innerHeight;
            canvasCtx.clearRect(0,0,w,h); if(mode==='none') return;
            let data = new Uint8Array(analyser.frequencyBinCount); analyser.getByteFrequencyData(data);
            if(mode==='bars') { const bw=(w/data.length)*2.5; let x=0; for(let i=0;i<data.length;i++){ const H=data[i]*1.5; canvasCtx.fillStyle=`rgba(255,255,255,0.3)`; canvasCtx.fillRect(x,h-H/2,bw,H/2); x+=bw+1; } }
            else if(mode==='snow') {
                // è‡ªé€‚åº”é›ªèŠ±æ•°é‡å¹¶ä¿æŒå·¦å³å‡åŒ€åˆ†å¸ƒ
                const maxParticles = Math.max(60, Math.floor(w / 8));
                while (particles.length < maxParticles) {
                    particles.push({ x: Math.random() * w, y: Math.random() * -h, r: Math.random() * 3 + 1, s: Math.random() * 2 + 0.5 });
                }
                const bass = (data && data[10]) ? data[10] : 0;
                canvasCtx.fillStyle = "rgba(255,255,255,0.9)";
                for (let i = 0; i < particles.length; i++) {
                    const p = particles[i];
                    // å‚ç›´ç§»åŠ¨ï¼Œå—ä½é¢‘å½±å“ä½†å¹…åº¦è¾ƒå°
                    p.y += p.s * (1 + (bass / 256) * 0.8);
                    // æ¸©å’Œæ°´å¹³æ¼‚ç§»å¹¶åŠ éšæœºæŠ–åŠ¨ï¼Œé¿å…åå‘ä¸€ä¾§
                    p.x += Math.sin(p.y * 0.01) * 0.5 + (Math.random() - 0.5) * 0.3;
                    // è¶Šç•Œå¤„ç†ï¼šä»é¡¶éƒ¨éšæœºXé‡ç½®ï¼Œä¿æŒæ•´ä½“å‡åŒ€
                    if (p.y > h) {
                        p.y = -Math.random() * 20;
                        p.x = Math.random() * w;
                    }
                    if (p.x < -50 || p.x > w + 50) {
                        p.x = Math.random() * w;
                    }
                    canvasCtx.beginPath();
                    canvasCtx.arc(p.x, p.y, Math.max(1, p.r), 0, Math.PI * 2);
                    canvasCtx.fill();
                }
            } else if(mode==='waves') {
                canvasCtx.beginPath(); canvasCtx.moveTo(0,h/2);
                for(let i=0;i<data.length;i++){ canvasCtx.lineTo((i/data.length)*w, h/2+Math.sin(i*0.1+performance.now()/1000)*data[i]+Math.cos(i*0.05)*50); }
                canvasCtx.strokeStyle="rgba(255,255,255,0.4)"; canvasCtx.lineWidth=2; canvasCtx.stroke();
            }
        }

        document.getElementById('toggle-list').onclick = () => document.getElementById('playlist-sidebar').classList.toggle('show');
        document.getElementById('toggle-loop-panel').onclick = () => document.getElementById('loop-panel').classList.toggle('show');
        document.getElementById('toggle-analyze').onclick = () => document.getElementById('analyze-panel').classList.toggle('show');
        document.getElementById('toggle-debug').onclick = () => {
            const dbg = document.getElementById('debug-console');
            dbg.style.display = (dbg.style.display === 'none' || dbg.style.display === '') ? 'block' : 'none';
        };
        
        // ç½‘æ˜“äº‘æ­Œè¯å¼€å…³
        const neteaseBtn = document.getElementById('toggle-netease');
        neteaseBtn.onclick = () => {
            neteaseSearchEnabled = !neteaseSearchEnabled;
            neteaseBtn.style.background = neteaseSearchEnabled ? '#27ae60' : '';
            neteaseBtn.style.color = neteaseSearchEnabled ? '#fff' : '';
            log(`Netease lyrics search: ${neteaseSearchEnabled ? 'ON' : 'OFF'}`);
        };
        
        // ========== ç½‘æ˜“äº‘éŸ³ä¹æœç´¢ & æ­Œå•å¯¼å…¥ ==========
        const neteasePanel = document.getElementById('netease-panel');
        const neteaseTabs = document.querySelectorAll('.netease-tab');
        const searchInput = document.getElementById('netease-search-input');
        const searchBtn = document.getElementById('netease-search-btn');
        const searchResults = document.getElementById('netease-search-results');
        const playlistInput = document.getElementById('netease-playlist-input');
        const playlistBtn = document.getElementById('netease-playlist-btn');
        const playlistPreview = document.getElementById('netease-playlist-preview');
        const playlistResults = document.getElementById('netease-playlist-results');
        
        // æ‰“å¼€ç½‘æ˜“äº‘é¢æ¿
        document.getElementById('toggle-netease-panel').onclick = () => {
            neteasePanel.classList.add('show');
        };
        
        // ç‚¹å‡»èƒŒæ™¯å…³é—­
        neteasePanel.onclick = (e) => {
            if (e.target === neteasePanel) neteasePanel.classList.remove('show');
        };
        
        // Tab åˆ‡æ¢
        neteaseTabs.forEach(tab => {
            tab.onclick = () => {
                neteaseTabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                document.querySelectorAll('.netease-tab-content').forEach(c => c.style.display = 'none');
                document.getElementById('tab-' + tab.dataset.tab).style.display = 'flex';
                // åˆ‡æ¢åˆ°æˆ‘çš„æ­Œå•æ—¶ï¼Œåªæœ‰æœªåŠ è½½è¿‡æ‰åˆ·æ–°
                if (tab.dataset.tab === 'mylist' && neteaseUser && !myPlaylistsCache) {
                    loadMyPlaylists();
                }
            };
        });
        
        // ========== ç½‘æ˜“äº‘ç™»å½•ç³»ç»Ÿ ==========
        let neteaseUser = null;
        let neteaseCookie = localStorage.getItem('netease_cookie') || '';
        let qrCheckTimer = null;
        let myPlaylistsCache = null; // æˆ‘çš„æ­Œå•ç¼“å­˜
        let pendingQualityInfo = null; // ç­‰å¾…è®¡ç®—çš„éŸ³è´¨ä¿¡æ¯ï¼ˆMP3ç­‰ï¼‰
        let currentAudioQuality = ''; // å½“å‰æ’­æ”¾éŸ³è´¨
        let neteaseVipType = 0; // 0=æ™®é€š 1=VIP 2=SVIP 3=éŸ³ä¹åŒ…
        let neteaseQuality = localStorage.getItem('netease_quality') || 'exhigh'; // é»˜è®¤æé«˜
        
        // åˆå§‹åŒ–éŸ³è´¨é€‰æ‹©å™¨
        const qualitySelect = document.getElementById('netease-quality-select');
        qualitySelect.value = neteaseQuality;
        qualitySelect.onchange = () => {
            neteaseQuality = qualitySelect.value;
            localStorage.setItem('netease_quality', neteaseQuality);
            log(`éŸ³è´¨è®¾ç½®: ${qualitySelect.options[qualitySelect.selectedIndex].text}`);
        };
        
        // æ£€æŸ¥ç™»å½•çŠ¶æ€
        async function checkLoginStatus() {
            if (!neteaseCookie) return false;
            
            try {
                const resp = await fetch(buildApiUrl(`/login/status?cookie=${encodeURIComponent(cleanCookie(neteaseCookie))}`));
                if (resp.ok) {
                    const json = await resp.json();
                    if (json.data?.profile) {
                        neteaseUser = json.data.profile;
                        // è·å–VIPä¿¡æ¯
                        await fetchVipInfo();
                        updateUserUI();
                        log(`Logged in as: ${neteaseUser.nickname}`, 'success');
                        return true;
                    }
                }
            } catch (e) {
                log('Login check failed: ' + e.message, 'error');
            }
            return false;
        }
        
        // è·å–VIPä¿¡æ¯
        async function fetchVipInfo() {
            try {
                const resp = await fetch(buildApiUrl(`/vip/info?cookie=${encodeURIComponent(cleanCookie(neteaseCookie))}`));
                if (resp.ok) {
                    const json = await resp.json();
                    // redVipLevel: 0=æ™®é€š 1=VIP; musicPackage=éŸ³ä¹åŒ…
                    const vipInfo = json.data;
                    if (vipInfo?.redVipLevel >= 7) {
                        neteaseVipType = 2; // SVIP
                        neteaseQuality = localStorage.getItem('netease_quality') || 'lossless';
                    } else if (vipInfo?.redVipLevel >= 1) {
                        neteaseVipType = 1; // VIP
                        neteaseQuality = localStorage.getItem('netease_quality') || 'lossless';
                    } else if (vipInfo?.musicPackage?.vipCode) {
                        neteaseVipType = 3; // éŸ³ä¹åŒ…
                        neteaseQuality = localStorage.getItem('netease_quality') || 'lossless';
                    } else {
                        neteaseVipType = 0; // æ™®é€š
                        neteaseQuality = localStorage.getItem('netease_quality') || 'exhigh';
                    }
                    qualitySelect.value = neteaseQuality;
                    localStorage.setItem('netease_quality', neteaseQuality);
                }
            } catch (e) {
                log('VIP info fetch failed', 'warn');
            }
        }
        
        // æ›´æ–°ç”¨æˆ·ç•Œé¢
        function updateUserUI() {
            const userBar = document.getElementById('netease-user-bar');
            const loginBtn = document.getElementById('netease-login-btn');
            const qualityBar = document.getElementById('netease-quality-bar');
            
            if (neteaseUser) {
                document.getElementById('netease-avatar').src = neteaseUser.avatarUrl;
                document.getElementById('netease-nickname').textContent = neteaseUser.nickname;
                document.getElementById('netease-user-id').textContent = 'ID: ' + neteaseUser.userId;
                
                // æ˜¾ç¤ºVIPçŠ¶æ€
                const userTypeEl = document.getElementById('netease-user-type');
                const typeMap = {
                    0: { text: 'æ™®é€šç”¨æˆ·', cls: 'normal' },
                    1: { text: 'VIPä¼šå‘˜', cls: 'vip' },
                    2: { text: 'SVIPä¼šå‘˜', cls: 'svip' },
                    3: { text: 'éŸ³ä¹åŒ…', cls: 'music-pack' }
                };
                const typeInfo = typeMap[neteaseVipType] || typeMap[0];
                userTypeEl.textContent = typeInfo.text;
                userTypeEl.className = 'netease-user-type ' + typeInfo.cls;
                
                userBar.style.display = 'flex';
                loginBtn.style.display = 'none';
                qualityBar.style.display = 'flex';
            } else {
                userBar.style.display = 'none';
                loginBtn.style.display = 'block';
                qualityBar.style.display = 'none';
            }
        }
        
        // æ˜¾ç¤ºäºŒç»´ç ç™»å½•
        async function showQRLogin() {
            // åˆ‡æ¢åˆ°ç™»å½•Tab
            document.querySelectorAll('.netease-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.netease-tab-content').forEach(c => c.style.display = 'none');
            document.getElementById('tab-qrlogin').style.display = 'block';
            
            await generateQRCode();
        }
        window.showQRLogin = showQRLogin;
        
        // ç”ŸæˆäºŒç»´ç 
        async function generateQRCode() {
                        // äºŒç»´ç ç›¸å…³è¯·æ±‚AbortController
                        if (window.neteaseQrAbortController) {
                            window.neteaseQrAbortController.abort();
                        }
                        window.neteaseQrAbortController = new AbortController();
                        const qrSignal = window.neteaseQrAbortController.signal;
            const imgWrap = document.getElementById('qrcode-img-wrap');
            const status = document.getElementById('qrcode-status');
            imgWrap.innerHTML = '<div class="netease-loading">ç”ŸæˆäºŒç»´ç ä¸­...</div>';
            status.textContent = 'ç­‰å¾…æ‰«æ...';
            status.className = 'qrcode-status waiting';
            
            // æ¸…é™¤æ—§çš„å®šæ—¶å™¨
            if (qrCheckTimer) clearInterval(qrCheckTimer);
            
            try {
                // è·å–äºŒç»´ç key
                const keyResp = await fetch(buildApiUrl(`/login/qr/key?timestamp=${Date.now()}`), { signal: qrSignal });
                if (!keyResp.ok) throw new Error('æ— æ³•è·å–äºŒç»´ç ');
                const keyJson = await keyResp.json();
                if (!keyJson.data?.unikey) throw new Error('æ— æ³•è·å–äºŒç»´ç key');
                const qrKey = keyJson.data.unikey;
                // è·å–äºŒç»´ç å›¾ç‰‡
                const imgResp = await fetch(buildApiUrl(`/login/qr/create?key=${qrKey}&qrimg=true&timestamp=${Date.now()}`), { signal: qrSignal });
                if (!imgResp.ok) throw new Error('æ— æ³•ç”ŸæˆäºŒç»´ç å›¾ç‰‡');
                const imgJson = await imgResp.json();
                if (!imgJson.data?.qrimg) throw new Error('æ— æ³•ç”ŸæˆäºŒç»´ç ');
                imgWrap.innerHTML = `<img src="${imgJson.data.qrimg}" alt="QR Code">`;
                // è½®è¯¢æ£€æŸ¥æ‰«ç çŠ¶æ€
                qrCheckTimer = setInterval(async () => {
                    try {
                        if (qrSignal.aborted) return;
                        const checkResp = await fetch(buildApiUrl(`/login/qr/check?key=${qrKey}&timestamp=${Date.now()}&noCookie=true`), { signal: qrSignal });
                        if (!checkResp.ok) return;
                        const checkJson = await checkResp.json();
                        if (checkJson.code === 800) {
                            status.textContent = 'äºŒç»´ç å·²è¿‡æœŸï¼Œè¯·åˆ·æ–°';
                            status.className = 'qrcode-status expired';
                            clearInterval(qrCheckTimer);
                        } else if (checkJson.code === 801) {
                            status.textContent = 'ç­‰å¾…æ‰«æ...';
                            status.className = 'qrcode-status waiting';
                        } else if (checkJson.code === 802) {
                            status.textContent = 'å·²æ‰«æï¼Œè¯·åœ¨æ‰‹æœºä¸Šç¡®è®¤ç™»å½•';
                            status.className = 'qrcode-status scanned';
                        } else if (checkJson.code === 803) {
                            status.textContent = 'ç™»å½•æˆåŠŸï¼';
                            status.className = 'qrcode-status success';
                            clearInterval(qrCheckTimer);
                            // ä¿å­˜å¹²å‡€çš„ cookieï¼ˆåªä¿ç•™æ ¸å¿ƒå‡­è¯ï¼‰
                            neteaseCookie = cleanCookie(checkJson.cookie || '');
                            localStorage.setItem('netease_cookie', neteaseCookie);
                            // è·å–ç”¨æˆ·ä¿¡æ¯
                            await checkLoginStatus();
                            // åˆ‡æ¢åˆ°æœç´¢Tab
                            setTimeout(() => {
                                document.querySelectorAll('.netease-tab')[0].click();
                            }, 1000);
                        }
                    } catch (e) {}
                }, 2000);
            } catch (e) {
                imgWrap.innerHTML = '<div class="netease-empty">ç”Ÿæˆå¤±è´¥: ' + e.message + '</div>';
                log('QR generate error: ' + e.message, 'error');
            }
        }
        
        // åˆ·æ–°äºŒç»´ç 
        window.refreshQRCode = generateQRCode;
        
        // é€€å‡ºç™»å½•
        window.neteaseLogout = function() {
            neteaseCookie = '';
            neteaseUser = null;
            myPlaylistsCache = null; // æ¸…é™¤æ­Œå•ç¼“å­˜
            localStorage.removeItem('netease_cookie');
            updateUserUI();
            document.getElementById('mylist-content').innerHTML = '<div class="netease-empty">è¯·å…ˆç™»å½•ç½‘æ˜“äº‘è´¦å·</div>';
            log('Logged out');
        };
        
        // åŠ è½½æˆ‘çš„æ­Œå•
        async function loadMyPlaylists() {
            const container = document.getElementById('mylist-content');
            
            if (!neteaseUser) {
                container.innerHTML = '<div class="netease-empty">è¯·å…ˆç™»å½•ç½‘æ˜“äº‘è´¦å·</div>';
                return;
            }
            
            // å¦‚æœæœ‰ç¼“å­˜ç›´æ¥ä½¿ç”¨
            if (myPlaylistsCache) {
                container.innerHTML = myPlaylistsCache;
                return;
            }
            
            container.innerHTML = '<div class="netease-loading">åŠ è½½ä¸­...</div>';
            
            try {
                const resp = await fetch(buildApiUrl(`/user/playlist?uid=${neteaseUser.userId}&cookie=${encodeURIComponent(cleanCookie(neteaseCookie))}`));
                if (!resp.ok) throw new Error('è·å–æ­Œå•å¤±è´¥');
                
                const json = await resp.json();
                const playlists = json.playlist;
                
                if (!playlists || playlists.length === 0) {
                    container.innerHTML = '<div class="netease-empty">æš‚æ— æ­Œå•</div>';
                    return;
                }
                
                // åˆ†ç±»ï¼šæˆ‘åˆ›å»ºçš„ & æˆ‘æ”¶è—çš„
                const created = playlists.filter(p => p.creator?.userId === neteaseUser.userId);
                const collected = playlists.filter(p => p.creator?.userId !== neteaseUser.userId);
                
                let html = '';
                
                if (created.length > 0) {
                    html += '<div class="my-playlists-title">ğŸ“ æˆ‘åˆ›å»ºçš„æ­Œå•</div>';
                    created.forEach(p => {
                        html += `
                            <div class="netease-item" onclick="loadPlaylistById(${p.id})">
                                <img class="netease-item-cover" src="${p.coverImgUrl}?param=100y100">
                                <div class="netease-item-info">
                                    <div class="netease-item-name">${p.name}</div>
                                    <div class="netease-item-artist">${p.trackCount} é¦–</div>
                                </div>
                            </div>
                        `;
                    });
                }
                
                if (collected.length > 0) {
                    html += '<div class="my-playlists-title" style="margin-top:15px">â¤ï¸ æˆ‘æ”¶è—çš„æ­Œå•</div>';
                    collected.forEach(p => {
                        html += `
                            <div class="netease-item" onclick="loadPlaylistById(${p.id})">
                                <img class="netease-item-cover" src="${p.coverImgUrl}?param=100y100">
                                <div class="netease-item-info">
                                    <div class="netease-item-name">${p.name}</div>
                                    <div class="netease-item-artist">${p.trackCount} é¦– Â· ${p.creator?.nickname || ''}</div>
                                </div>
                            </div>
                        `;
                    });
                }
                
                myPlaylistsCache = html; // ä¿å­˜ç¼“å­˜
                container.innerHTML = html;
                
            } catch (e) {
                container.innerHTML = '<div class="netease-empty">åŠ è½½å¤±è´¥: ' + e.message + '</div>';
            }
        }
        
        // ç‚¹å‡»æ­Œå•åŠ è½½
        window.loadPlaylistById = async function(id) {
            // åˆ‡æ¢åˆ°æ­Œå•Tab
            document.querySelectorAll('.netease-tab')[1].click();
            document.getElementById('netease-playlist-input').value = id;
            await fetchPlaylist(id);
        };
        
        // åˆå§‹åŒ–æ—¶æ£€æŸ¥ç™»å½•çŠ¶æ€
        checkLoginStatus();
        
        // å½“å‰åŠ è½½çš„æ­Œå•æ•°æ®
        let currentPlaylistData = null;
        
        // æœç´¢æ­Œæ›²
        async function searchNeteaseSongs(keyword) {
            if (!keyword.trim()) return;
            searchResults.innerHTML = '<div class="netease-loading">ğŸ” æœç´¢ä¸­...</div>';
            searchBtn.disabled = true;
            
            try {
                const resp = await fetch(buildApiUrl(`/search?keywords=${encodeURIComponent(keyword)}&limit=30`));
                if (!resp.ok) throw new Error('æœç´¢å¤±è´¥');
                
                const json = await resp.json();
                if (json.code !== 200 || !json.result?.songs?.length) {
                    searchResults.innerHTML = '<div class="netease-empty">æœªæ‰¾åˆ°ç›¸å…³æ­Œæ›²</div>';
                    return;
                }
                
                renderSongList(json.result.songs, searchResults, 0);
            } catch (e) {
                searchResults.innerHTML = '<div class="netease-empty">æœç´¢å¤±è´¥: ' + e.message + '</div>';
            } finally {
                searchBtn.disabled = false;
            }
        }
        
        // æ¸²æŸ“æ­Œæ›²åˆ—è¡¨ï¼ˆæ”¯æŒåˆ†é¡µï¼‰
        function renderSongList(songs, container, page = 0) {
            // ä¿æŒç”¨æˆ·å½“å‰é¡µ
            if (typeof renderSongList._page !== 'undefined' && typeof page === 'undefined') {
                page = renderSongList._page;
            }
            renderSongList._page = page;
            currentPlaylistSongs = songs;
            currentPage = page;
            const start = page * SONGS_PER_PAGE;
            const end = Math.min(start + SONGS_PER_PAGE, songs.length);
            const pageSongs = songs.slice(start, end);
            container.innerHTML = '';
            // ä½¿ç”¨ DocumentFragment æ‰¹é‡æ·»åŠ å…ƒç´ ï¼Œæé«˜æ€§èƒ½
            const fragment = document.createDocumentFragment();
            pageSongs.forEach(song => {
                const artists = (song.artists || song.ar || []).map(a => a.name).join(', ');
                const album = song.album?.name || song.al?.name || '';
                const duration = song.duration || song.dt || 0;
                const cover = song.album?.picUrl || song.al?.picUrl || '';
                const item = document.createElement('div');
                item.className = 'netease-item';
                item.innerHTML = `
                    <img class="netease-item-cover" data-src="${cover ? cover + '?param=100y100' : ''}" onerror="this.style.display='none'" loading="lazy">
                    <div class="netease-item-info">
                        <div class="netease-item-name">${song.name}</div>
                        <div class="netease-item-artist">${artists}${album ? ' Â· ' + album : ''}</div>
                    </div>
                    <span class="netease-item-duration">${fmtTime(duration / 1000)}</span>
                    <button class="netease-item-play">â–¶</button>
                `;
                item.querySelector('.netease-item-play').onclick = (e) => {
                    e.stopPropagation();
                    playNeteaseSong(song);
                };
                item.onclick = () => playNeteaseSong(song);
                fragment.appendChild(item);
            });
            container.appendChild(fragment);
            // æ·»åŠ åˆ†é¡µæ§ä»¶
            if (songs.length > SONGS_PER_PAGE) {
                const paginationDiv = document.createElement('div');
                paginationDiv.className = 'netease-pagination';
                paginationDiv.style.cssText = 'display: flex; justify-content: center; gap: 10px; margin-top: 15px; padding: 10px;';
                const totalPages = Math.ceil(songs.length / SONGS_PER_PAGE);
                // ä¸Šä¸€é¡µæŒ‰é’®
                if (page > 0) {
                    const prevBtn = document.createElement('button');
                    prevBtn.textContent = 'â—€ ä¸Šä¸€é¡µ';
                    prevBtn.style.cssText = 'padding: 8px 15px; border: 1px solid #ddd; border-radius: 5px; background: white; cursor: pointer;';
                    prevBtn.onclick = () => renderSongList(songs, container, page - 1);
                    paginationDiv.appendChild(prevBtn);
                }
                // é¡µç ä¿¡æ¯
                const pageInfo = document.createElement('span');
                pageInfo.textContent = `ç¬¬ ${page + 1} / ${totalPages} é¡µ (${songs.length} é¦–æ­Œæ›²)`;
                pageInfo.style.cssText = 'padding: 8px 15px; color: #666;';
                paginationDiv.appendChild(pageInfo);
                // ä¸‹ä¸€é¡µæŒ‰é’®
                if (end < songs.length) {
                    const nextBtn = document.createElement('button');
                    nextBtn.textContent = 'ä¸‹ä¸€é¡µ â–¶';
                    nextBtn.style.cssText = 'padding: 8px 15px; border: 1px solid #ddd; border-radius: 5px; background: white; cursor: pointer;';
                    nextBtn.onclick = () => renderSongList(songs, container, page + 1);
                    paginationDiv.appendChild(nextBtn);
                }
                container.appendChild(paginationDiv);
            }
            // é‡æ–°åˆå§‹åŒ–æ‡’åŠ è½½
            lazyLoadImages();
        }
        
        // æ’­æ”¾ç½‘æ˜“äº‘æ­Œæ›²
        async function playNeteaseSong(song) {
            // play token é˜²æ­¢æ—§çš„æ’­æ”¾è¯·æ±‚å®Œæˆåè¦†ç›–æ–°çš„æ’­æ”¾
            if (!window._playActionTokenSeed) window._playActionTokenSeed = 1;
            prefetchAttempted = false; // ç¡®ä¿æ–°æ­Œå¼€å§‹æ—¶ï¼Œå…è®¸è§¦å‘é¢„åŠ è½½
            const myPlayToken = ++window._playActionTokenSeed;
            window._currentPlayActionToken = myPlayToken;

            // æ ‡è®°å½“å‰æ’­æ”¾ä¸ºåœ¨çº¿ç½‘æ˜“äº‘æ­Œæ›²ï¼ˆç”¨äºä¸‹è½½æ£€æµ‹ï¼‰
            try {
                window._currentPlaying = {
                    netease: true,
                    songData: song,
                    songId: song.id,
                    name: song.name,
                    artists: (song.artists || song.ar || []).map(a => a.name).join(', ')
                };
            } catch (e) {}

            const songId = song.id;
            let songName = song.name;
            let artists = (song.artists || song.ar || []).map(a => a.name).join(', ');
            let cover = song.album?.picUrl || song.al?.picUrl || '';
            
            log(`Playing: ${songName} - ${artists}`);
            neteasePanel.classList.remove('show');
            
            // å¦‚æœæ²¡æœ‰å°é¢ï¼Œå…ˆå°è¯•ä»ç¼“å­˜æˆ–é˜Ÿåˆ—è·å–æ­Œæ›²è¯¦æƒ…
            if (!cover) {
                try {
                    const detailJson = await cachedFetchJson(buildApiUrl(`/song/detail?ids=${songId}`), { useQueue: true }, 60_000);
                    if (detailJson?.songs?.[0]) {
                        const detail = detailJson.songs[0];
                        cover = detail.al?.picUrl || '';
                        artists = (detail.ar || []).map(a => a.name).join(', ');
                    }
                } catch (e) {}
            }
            
            // æ›´æ–°UI
            el.title.textContent = songName;
            el.artist.textContent = artists;
            if (cover) {
                el.img.src = cover;
                el.img.onload = () => { el.img.style.opacity = 1; updateTheme(el.img); };
            } else {
                el.img.style.opacity = 0;
                updateTheme(null);
            }
            
            el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">ğŸ”„ è·å–éŸ³é¢‘...</div>';
            // ç«‹å³ä¸­æ–­ä¸Šä¸€ä¸ªæ’­æ”¾æ“ä½œå¹¶åœæ­¢å£°éŸ³
            stopAudio();
            resetLoopUI();
            lyrics = [];
            
            // å¦‚æœæœ‰æ­£åœ¨è¿›è¡Œçš„ next-song é¢„å– Promiseï¼Œä¸”å®ƒå¯¹åº”å½“å‰è¦æ’­æ”¾çš„æ­Œæ›²ï¼Œåˆ™å¤ç”¨è¯¥ Promiseï¼ˆé¿å…é‡å¤ä¸‹è½½ï¼‰
            try {
                const nextPrefetchMatches = nextSongFetchPromise && (typeof nextPreloadIndex === 'number') && playlist[nextPreloadIndex] && ((playlist[nextPreloadIndex].songId || playlist[nextPreloadIndex].songData?.id) == songId);
                if (nextPrefetchMatches) {
                    // ä¼˜åŒ–ï¼šä¼˜å…ˆæ£€æŸ¥æ˜¯å¦å·²å®Œæˆï¼ˆäº‹ä»¶é©±åŠ¨ï¼‰ï¼Œå¦åˆ™ç”¨å•æ¬¡è¶…æ—¶ç­‰å¾…ï¼ˆæœ€å¤š6000msï¼‰â€”â€”æ— è½®è¯¢ï¼Œå®Œæˆæ—¶ç«‹å³å“åº”
                    let res = null;
                    if (hasPreloaded && nextSongRawData) {
                        res = { ab: nextSongRawData };
                    } else if (nextSongFetchPromise) {
                        const wrapped = await waitForPromiseWithTimeout(nextSongFetchPromise, 6000);
                        res = wrapped.ok ? wrapped.value : null;
                    }

                    if (res && res.ab) {
                        el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">â³ ä½¿ç”¨é¢„åŠ è½½éŸ³é¢‘...</div>';
                        el.loadTip.style.display = 'block';
                        el.bufferLine.style.width = '30%';

                        const ab = res.ab;
                        // æ¸…ç†é¢„åŠ è½½çŠ¶æ€å¹¶é˜²æ­¢åç»­å¤ç”¨
                        nextSongRawData = null; hasPreloaded = false; nextPreloadIndex = null; prefetchAttempted = false;
                        try { nextSongFetchPromise = null; } catch(e) {}
                        if (nextSongAbortController) { try { if (typeof nextSongAbortController.abort === 'function') nextSongAbortController.abort(); } catch(e) {} nextSongAbortController = null; }

                        el.bufferLine.style.width = '60%';
                        audioBuffer = await actx.decodeAudioData(ab);
                        el.bufferLine.style.width = '100%';
                        playbackState.duration = audioBuffer.duration;
                        el.totalTime.textContent = fmtTime(playbackState.duration);
                        el.loadTip.style.display = 'none';

                        // æ’­æ”¾æˆåŠŸï¼Œæ¸…é™¤é‡è¯•è®¡æ•°ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼ 
                        if (window._playRetryMap && window._playRetryMap[songId]) {
                            delete window._playRetryMap[songId];
                        }


                        if (playlist[curIdx]) playlist[curIdx].songData = song;
                        renderPlaylist();

                        startAudio(0);
                        el.coverWrap.classList.add('playing');
                        updatePlayIcon();
                        updateMediaSession();

                        try { fetchLyricById(songId); } catch(_) {}

                        // é¢„å–ä¸‹ä¸€é¦–çš„å…ƒæ•°æ®ï¼ˆå¹¶å‘1ï¼‰
                        try {
                            const nextIdx = (curIdx + 1) < playlist.length ? (curIdx + 1) : null;
                            if (nextIdx !== null && playlist[nextIdx] && playlist[nextIdx].netease) {
                                const nextId = playlist[nextIdx].songId || playlist[nextIdx].songData?.id;
                                if (nextId) {
                                    const cookieParamLocal = neteaseCookie ? `&cookie=${encodeURIComponent(cleanCookie(neteaseCookie))}` : '';
                                    cachedFetchJson(buildApiUrl(`/song/detail?ids=${nextId}${cookieParamLocal}`), { useQueue: true }).catch(()=>{});
                                    cachedFetchJson(buildApiUrl(`/song/url/v1?id=${nextId}&level=${neteaseQuality}&os=pc${cookieParamLocal}`), { useQueue: true }).catch(()=>{});
                                }
                            }
                        } catch (_) {}

                        return;
                    } else {
                        // é¢„å–æœªåœ¨çŸ­æ—¶é—´å†…å®Œæˆï¼Œæ”¾å¼ƒå¤ç”¨ï¼Œå–æ¶ˆé¢„å–å¹¶ç»§ç»­åç»­æ­£å¸¸æµç¨‹
                        try { cancelNextPreload(); } catch(e) {}
                    }
                }
            } catch (e) {
                log('Prefetch reuse error, fallback: ' + (e && e.message), 'warn');
                try { cancelNextPreload(); } catch(e) {}
            }

            // åˆ›å»ºæ–°çš„ AbortControllerï¼ˆä¸play tokené…åˆï¼‰
            if (window.currentAbortController) window.currentAbortController.abort();
            window.currentAbortController = new AbortController();
            const controller = window.currentAbortController;
            const signal = controller.signal;

            try {
                // è·å–éŸ³é¢‘URL - ä½¿ç”¨æ–°ç‰ˆAPIæŒ‡å®šéŸ³è´¨ï¼Œä¼˜å…ˆä»ç¼“å­˜è·å–ï¼ˆçŸ­æ—¶ç¼“å­˜ï¼‰
                const cookieParam = neteaseCookie ? `&cookie=${encodeURIComponent(cleanCookie(neteaseCookie))}` : '';
                const levelParam = `&level=${neteaseQuality}&os=pc`;
                if (window._currentPlayActionToken !== myPlayToken) throw new Error('stale');
                const json = await cachedFetchJson(buildApiUrl(`/song/url/v1?id=${songId}${levelParam}${cookieParam}`), { signal, useQueue: true }, 30_000);
                if (window._currentPlayActionToken !== myPlayToken) { controller.abort(); throw new Error('stale'); }
                
                if (!json || json.code !== 200) throw new Error('è·å–éŸ³é¢‘å¤±è´¥');
                // ä¿è¯ä¸ä¼šå‡ºç°ç©ºå¼•ç”¨
                if (json.code !== 200) throw new Error('è·å–éŸ³é¢‘å¤±è´¥');
                let audioInfo = (json.data && json.data[0]) ? json.data[0] : null;
                // å¦‚æœè¿ç¬¬ä¸€ä¸ªéƒ½æ²¡æœ‰ï¼ŒæŠ›å‡ºç‰¹å®šé”™è¯¯ä»¥ä¾¿åç»­è§¦å‘å¼ºåˆ¶è§£ç°
                if (!audioInfo || !audioInfo.url) {
                    throw new Error('NO_URL_FROM_OFFICIAL');
                }
                let audioUrl = audioInfo.url;
                // è·å–éŸ³è´¨ä¿¡æ¯ - APIå¯èƒ½è¿”å›: br(æ¯”ç‰¹ç‡), type(æ ¼å¼), level, sr(é‡‡æ ·ç‡)ç­‰
                const brKbps = audioInfo.br ? Math.round(audioInfo.br / 1000) : null;
                const audioType = (audioInfo.type || 'mp3').toUpperCase();
                const sampleRate = audioInfo.sr || null; // é‡‡æ ·ç‡ (å¦‚44100)
                
                // Debugæ˜¾ç¤ºåŸå§‹ä¿¡æ¯
                log(`Audio: ${audioType} ${brKbps || '?'}kbps${sampleRate ? ` ${sampleRate}Hz` : ''}`, 'success');
                
                // æ ¹æ®æ ¼å¼å’Œå¯ç”¨ä¿¡æ¯æ„å»ºéŸ³è´¨æ ‡ç­¾
                let qualityStr = audioType;
                if (audioType === 'FLAC' || audioType === 'WAV' || audioType === 'AIFF') {
                    // æ— æŸæ ¼å¼ - ä¼˜å…ˆæ˜¾ç¤ºé‡‡æ ·ç‡ä¿¡æ¯
                    if (sampleRate) {
                        const srKhz = sampleRate >= 1000 ? (sampleRate / 1000).toFixed(sampleRate % 1000 === 0 ? 0 : 1) + 'kHz' : sampleRate + 'Hz';
                        // FLACé€šå¸¸æ˜¯16bitæˆ–24bitï¼Œæ ¹æ®æ¯”ç‰¹ç‡ä¼°ç®—
                        // 16bit/44.1kHz stereo â‰ˆ 1411kbps, 24bit/96kHz stereo â‰ˆ 4608kbps
                        if (brKbps) {
                            const estBitDepth = brKbps > 2000 ? 24 : 16;
                            qualityStr = `${audioType} ${estBitDepth}bit/${srKhz}`;
                        } else {
                            qualityStr = `${audioType} ${srKhz}`;
                        }
                    } else if (brKbps) {
                        // æ²¡æœ‰é‡‡æ ·ç‡ä½†æœ‰æ¯”ç‰¹ç‡ï¼Œæ ¹æ®æ¯”ç‰¹ç‡ä¼°ç®—
                        const estBitDepth = brKbps > 2000 ? 24 : 16;
                        const estSr = brKbps > 2000 ? '96kHz' : '44.1kHz';
                        qualityStr = `${audioType} ${estBitDepth}bit/${estSr}`;
                    }
                } else {
                    // æœ‰æŸæ ¼å¼ - æ˜¾ç¤ºæ¯”ç‰¹ç‡
                    if (brKbps) {
                        qualityStr = `${audioType} ${brKbps}kbps`;
                    }
                }
                
                currentAudioQuality = qualityStr;
                
                // ç¡®ä¿ä½¿ç”¨ https
                audioUrl = audioUrl.replace('http://', 'https://');
                log(`Audio URL: ${audioUrl}`);
                
                el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">â³ åŠ è½½éŸ³é¢‘...</div>';
                el.loadTip.style.display = 'block';
                el.bufferLine.style.width = '30%';
                
                // è·å–éŸ³é¢‘æ•°æ®
                // äºŒæ¬¡æ£€æŸ¥ï¼šç¡®ä¿ä»æ˜¯å½“å‰æ’­æ”¾è¯·æ±‚
                if (window._currentPlayActionToken !== myPlayToken) { controller.abort(); throw new Error('stale'); }
                const audioResp = await fetch(audioUrl, { signal });
                if (window._currentPlayActionToken !== myPlayToken) { controller.abort(); throw new Error('stale'); }
                if (!audioResp.ok) throw new Error('éŸ³é¢‘åŠ è½½å¤±è´¥');
                
                el.bufferLine.style.width = '60%';
                const ab = await audioResp.arrayBuffer();
                if (window._currentPlayActionToken !== myPlayToken) { controller.abort(); throw new Error('stale'); }
                
                el.bufferLine.style.width = '80%';
                audioBuffer = await actx.decodeAudioData(ab);
                if (window._currentPlayActionToken !== myPlayToken) { controller.abort(); throw new Error('stale'); }
                
                el.bufferLine.style.width = '100%';
                playbackState.duration = audioBuffer.duration;
                el.totalTime.textContent = fmtTime(playbackState.duration);
                el.loadTip.style.display = 'none';
                
                // æ’­æ”¾æˆåŠŸï¼Œæ¸…é™¤é‡è¯•è®¡æ•°ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
                if (window._playRetryMap && window._playRetryMap[songId]) {
                delete window._playRetryMap[songId];
}
                
                // æ›´æ–°å½“å‰æ’­æ”¾é¡¹çš„ songDataï¼ˆä¸è¦†ç›–æ•´ä¸ªæ’­æ”¾åˆ—è¡¨ï¼‰
                if (playlist[curIdx]) {
                    playlist[curIdx].songData = song;
                }
                renderPlaylist();
                
                startAudio(0);
                el.coverWrap.classList.add('playing');
                updatePlayIcon();
                updateMediaSession();
                
                // ç›´æ¥ç”¨æ­Œæ›²IDè·å–æ­Œè¯ï¼ˆå·²çŸ¥IDæ— éœ€æœç´¢ï¼‰
                try { fetchLyricById(songId); } catch(_) {}

                    // é¢„å–ä¸‹ä¸€é¦–çš„å…ƒæ•°æ®ï¼ˆå¹¶å‘1ï¼‰ï¼Œå¸¦ cookie ä»¥é¿å…æƒé™/åŒ¹é…é—®é¢˜
                    try {
                        const nextIdx = (curIdx + 1) < playlist.length ? (curIdx + 1) : null;
                        if (nextIdx !== null && playlist[nextIdx] && playlist[nextIdx].netease) {
                            const nextId = playlist[nextIdx].songId || playlist[nextIdx].songData?.id;
                            if (nextId) {
                                const cookieParam = neteaseCookie ? `&cookie=${encodeURIComponent(cleanCookie(neteaseCookie))}` : '';
                                // é¢„å– song/detail å’Œ song/urlï¼ˆçŸ­æ—¶ç¼“å­˜ï¼‰
                                // ä½¿ç”¨ cachedFetchJson æ›¿ä»£ prefetchFetchï¼Œç¡®ä¿ç»“æœè¢«å†™å…¥ IDB ç¼“å­˜
                                cachedFetchJson(buildApiUrl(`/song/detail?ids=${nextId}${cookieParam}`), { useQueue: true }).catch(()=>{});
                                cachedFetchJson(buildApiUrl(`/song/url/v1?id=${nextId}&level=${neteaseQuality}&os=pc${cookieParam}`), { useQueue: true }).catch(()=>{});
                            }
                        }
                    } catch (_) {}
                
            } catch (e) {
                if (e.message === 'stale' || e.name === 'AbortError') {
                    // è¿‡æœŸæˆ–è¢«å–æ¶ˆï¼Œä¸è®°å½•ä¸ºé”™è¯¯
                    log('Play request aborted/stale');
                    return;
                }
                // å¦‚æœæ˜¯æ²¡æœ‰å®˜æ–¹é“¾æ¥æˆ– 404ï¼Œå°è¯•å¼ºåˆ¶è§¦å‘è§£ç°å¹¶é‡è¯•ï¼ˆæœ€å¤šé‡è¯•ä¸€æ¬¡ï¼‰
                const errMsg = (e && e.message) ? e.message : '';
                const isNoUrl = errMsg === 'NO_URL_FROM_OFFICIAL' || errMsg.includes('404') || errMsg.includes('HTTP 404');
                window._playRetryMap = window._playRetryMap || {};
                const alreadyRetried = window._playRetryMap[songId] || 0;
                if (isNoUrl && alreadyRetried < 1) {
                    window._playRetryMap[songId] = alreadyRetried + 1;
                    log('âš ï¸ å®˜æ–¹æ— é“¾æ¥æˆ–é“¾æ¥å¤±æ•ˆï¼Œå°è¯•å¼ºåˆ¶è§¦å‘è§£ç°å¹¶é‡è¯•...', 'warn');
                    try {
                        const cookieParam = neteaseCookie ? `&cookie=${encodeURIComponent(cleanCookie(neteaseCookie))}` : '';
                        // æ¸…é™¤åŸå§‹ç¼“å­˜ï¼ˆè‹¥æœ‰ï¼‰
                        try { await idbDelete('json|' + buildApiUrl(`/song/url/v1?id=${songId}&level=${neteaseQuality}&os=pc${cookieParam}`)); } catch(_) {}
                        // å¼ºåˆ¶ä»¥ standard è¯·æ±‚å¹¶å¸¦æ—¶é—´æˆ³ç»•è¿‡ç¼“å­˜ï¼Œè§¦å‘æœåŠ¡å™¨é‡æ–°ç”Ÿæˆé“¾æ¥
                        const retryUrl = buildApiUrl(`/song/url/v1?id=${songId}&level=standard&noCache=${Date.now()}&os=pc${cookieParam}`);
                        try { await cachedFetchJson(retryUrl, { useQueue: true }, 30_000); } catch (_) {}
                    } catch (_) {}
                    // é‡æ–°å‘èµ·æ’­æ”¾è¯·æ±‚ï¼ˆæ–°çš„è¯·æ±‚ä¼šé‡æ–°èµ°è·å–é€»è¾‘ï¼‰
                    return playNeteaseSong(song);
                }
                log('Play error: ' + e.message, 'error');
                el.lyricBox.innerHTML = `<div class="lyric-line active" style="margin-top:100px">âŒ ${e.message}</div>`;
                el.loadTip.style.display = 'none';
            } finally {
                if (window.currentAbortController && window.currentAbortController.signal.aborted) window.currentAbortController = null;
            }
        }
        
        // å–æ¶ˆæ­Œå•è¯·æ±‚
        window.cancelPlaylistRequest = function() {
            if (window.currentPlaylistAbortController) {
                window.currentPlaylistAbortController.abort();
                window.currentPlaylistAbortController = null;
            }
        };
        
        // è·å–æ­Œå•
        async function fetchPlaylist(input) {
                                    // åˆ†æ­¥åŠ è½½å”¯ä¸€tokenï¼Œåˆ‡æ­Œå•æ—¶åªå…è®¸å½“å‰tokençš„loadBatchæ¸²æŸ“
                                    if (!window._playlistLoadTokenSeed) window._playlistLoadTokenSeed = 1;
                                    const myLoadToken = ++window._playlistLoadTokenSeed;
                                    window._currentPlaylistLoadToken = myLoadToken;
                        // åˆ‡æ¢æ­Œå•æ—¶ï¼Œå…ˆä¸­æ–­ä¸Šä¸€ä¸ªåŠ è½½
                        if (window.currentPlaylistAbortController) {
                            window.currentPlaylistAbortController.abort();
                            window.currentPlaylistAbortController = null;
                        }
            // è§£ææ­Œå•ID
            let playlistId = input.trim();
            
            // ä»é“¾æ¥ä¸­æå–ID
            const match = input.match(/playlist[?/].*?id[=/]?(\d+)/i) || input.match(/(\d{5,})/);
            if (match) playlistId = match[1];
            
            if (!playlistId || !/^\d+$/.test(playlistId)) {
                playlistResults.innerHTML = '<div class="netease-empty">æ— æ•ˆçš„æ­Œå•é“¾æ¥æˆ–ID</div>';
                return;
            }
            
            playlistResults.innerHTML = '<div class="netease-loading">ğŸ”„ è·å–æ­Œå•ä¿¡æ¯... <button onclick="cancelPlaylistRequest()" style="margin-left:10px; padding:2px 8px; font-size:12px;">å–æ¶ˆ</button></div>';
            playlistPreview.innerHTML = '';
            playlistBtn.disabled = true;
            currentPlaylistData = null;
            
            // åˆ›å»º AbortController ç”¨äºå–æ¶ˆè¯·æ±‚
            const abortController = new AbortController();
            window.currentPlaylistAbortController = abortController; // å…¨å±€ä¿å­˜ç”¨äºå–æ¶ˆ
            
            const timeoutId = setTimeout(() => {
                abortController.abort();
                playlistResults.innerHTML = '<div class="netease-empty">è¯·æ±‚è¶…æ—¶ï¼Œè¯·é‡è¯•</div>';
                playlistBtn.disabled = false;
            }, 15000); // 15ç§’è¶…æ—¶
            
            try {
                const cookieParam = neteaseCookie ? `&cookie=${encodeURIComponent(cleanCookie(neteaseCookie))}` : '';
                playlistResults.innerHTML = '<div class="netease-loading">ğŸ”„ è¿æ¥ç½‘æ˜“äº‘éŸ³ä¹...</div>';
                // 1. è·å–æ­Œå•åŸºæœ¬ä¿¡æ¯ï¼ˆä¸å¸¦tracksï¼‰
                const json = await cachedFetchJson(buildApiUrl(`/playlist/detail?id=${playlistId}&s=0${cookieParam}`), { signal: abortController.signal, headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36' }, useQueue: true }, 30_000);
                clearTimeout(timeoutId);
                if (!json) throw new Error('æ— æ³•è·å–æ­Œå•ä¿¡æ¯');
                if (json.code !== 200 || !json.playlist) {
                    throw new Error('æ— æ³•è·å–æ­Œå•ä¿¡æ¯ï¼Œå¯èƒ½éœ€è¦ç™»å½•æˆ–æ­Œå•ä¸å­˜åœ¨');
                }
                const data = json.playlist;
                currentPlaylistData = data;
                // æ˜¾ç¤ºæ­Œå•åŸºæœ¬ä¿¡æ¯ï¼ˆæ— tracksï¼‰
                const trackCount = data.trackCount || 0;
                playlistPreview.innerHTML = `
                    <div class=\"netease-playlist-info\">
                        <img class=\"netease-playlist-cover\" data-src=\"${data.coverImgUrl}?param=200y200\" loading=\"lazy\">
                        <div class=\"netease-playlist-meta\">
                            <div class=\"netease-playlist-name\">${data.name}</div>
                            <div class=\"netease-playlist-desc\">${trackCount} é¦–æ­Œæ›² Â· ${data.playCount ? Math.floor(data.playCount/10000) + 'ä¸‡æ’­æ”¾' : ''}</div>
                            <button class=\"netease-import-btn\" onclick=\"importPlaylistToQueue()\">ğŸ“¥ å¯¼å…¥åˆ°æ’­æ”¾åˆ—è¡¨</button>
                        </div>
                    </div>
                `;
                playlistResults.innerHTML = `<div class=\"netease-loading\">ğŸ”„ æ­Œå•ä¿¡æ¯åŠ è½½å®Œæˆï¼Œæ­£åœ¨åˆ†æ­¥åŠ è½½æ­Œæ›²... (å…±${trackCount}é¦–)</div>`;
                // 2. åˆ†æ­¥å¹¶å‘åŠ è½½æ­Œæ›²è¯¦æƒ…ï¼ˆé™å¹¶å‘ worker æ± ï¼‰
                let allTracks = [];
                const limit = 50;
                let loading = true;

                async function fetchBatchesConcurrently(concurrency = 3) {
                    const offsets = [];
                    for (let o = 0; o < trackCount; o += limit) offsets.push(o);
                    const resultsMap = new Map();
                    let idx = 0;

                    // ç®€å•çš„ 429/çŸ­æœŸé”™è¯¯é€€é¿é‡è¯•å™¨ï¼ˆç”¨äºä¿æŠ¤ Zeabur ç«¯ç‚¹ï¼‰
                    async function fetchWithRetry(url, opts = {}) {
                        const maxRetries = 5;
                        let attempt = 0;
                        let backoff = 250; // ms
                        while (true) {
                            if (abortController.signal.aborted || window._currentPlaylistLoadToken !== myLoadToken) throw new DOMException('aborted', 'AbortError');
                            try {
                                const resp = await fetch(url, opts);
                                if (resp.status === 429) {
                                    log(`429 received for ${url} (attempt ${attempt+1}), backing off ${backoff}ms`, 'error');
                                    if (attempt >= maxRetries) throw new Error('Too many 429 responses');
                                    const jitter = Math.floor(Math.random() * 200);
                                    await new Promise(r => setTimeout(r, backoff + jitter));
                                    attempt++;
                                    backoff *= 2;
                                    continue;
                                }
                                if (!resp.ok && resp.status >= 500 && attempt < maxRetries) {
                                    log(`server error ${resp.status} for ${url}, retrying (attempt ${attempt+1})`, 'error');
                                    const jitter = Math.floor(Math.random() * 200);
                                    await new Promise(r => setTimeout(r, backoff + jitter));
                                    attempt++;
                                    backoff *= 2;
                                    continue;
                                }
                                return resp;
                            } catch (err) {
                                // ä»…åœ¨ fetch æŠ›é”™æ—¶é‡è¯•ä¸€æ¬¡ï¼Œé¿å…æ— é™å¾ªç¯
                                log(`fetch error for ${url}: ${err}. retrying (attempt ${attempt+1})`, 'error');
                                if (attempt >= maxRetries) throw err;
                                const jitter = Math.floor(Math.random() * 200);
                                await new Promise(r => setTimeout(r, backoff + jitter));
                                attempt++;
                                backoff *= 2;
                            }
                        }
                    }

                    async function worker() {
                        while (true) {
                            if (abortController.signal.aborted || window._currentPlaylistLoadToken !== myLoadToken) return;
                            const myIdx = idx++;
                            if (myIdx >= offsets.length) return;
                            const myOffset = offsets[myIdx];
                            try {
                                const url = buildApiUrl(`/playlist/track/all?id=${playlistId}&limit=${limit}&offset=${myOffset}${cookieParam}`);
                                const t0 = performance.now();
                                const respBatch = await fetchWithRetry(url, { signal: abortController.signal });
                                const tFetch = performance.now();
                                if (abortController.signal.aborted) return;
                                if (!respBatch.ok) throw new Error('æ­Œæ›²è¯¦æƒ…åŠ è½½å¤±è´¥: ' + respBatch.status);
                                // è¯»å–éƒ¨åˆ†å“åº”å¤´ç”¨äºè°ƒè¯•
                                const contentLen = respBatch.headers.get('content-length') || respBatch.headers.get('Content-Length') || 'unknown';
                                const contentEnc = respBatch.headers.get('content-encoding') || respBatch.headers.get('Content-Encoding') || 'none';
                                const altSvc = respBatch.headers.get('alt-svc') || respBatch.headers.get('Alt-Svc') || '';
                                const bj = await respBatch.json();
                                const tJson = performance.now();
                                if (abortController.signal.aborted) return;
                                if (bj.code !== 200 || !bj.songs) throw new Error('æ­Œæ›²è¯¦æƒ…è·å–å¤±è´¥');
                                resultsMap.set(myOffset, bj.songs);
                                // ä¼°ç®—å“åº”ä½“å¤§å°ï¼ˆå­—ç¬¦æ•°ï¼‰å¹¶è¾“å‡ºè°ƒè¯•ä¿¡æ¯
                                let approxSize = 0;
                                try { approxSize = JSON.stringify(bj).length; } catch(e) { approxSize = -1; }
                                if (window.DEBUG) {
                                    log(`batch offset=${myOffset} status=${respBatch.status} fetchMs=${(tFetch-t0).toFixed(1)} jsonMs=${(tJson-tFetch).toFixed(1)} totalMs=${(tJson-t0).toFixed(1)} size=${approxSize} hdr_len=${contentLen} enc=${contentEnc} alt=${altSvc}`);
                                }
                                // åˆå¹¶å·²åˆ°è¾¾çš„æ‰¹æ¬¡å¹¶æ¸²æŸ“
                                const merged = [];
                                for (let o of offsets) {
                                    if (resultsMap.has(o)) merged.push(...resultsMap.get(o));
                                    else break; // ä¿æŒé¡ºåºç›´åˆ°ç¬¬ä¸€ä¸ªç¼ºå¤±æ‰¹æ¬¡
                                }
                                allTracks = merged;
                                const keepPage = typeof renderSongList._page === 'number' ? renderSongList._page : 0;
                                if (window._currentPlaylistLoadToken !== myLoadToken) return;
                                renderSongList(allTracks, playlistResults, keepPage);
                                // æ›´æ–°è¿›åº¦æç¤º
                                const progressDiv = document.createElement('div');
                                progressDiv.className = 'netease-loading';
                                progressDiv.textContent = `ğŸ”„ å·²åŠ è½½ ${allTracks.length}/${trackCount} é¦–...`;
                                const old = playlistResults.querySelector('.netease-loading');
                                if (old) old.remove();
                                playlistResults.appendChild(progressDiv);
                            } catch (e) {
                                if (e.name === 'AbortError') return;
                                console.warn('batch error', e);
                            }
                        }
                    }

                    await Promise.all(new Array(Math.max(1, Math.min(concurrency, offsets.length))).fill(0).map(() => worker()));
                    // æ‰€æœ‰å®Œæˆååˆå¹¶æ‰€æœ‰æ‰¹æ¬¡ï¼ˆæŒ‰ offset æ’åºï¼‰
                    const sortedOffsets = Array.from(resultsMap.keys()).sort((a,b)=>a-b);
                    const mergedAll = [];
                    for (const o of sortedOffsets) mergedAll.push(...resultsMap.get(o));
                    return mergedAll;
                }

                try {
                    const concurrency = 3; // å¯è°ƒï¼š3~6 ä¹‹é—´è§†æœåŠ¡ç¨³å®šæ€§è€Œå®š
                    const merged = await fetchBatchesConcurrently(concurrency);
                    if (abortController.signal.aborted || window._currentPlaylistLoadToken !== myLoadToken) {
                        // è¢«å–æ¶ˆæˆ–å·²åˆ‡æ¢æ­Œå•
                        loading = false;
                        return;
                    }
                    allTracks = merged;
                    loading = false;
                    const old = playlistResults.querySelector('.netease-loading'); if (old) old.remove();
                    renderSongList(allTracks, playlistResults, 0);
                    currentPlaylistData.tracks = allTracks;
                } catch (e) {
                    if (e.name === 'AbortError') {
                        // ignore
                    } else {
                        throw e;
                    }
                }
            } catch (e) {
                clearTimeout(timeoutId);
                if (e.name === 'AbortError') {
                    playlistResults.innerHTML = '<div class="netease-empty">è¯·æ±‚å·²å–æ¶ˆæˆ–è¶…æ—¶</div>';
                } else {
                    playlistResults.innerHTML = '<div class="netease-empty">è·å–å¤±è´¥: ' + e.message + '</div>';
                }
            } finally {
                playlistBtn.disabled = false;
                window.currentPlaylistAbortController = null;
            }
        }
        
        // å¯¼å…¥æ­Œå•åˆ°æ’­æ”¾é˜Ÿåˆ—
        window.importPlaylistToQueue = async function() {
            if (!currentPlaylistData || !currentPlaylistData.tracks) return;
            
            const tracks = currentPlaylistData.tracks;
            log(`Importing ${tracks.length} songs from playlist`);
            
            // åˆ›å»ºæ’­æ”¾åˆ—è¡¨æ¡ç›®
            playlist = tracks.map(song => {
                const artists = (song.ar || []).map(a => a.name).join(', ');
                return {
                    name: `${song.name} - ${artists}`,
                    netease: true,
                    songId: song.id,
                    songData: song
                };
            });
            
            curIdx = -1;
            renderPlaylist();
            neteasePanel.classList.remove('show');
            document.getElementById('playlist-sidebar').classList.add('show');
            
            log(`Imported ${playlist.length} songs`, 'success');
            
            // è‡ªåŠ¨æ’­æ”¾ç¬¬ä¸€é¦–
            if (playlist.length > 0) {
                playTrackFromPlaylist(0);
            }
        };
        
        // ä»æ’­æ”¾åˆ—è¡¨æ’­æ”¾ï¼ˆæ”¯æŒæœ¬åœ°å’Œç½‘æ˜“äº‘ï¼‰
        async function playTrackFromPlaylist(i) {
            if (i < 0 || i >= playlist.length) return;
            const track = playlist[i];
            curIdx = i;
            renderPlaylist();
            
            
            if (track.netease) {
                // ç½‘æ˜“äº‘æ­Œæ›²
                if (track.songData) {
                    await playNeteaseSong(track.songData);
                } else {
                    // éœ€è¦é‡æ–°è·å–æ­Œæ›²ä¿¡æ¯
                    el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">ğŸ”„ è·å–æ­Œæ›²ä¿¡æ¯...</div>';
                    try {
                        const json = await cachedFetchJson(buildApiUrl(`/song/detail?ids=${track.songId}`), { useQueue: true }, 60_000);
                        if (json?.songs?.[0]) {
                            track.songData = json.songs[0];
                            await playNeteaseSong(track.songData);
                            return;
                        }
                    } catch (e) {
                        log('Error: ' + e.message, 'error');
                    }
                }
            } else {
                // æœ¬åœ°æ–‡ä»¶
                await playTrack(i);
            }
        }
        
        // ä¿®æ”¹ handleNextï¼šåŒºåˆ†æ‰‹åŠ¨ç‚¹å‡» å’Œ è‡ªåŠ¨æ’­æ”¾ç»“æŸ
        // ç‚¹å‡»æŒ‰é’®æ—¶ä¼šä¼ å…¥ Event å¯¹è±¡ï¼ˆtruthyï¼‰ï¼Œè‡ªåŠ¨æ’­æ”¾ç»“æŸè°ƒç”¨æ—¶æ²¡æœ‰å‚æ•°ï¼ˆfalsyï¼‰
        const originalHandleNext = handleNext;
        handleNext = function(e) {
            if (playlist.length === 0) return;

            const isAuto = !e; // è‡ªåŠ¨è§¦å‘ï¼ˆæ’­æ”¾ç»“æŸï¼‰æ—¶ä¸º true

            // ä»…åœ¨è‡ªåŠ¨è§¦å‘ä¸”ä¸ºå•æ›²å¾ªç¯æ—¶ï¼Œç›´æ¥é‡æ”¾å†…å­˜ä¸­çš„å·²è§£ç éŸ³é¢‘ï¼ˆç¬æ—¶ï¼Œæ— ç½‘ç»œ/è§£ç å¼€é”€ï¼‰
            if (isAuto && playMode === 2 && audioBuffer) {
                log('Single Loop: Auto Replay âš¡ï¸');
                startAudio(0);
                try { if (el && el.coverWrap) el.coverWrap.classList.add('playing'); } catch(err) {}
                return;
            }
            // ç¡®å®šç›®æ ‡ä¸‹ä¸€é¦–ç´¢å¼•ï¼ˆåœ¨å†³å®šåå†è¯„ä¼°æ˜¯å¦å–æ¶ˆé¢„å–ï¼Œä»¥ä¾¿åœ¨æ‰‹åŠ¨åˆ‡æ­Œæ—¶å¤ç”¨é¢„åŠ è½½ï¼‰
            let nextIdx;
            if (playMode === 1) {
                if (playlist.length === 1) return;
                // ä¼˜å…ˆä½¿ç”¨å·²é¢„åŠ è½½çš„éšæœºç›®æ ‡ï¼ˆå¦‚æœå­˜åœ¨ï¼‰ï¼Œä»¥æå‡å‘½ä¸­ç‡
                if (hasPreloaded && nextPreloadIndex !== null && nextPreloadIndex !== curIdx) nextIdx = nextPreloadIndex;
                else {
                    nextIdx = Math.floor(Math.random() * playlist.length);
                    if (nextIdx === curIdx) nextIdx = (nextIdx + 1) % playlist.length;
                }
            } else {
                nextIdx = curIdx + 1 >= playlist.length ? 0 : curIdx + 1;
            }

            // æ‰‹åŠ¨è§¦å‘æ—¶ï¼šä»…åœ¨ç›®æ ‡ä¸æ˜¯å½“å‰æ­£åœ¨/å·²é¢„åŠ è½½çš„é‚£ä¸€é¦–æ—¶æ‰å–æ¶ˆé¢„å–ï¼ˆå¦åˆ™ä¿ç•™ä»¥å¤ç”¨ï¼‰
            if (!isAuto) {
                const prefetchMatchesTarget = (nextPreloadIndex !== null && nextPreloadIndex === nextIdx);
                const hasOngoingPrefetch = prefetchInProgress || hasPreloaded || !!nextSongFetchPromise;
                if (!prefetchMatchesTarget || !hasOngoingPrefetch) {
                    try { cancelNextPreload(); } catch(err) {}
                }
            }

            playTrackFromPlaylist(nextIdx);
        };
        
        // ä¿®æ”¹ä¸Šä¸€æ›²/ä¸‹ä¸€æ›²æŒ‰é’®
        document.getElementById('prev-btn').onclick = () => {
            if (playlist.length === 0) return;
            try { cancelNextPreload(); } catch(e) {}
            playTrackFromPlaylist(curIdx - 1 < 0 ? playlist.length - 1 : curIdx - 1);
        };
        document.getElementById('next-btn').onclick = handleNext;
        
        // æœç´¢æŒ‰é’®å’Œå›è½¦
        searchBtn.onclick = () => searchNeteaseSongs(searchInput.value);
        searchInput.onkeypress = (e) => { if (e.key === 'Enter') searchNeteaseSongs(searchInput.value); };
        
        // æ­Œå•æŒ‰é’®å’Œå›è½¦
        playlistBtn.onclick = () => fetchPlaylist(playlistInput.value);
        playlistInput.onkeypress = (e) => { if (e.key === 'Enter') fetchPlaylist(playlistInput.value); };
        
        // ç§»åŠ¨ç«¯é«˜çº§èœå•
        const advancedBtn = document.getElementById('toggle-advanced');
        const advancedMenu = document.getElementById('advanced-menu');
        if (advancedBtn && advancedMenu) {
            advancedBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                advancedMenu.classList.toggle('show');
            });
            
            // ç‚¹å‡»èœå•é¡¹
            advancedMenu.querySelectorAll('.advanced-menu-item').forEach(item => {
                item.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const action = this.dataset.action;
                    advancedMenu.classList.remove('show');
                    
                    if (action === 'debug') {
                        const dbg = document.getElementById('debug-console');
                        dbg.style.display = (dbg.style.display === 'none' || dbg.style.display === '') ? 'block' : 'none';
                    } else if (action === 'analyze') {
                        document.getElementById('analyze-panel').classList.toggle('show');
                    } else if (action === 'loop') {
                        document.getElementById('loop-panel').classList.toggle('show');
                    } else if (action === 'netease-lyrics') {
                        // åˆ‡æ¢äº‘è¯å¼€å…³
                        neteaseSearchEnabled = !neteaseSearchEnabled;
                        neteaseBtn.style.background = neteaseSearchEnabled ? '#27ae60' : '';
                        neteaseBtn.style.color = neteaseSearchEnabled ? '#fff' : '';
                        log(`Netease lyrics search: ${neteaseSearchEnabled ? 'ON' : 'OFF'}`);
                        alert(`äº‘è¯æœç´¢å·²${neteaseSearchEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
                    } else if (action === 'effects') {
                        // å¾ªç¯åˆ‡æ¢ç‰¹æ•ˆ
                        const options = ['none', 'snow', 'bars', 'waves'];
                        const names = ['æ— ç‰¹æ•ˆ', 'å‡›å†¬é£é›ª', 'å¾‹åŠ¨é¢‘è°±', 'æå…‰æ³¢æµª'];
                        const current = options.indexOf(el.effectSel.value);
                        const next = (current + 1) % options.length;
                        el.effectSel.value = options[next];
                        alert(`ç‰¹æ•ˆ: ${names[next]}`);
                    } else if (action === 'lyric-toggle') {
                        // ä¼˜å…ˆå¤ç”¨æ¡Œé¢æŒ‰é’®é€»è¾‘ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                        if (lyricToggleBtn) {
                            lyricToggleBtn.click();
                        } else {
                            // å¤‡ç”¨ï¼šç›´æ¥åˆ‡æ¢çŠ¶æ€å¹¶è§¦å‘æ¸²æŸ“/å¢é‡æ›´æ–°
                            lyricDisplayMode = lyricDisplayMode === 'original' ? 'both' : 'original';
                            localStorage.setItem('lyric_mode', lyricDisplayMode);
                            const lines = el.lyricBox.querySelectorAll('.lyric-line');
                            if (lines && lines.length && (originalLyricsArr.some(l=>l.t>=0) || translatedLyricsArr.some(l=>l.t>=0))) {
                                if (lyricDisplayMode === 'both') {
                                    lines.forEach(lineEl => {
                                        if (lineEl.querySelector('.lyric-translation')) return;
                                        const t = parseFloat(lineEl.dataset.time || -1);
                                        if (isNaN(t) || t < 0) return;
                                        const trans = translatedLyricsArr.find(x => Math.abs(x.t - t) < 0.05);
                                        if (trans && trans.txt) {
                                            const tdiv = document.createElement('div');
                                            tdiv.className = 'lyric-translation';
                                            tdiv.textContent = trans.txt;
                                            lineEl.appendChild(tdiv);
                                        }
                                    });
                                } else {
                                    el.lyricBox.querySelectorAll('.lyric-translation').forEach(n => n.remove());
                                }
                            } else {
                                renderLyricsFromArrays();
                            }
                            updateLyricToggleUI(!!(translatedLyricsArr && translatedLyricsArr.length));
                        }
                        alert('å·²åˆ‡æ¢æ­Œè¯æ˜¾ç¤ºæ¨¡å¼');
                    }
                });
            });
            
            // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­èœå•
            document.addEventListener('click', function(e) {
                if (!advancedBtn.contains(e.target) && !advancedMenu.contains(e.target)) {
                    advancedMenu.classList.remove('show');
                }
            });
        } else {
            console.log('Advanced menu elements not found:', { advancedBtn, advancedMenu });
        }
        
        updateTheme(null);
        
        // æ‡’åŠ è½½å›¾ç‰‡å®ç°
        const lazyLoadImages = () => {
            const imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        img.src = img.dataset.src;
                        img.classList.remove('lazy');
                        observer.unobserve(img);
                    }
                });
            });
            
            // è§‚å¯Ÿæ‰€æœ‰æ‡’åŠ è½½å›¾ç‰‡
            document.querySelectorAll('img[data-src]').forEach(img => {
                imageObserver.observe(img);
            });
        };
        
        // åˆå§‹åŒ–æ‡’åŠ è½½
        lazyLoadImages();

        // ========== æ’­æ”¾åˆ—è¡¨æŒä¹…åŒ–ä¿å­˜ (æ–°å¢åŠŸèƒ½) ==========

        // ä¿å­˜æ’­æ”¾åˆ—è¡¨ (ä»…é™ç½‘æ˜“äº‘èµ„æº)
        function saveCurrentPlaylist() {
            try {
                const savedList = playlist
                    .filter(track => track.netease)
                    .map(track => ({
                        name: track.name,
                        id: track.songId || track.songData?.id,
                        ar: track.songData?.artists || track.songData?.ar || [],
                        al: track.songData?.album || track.songData?.al || {}
                    }));

                if (savedList.length > 0) {
                    localStorage.setItem('aurora_saved_playlist', JSON.stringify(savedList));
                    localStorage.setItem('aurora_saved_index', String(curIdx || 0));
                    // ä¸ç”¨é¢‘ç¹ logï¼Œä¿æŒè½»é‡
                } else {
                    localStorage.removeItem('aurora_saved_playlist');
                    localStorage.removeItem('aurora_saved_index');
                }
            } catch (e) {
                console.warn('saveCurrentPlaylist error', e);
            }
        }

        // æ¢å¤æ’­æ”¾åˆ—è¡¨
        function restoreSavedPlaylist() {
            try {
                const rawList = localStorage.getItem('aurora_saved_playlist');
                const rawIdx = localStorage.getItem('aurora_saved_index');
                if (!rawList) return;
                const parsedList = JSON.parse(rawList);
                if (!Array.isArray(parsedList) || parsedList.length === 0) return;

                const restoredTracks = parsedList.map(item => ({
                    name: item.name,
                    netease: true,
                    songId: item.id,
                    songData: {
                        id: item.id,
                        name: (item.name || '').split(' - ')[0] || item.name,
                        ar: item.ar || [],
                        al: item.al || {},
                        artists: item.ar || [],
                        album: item.al || {}
                    }
                }));

                if (playlist.length === 0) {
                    playlist = restoredTracks;
                    curIdx = Math.max(0, Math.min(restoredTracks.length - 1, parseInt(rawIdx) || 0));
                    renderPlaylist();
                    log(`ğŸ“š Restored ${playlist.length} songs from history`, 'success');

                    // æ¢å¤ UI æ˜¾ç¤ºä½†ä¸è‡ªåŠ¨æ’­æ”¾
                    const currentTrack = playlist[curIdx];
                    if (currentTrack) {
                        el.title.textContent = currentTrack.name || '';
                        el.artist.textContent = 'Ready to play';
                        const cover = currentTrack.songData?.al?.picUrl;
                        if (cover) {
                            el.img.src = cover + '?param=500y500';
                            el.img.style.opacity = 1;
                            setTimeout(() => updateTheme(el.img), 200);
                        }
                        const items = el.plContainer.children;
                        if (items[curIdx]) items[curIdx].classList.add('active');
                    }
                }
            } catch (e) {
                console.warn('Failed to restore playlist:', e);
            }
        }

        // é¡µé¢å¸è½½æ—¶è‡ªåŠ¨ä¿å­˜ï¼ˆåˆ·æ–°/å…³é—­ï¼‰
        window.addEventListener('beforeunload', saveCurrentPlaylist);

        // é¡µé¢è½½å…¥æ—¶å°è¯•æ¢å¤
        restoreSavedPlaylist();
        
    </script>
</body>
</html>
