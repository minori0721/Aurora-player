<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aurora Player</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.4.0/color-thief.min.js"></script>

    <style>
        :root {
            --bg-1: #e0c3fc; --bg-2: #8ec5fc;
            --text-main: #2c3e50; --text-sub: rgba(44, 62, 80, 0.6);
            --glass: rgba(255, 255, 255, 0.4);
            --glass-strong: rgba(255, 255, 255, 0.95);
            --border: rgba(255, 255, 255, 0.6);
            --accent: #2980b9;
        }

        body {
            margin: 0; height: 100vh;
            background-color: #f5f7fa;
            background-image: 
                radial-gradient(circle at 10% 20%, var(--bg-1) 0%, transparent 50%),
                radial-gradient(circle at 90% 80%, var(--bg-2) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, #fff 0%, transparent 60%);
            background-size: 150% 150%;
            animation: bgMove 15s infinite alternate;
            color: var(--text-main); font-family: 'Segoe UI', sans-serif;
            overflow: hidden; display: flex; justify-content: center; align-items: center;
            transition: --bg-1 1s, --bg-2 1s;
        }
        @keyframes bgMove { 0% { background-position: 0% 0%; } 100% { background-position: 100% 100%; } }

        #visual-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; pointer-events: none; }

        .top-bar { position: absolute; top: 20px; left: 20px; right: 20px; display: flex; justify-content: space-between; z-index: 100; }
        .tool-group { display: flex; gap: 10px; }
        .glass-btn {
            background: var(--glass); backdrop-filter: blur(10px); border: 1px solid var(--border);
            padding: 8px 15px; border-radius: 20px; cursor: pointer; font-size: 0.9rem; color: var(--text-main);
            display: flex; align-items: center; gap: 5px; transition: 0.2s; outline: none; white-space: nowrap;
        }
        .glass-btn:hover { background: #fff; transform: translateY(-2px); }

        /* é€šç”¨é¢æ¿æ ·å¼ */
        .panel-float {
            position: absolute; top: 70px; right: 20px; background: var(--glass-strong); padding: 20px; border-radius: 15px;
            border: 1px solid var(--border); width: 320px; 
            transform: translateX(120%); transition: transform 0.3s cubic-bezier(0.19, 1, 0.22, 1);
            z-index: 90; box-shadow: 0 10px 30px rgba(0,0,0,0.1); display: flex; flex-direction: column; gap: 12px;
        }
        .panel-float.show { transform: translateX(0); }
        
        .panel-row { display: flex; align-items: center; justify-content: space-between; font-size: 0.9rem; }
        .panel-input { width: 80px; border: 1px solid #ccc; border-radius: 5px; padding: 4px; text-align: center; font-family: monospace; }
        .panel-title { margin: 0; border-bottom: 1px solid rgba(0,0,0,0.1); padding-bottom: 10px; font-size: 1rem; font-weight: bold; position: relative; }
        
        /* é¢æ¿å…³é—­æŒ‰é’® */
        .panel-close {
            position: absolute; right: 0; top: 50%; transform: translateY(-50%);
            background: none; border: none; font-size: 1.5rem; color: var(--text-sub);
            cursor: pointer; padding: 0 5px; line-height: 1; display: none;
        }
        .panel-close:hover { color: var(--text-main); }

        /* åˆ†æé¢æ¿ç‰¹åˆ«æ ·å¼ */
        #analyze-panel { right: 350px; width: 300px; } /* æ”¾åœ¨å¾ªç¯é¢æ¿å·¦è¾¹ */
        #analyze-panel:not(.show) { transform: translateX(calc(100% + 370px)); } /* ç¡®ä¿èƒ½å®Œå…¨æ»‘å‡ºå±å¹• */
        .analyze-btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 5px; }
        .big-btn { width: 100%; justify-content: center; background: var(--accent); color: white; border: none; }
        .big-btn:hover { background: #1a5276; }

        .main-container { width: 85vw; height: 80vh; display: grid; grid-template-columns: 450px 1fr; gap: 80px; position: relative; z-index: 10; }
        .left-panel { display: flex; flex-direction: column; justify-content: center; position: relative; }
        .cover-wrapper { width: 100%; padding-bottom: 100%; position: relative; margin-bottom: 40px; filter: drop-shadow(0 20px 30px rgba(0,0,0,0.1)); }
        .default-disc {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 50%;
            background: conic-gradient(from 0deg, #e0e0e0, #ffffff, #e0e0e0, #d0d0d0, #ffffff, #e0e0e0);
            box-shadow: inset 0 0 0 5px rgba(255,255,255,0.8); display: flex; justify-content: center; align-items: center;
            animation: spin 10s linear infinite paused;
        }
        .default-disc::after { content:''; width:20%; height:20%; background:#f5f7fa; border-radius:50%; border:5px solid rgba(255,255,255,0.5); }
        .playing .default-disc { animation-play-state: running; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .album-img { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; border-radius: 20px; opacity: 0; transition: opacity 0.5s; }
        
        .progress-section { margin-top: auto; }
        .time-display { font-size: 0.9rem; color: var(--text-sub); margin-bottom: 12px; font-weight: 500; display: flex; justify-content: space-between;}
        .progress-bar-bg { width: 100%; height: 8px; background: rgba(0,0,0,0.05); border-radius: 4px; position: relative; cursor: pointer; transition: height 0.2s; overflow: visible;}
        .progress-bar-bg:hover { height: 12px; }
        .progress-line { position: absolute; top: 0; left: 0; width: 0%; height: 100%; background: var(--text-main); border-radius: 4px; }
        .buffer-line { position: absolute; top: 0; left: 0; width: 0%; height: 100%; background: rgba(255,255,255,0.6); border-radius: 4px; transition: width 0.2s; }
        
        .loop-marker { 
            position: absolute; top: -6px; width: 2px; height: 20px; background: #e74c3c; 
            z-index: 20; pointer-events: none; display: none; box-shadow: 0 0 5px rgba(231, 76, 60, 0.5);
        }
        .loop-marker::after { content: attr(data-label); position: absolute; top: -15px; left: -50%; color: #e74c3c; font-size: 10px; font-weight: bold; }

        .right-panel { display: flex; flex-direction: column; justify-content: center; position: relative; }
        .track-header { margin-bottom: 20px; }
        .track-title { font-size: 3rem; font-weight: 800; margin: 0 0 10px 0; line-height: 1.1; }
        .track-artist { font-size: 1.2rem; color: var(--text-sub); font-weight: 500; }
        
        .lyrics-box { 
            height: 350px; overflow: hidden; margin-bottom: 30px; position: relative; 
            padding-left: 20px;
            mask-image: linear-gradient(to bottom, transparent, black 15%, black 85%, transparent); 
            -webkit-mask-image: linear-gradient(to bottom, transparent, black 15%, black 85%, transparent); 
        }
        .lyrics-scroll { transition: transform 0.3s ease-out; width: 100%; text-align: left; }
        .lyric-line { font-size: 1.1rem; color: var(--text-sub); margin: 14px 0; cursor: pointer; opacity: 0.6; transition: 0.2s; line-height: 1.4; }
        .lyric-line.active { color: var(--text-main); font-size: 1.4rem; font-weight: 800; opacity: 1; transform-origin: left center; }

        .controls-row { display: flex; align-items: center; justify-content: flex-start; gap: 25px; padding-top: 20px; }
        .btn { background: var(--glass); backdrop-filter: blur(10px); border: 1px solid var(--border); color: var(--text-main); cursor: pointer; width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: 0.2s; position: relative; }
        .btn:hover { background: #fff; transform: translateY(-3px); }
        .btn svg { width: 20px; height: 20px; fill: currentColor; }
        .btn-play { width: 70px; height: 70px; background: var(--text-main); color: #fff; }
        .btn-play:hover { background: #000; }

        .playlist-sidebar { position: fixed; right: 0; top: 0; bottom: 0; width: 320px; background: var(--glass-strong); backdrop-filter: blur(30px); box-shadow: -10px 0 40px rgba(0,0,0,0.05); transform: translateX(100%); transition: transform 0.4s; z-index: 95; padding: 80px 30px 30px 30px; overflow-y: auto; }
        .playlist-sidebar.show { transform: translateX(0); }
        .pl-item { padding: 12px; border-radius: 8px; cursor: pointer; font-size: 0.95rem; color: var(--text-sub); margin-bottom: 5px; display: flex; align-items: center; }
        .pl-item:hover { background: rgba(0,0,0,0.05); }
        .pl-item.active { background: #fff; color: var(--text-main); font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.05); }

        .drag-mask { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.9); z-index: 999; display: flex; flex-direction: column; justify-content: center; align-items: center; opacity: 0; pointer-events: none; transition: 0.3s; }
        body.drag-on .drag-mask { opacity: 1; pointer-events: all; }
        .loading-tip { position: absolute; bottom: 20px; font-size: 0.8rem; color: #2980b9; display: none; font-weight: bold; }
        .tag-source { font-size: 0.7rem; padding: 2px 6px; border-radius: 4px; background: rgba(0,0,0,0.1); margin-left: 10px; vertical-align: middle;}
        .tag-quality { font-size: 0.65rem; padding: 2px 6px; border-radius: 4px; background: linear-gradient(135deg, #3498db, #2980b9); color: white; margin-left: 8px; vertical-align: middle; font-weight: 600; letter-spacing: 0.5px; text-transform: uppercase; }

        #debug-console {
            position: fixed; top: 70px; left: 20px; width: 350px; max-height: 200px;
            background: rgba(0,0,0,0.85); color: #0f0; font-family: monospace; font-size: 11px;
            overflow-y: auto; z-index: 9999; padding: 10px; border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); pointer-events: all;
            display: none; border: 1px solid rgba(255,255,255,0.2);
        }
        .log-warn { color: yellow; } .log-err { color: #ff5555; font-weight: bold; } .log-suc { color: #55ff55; font-weight: bold; }

        .vol-container { position: relative; display: flex; align-items: center; justify-content: center; }
        .vol-popup {
            position: absolute; bottom: 65px; left: 50%; transform: translateX(-50%);
            width: 40px; height: 120px;
            background: var(--glass-strong); backdrop-filter: blur(10px);
            border-radius: 20px; border: 1px solid var(--border);
            display: flex; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: all 0.3s cubic-bezier(0.19, 1, 0.22, 1);
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }
        .vol-popup.show { opacity: 1; pointer-events: all; bottom: 70px; }
        input[type=range].vol-range {
            writing-mode: vertical-lr; direction: rtl;
            width: 8px; height: 90px; background: rgba(0,0,0,0.1);
            cursor: pointer; accent-color: var(--text-main);
        }

        /* ç½‘æ˜“äº‘æœç´¢é¢æ¿ */
        .netease-panel {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5); z-index: 200;
            display: none; justify-content: center; align-items: center;
        }
        .netease-panel.show { display: flex; }
        .netease-content {
            background: var(--glass-strong); backdrop-filter: blur(30px);
            border-radius: 20px; padding: 25px; width: 90%; max-width: 500px;
            max-height: 80vh; display: flex; flex-direction: column;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        .netease-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid rgba(0,0,0,0.1);
        }
        .netease-header h3 { margin: 0; font-size: 1.1rem; }
        .netease-close {
            background: none; border: none; font-size: 1.5rem;
            cursor: pointer; color: var(--text-sub); padding: 0 5px;
        }
        .netease-close:hover { color: var(--text-main); }
        .netease-tabs { display: flex; gap: 10px; margin-bottom: 15px; }
        .netease-tab {
            flex: 1; padding: 10px; border: none; border-radius: 10px;
            background: rgba(0,0,0,0.05); cursor: pointer; font-size: 0.9rem;
            transition: 0.2s;
        }
        .netease-tab.active { background: var(--accent); color: white; }
        .netease-tab:hover:not(.active) { background: rgba(0,0,0,0.1); }
        .netease-tab-content {
            flex: 1; display: flex; flex-direction: column;
            overflow: hidden; min-height: 0;
        }
        .netease-search-box {
            display: flex; gap: 10px; margin-bottom: 15px;
        }
        .netease-input {
            flex: 1; padding: 12px 15px; border: 1px solid rgba(0,0,0,0.15);
            border-radius: 10px; font-size: 0.95rem; outline: none;
            background: rgba(255,255,255,0.8);
        }
        .netease-input:focus { border-color: var(--accent); }
        .netease-search-btn {
            padding: 12px 20px; border: none; border-radius: 10px;
            background: var(--accent); color: white; cursor: pointer;
            font-size: 0.9rem; white-space: nowrap;
        }
        .netease-search-btn:hover { background: #1a5276; }
        .netease-search-btn:disabled { background: #ccc; cursor: not-allowed; }
        .netease-results {
            flex: 1; overflow-y: auto; min-height: 0; max-height: 45vh;
            border: 1px solid rgba(0,0,0,0.1); border-radius: 10px;
            background: rgba(255,255,255,0.5);
        }
        .netease-item {
            padding: 12px 15px; cursor: pointer; border-bottom: 1px solid rgba(0,0,0,0.05);
            display: flex; align-items: center; gap: 12px; transition: 0.15s;
        }
        .netease-item:hover { background: rgba(0,0,0,0.05); }
        .netease-item:last-child { border-bottom: none; }
        .netease-item-cover {
            width: 45px; height: 45px; border-radius: 6px;
            object-fit: cover; background: #eee; flex-shrink: 0;
        }
        .netease-item-info { flex: 1; min-width: 0; }
        .netease-item-name {
            font-weight: 600; font-size: 0.95rem; color: var(--text-main);
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .netease-item-artist {
            font-size: 0.8rem; color: var(--text-sub); margin-top: 3px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .netease-item-duration {
            font-size: 0.75rem; color: var(--text-sub); flex-shrink: 0;
        }
        .netease-item-play {
            width: 32px; height: 32px; border-radius: 50%;
            background: var(--accent); color: white; border: none;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            flex-shrink: 0; opacity: 0; transition: 0.15s;
        }
        .netease-item:hover .netease-item-play { opacity: 1; }
        .netease-item-play:hover { transform: scale(1.1); }
        .netease-loading, .netease-empty {
            text-align: center; padding: 40px; color: var(--text-sub);
        }
        .netease-playlist-info {
            display: flex; gap: 15px; padding: 15px;
            background: rgba(0,0,0,0.03); border-radius: 10px; margin-bottom: 15px;
        }
        .netease-playlist-cover {
            width: 80px; height: 80px; border-radius: 10px; object-fit: cover; background: #eee;
        }
        .netease-playlist-meta { flex: 1; }
        .netease-playlist-name { font-weight: bold; font-size: 1rem; margin-bottom: 5px; }
        .netease-playlist-desc { font-size: 0.8rem; color: var(--text-sub); }
        .netease-import-btn {
            width: 100%; padding: 12px; border: none; border-radius: 10px;
            background: #27ae60; color: white; cursor: pointer;
            font-size: 0.95rem; margin-top: 10px;
        }
        .netease-import-btn:hover { background: #219a52; }
        .netease-import-btn:disabled { background: #ccc; }
        
        /* ç™»å½•ç›¸å…³ */
        .netease-user-bar {
            display: flex; align-items: center; gap: 10px;
            padding: 10px 15px; background: rgba(0,0,0,0.03);
            border-radius: 10px; margin-bottom: 15px;
        }
        .netease-avatar {
            width: 40px; height: 40px; border-radius: 50%;
            object-fit: cover; background: #eee;
        }
        .netease-user-info { flex: 1; min-width: 0; }
        .netease-nickname { font-weight: 600; font-size: 0.95rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .netease-user-type { 
            display: inline-block; font-size: 0.7rem; padding: 2px 6px; 
            border-radius: 4px; margin-top: 2px;
        }
        .netease-user-type.vip { background: linear-gradient(135deg, #f39c12, #e74c3c); color: white; }
        .netease-user-type.svip { background: linear-gradient(135deg, #9b59b6, #8e44ad); color: white; }
        .netease-user-type.music-pack { background: linear-gradient(135deg, #1abc9c, #16a085); color: white; }
        .netease-user-type.normal { background: #95a5a6; color: white; }
        .netease-quality-bar {
            display: flex; align-items: center; gap: 8px;
            padding: 8px 12px; background: rgba(0,0,0,0.03);
            border-radius: 8px; margin-bottom: 15px; font-size: 0.85rem;
        }
        .netease-quality-bar label { color: var(--text-sub); white-space: nowrap; }
        .netease-quality-select {
            flex: 1; padding: 6px 10px; border: 1px solid rgba(0,0,0,0.1);
            border-radius: 6px; background: white; font-size: 0.85rem; cursor: pointer;
        }
        .netease-logout-btn {
            padding: 6px 12px; border: none; border-radius: 6px;
            background: #e74c3c; color: white; cursor: pointer; font-size: 0.8rem;
        }
        .netease-logout-btn:hover { background: #c0392b; }
        .netease-login-btn {
            width: 100%; padding: 12px; border: none; border-radius: 10px;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white; cursor: pointer; font-size: 0.95rem;
            margin-bottom: 15px; transition: 0.2s;
        }
        .netease-login-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(231,76,60,0.3); }
        .qrcode-container {
            text-align: center; padding: 20px;
        }
        .qrcode-container img {
            width: 180px; height: 180px; border-radius: 10px;
            border: 2px solid #eee;
        }
        .qrcode-tip {
            margin-top: 15px; font-size: 0.85rem; color: var(--text-sub);
        }
        .qrcode-status {
            margin-top: 10px; font-size: 0.9rem; font-weight: 600;
        }
        .qrcode-status.waiting { color: #f39c12; }
        .qrcode-status.scanned { color: #3498db; }
        .qrcode-status.success { color: #27ae60; }
        .qrcode-status.expired { color: #e74c3c; }
        .my-playlists { margin-top: 10px; }
        .my-playlists-title {
            font-size: 0.85rem; color: var(--text-sub);
            margin-bottom: 8px; padding-left: 5px;
        }

        /* é«˜çº§èœå• */
        .advanced-menu-container { position: relative; }
        .advanced-menu {
            position: absolute; top: 45px; right: 0;
            background: var(--glass-strong); backdrop-filter: blur(20px);
            border-radius: 12px; border: 1px solid var(--border);
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            min-width: 140px; padding: 8px 0;
            opacity: 0; pointer-events: none; transform: translateY(-10px);
            transition: all 0.2s ease;
            z-index: 9999;
        }
        .advanced-menu.show { opacity: 1; pointer-events: all; transform: translateY(0); }
        .advanced-menu-item {
            display: block; width: 100%; padding: 10px 15px;
            background: none; border: none; text-align: left;
            font-size: 0.85rem; color: var(--text-main); cursor: pointer;
            transition: background 0.15s;
        }
        .advanced-menu-item:hover { background: rgba(0,0,0,0.05); }
        .advanced-menu-item:active { background: rgba(0,0,0,0.1); }
        
        /* æ¡Œé¢ç«¯éšè—é«˜çº§æŒ‰é’® */
        .mobile-only { display: none; }
        .desktop-only { display: flex; }

        /* ========== ç§»åŠ¨ç«¯å“åº”å¼ ========== */
        @media screen and (max-width: 900px) {
            html, body { 
                overflow-x: hidden; 
                overflow-y: auto;
                height: auto; 
                min-height: 100vh;
                max-width: 100vw;
            }
            
            .main-container {
                width: 100%; height: auto;
                grid-template-columns: 1fr; gap: 15px;
                padding: 70px 15px 100px 15px;
                box-sizing: border-box;
            }
            
            .left-panel { order: 1; }
            .right-panel { order: 2; }
            
            .cover-wrapper { 
                width: 55vw; max-width: 250px; padding-bottom: 55vw; 
                margin: 0 auto 15px auto; 
            }
            
            .progress-section { padding: 0; }
            
            .track-header { text-align: center; padding: 0 10px; }
            .track-title { font-size: 1.5rem; word-break: break-word; }
            .track-artist { font-size: 0.95rem; }
            
            .lyrics-box { 
                height: 180px; padding: 0 10px;
                mask-image: linear-gradient(to bottom, transparent, black 10%, black 90%, transparent);
                -webkit-mask-image: linear-gradient(to bottom, transparent, black 10%, black 90%, transparent);
            }
            .lyric-line { font-size: 0.9rem; margin: 8px 0; text-align: center; }
            .lyric-line.active { font-size: 1.1rem; }
            .lyrics-scroll { text-align: center; }
            
            .controls-row { justify-content: center; gap: 12px; padding: 10px 0; }
            .btn { width: 42px; height: 42px; }
            .btn svg { width: 16px; height: 16px; }
            .btn-play { width: 56px; height: 56px; }
            
            /* é¡¶éƒ¨å·¥å…·æ  - ç§»åŠ¨ç«¯é‡æ–°å¸ƒå±€ */
            .top-bar { 
                top: 8px; left: 8px; right: 8px;
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
                gap: 5px;
                overflow: visible;
            }
            .tool-group { 
                gap: 5px; 
                flex-wrap: nowrap;
                overflow: visible;
            }
            .tool-group::-webkit-scrollbar { display: none; }
            .glass-btn { 
                padding: 5px 8px; font-size: 0.7rem; 
                border-radius: 12px;
                flex-shrink: 0;
            }
            /* ç§»åŠ¨ç«¯éšè—éƒ¨åˆ†æŒ‰é’®æ–‡å­—ï¼Œåªæ˜¾ç¤ºå›¾æ ‡ */
            .glass-btn .btn-text { display: none; }
            
            /* é¢æ¿ */
            .panel-float { 
                position: fixed;
                top: auto; bottom: 0; left: 0; right: 0;
                width: 100%; max-width: 100%;
                border-radius: 20px 20px 0 0;
                max-height: 70vh; overflow-y: auto;
                transform: translateY(100%);
                box-sizing: border-box;
            }
            .panel-float.show { transform: translateY(0); }
            
            /* ç§»åŠ¨ç«¯æ˜¾ç¤ºå…³é—­æŒ‰é’® */
            .panel-close { display: block; }
            
            #analyze-panel { 
                position: fixed;
                top: auto; bottom: 0; left: 0; right: 0;
                width: 100%;
            }
            #analyze-panel:not(.show) { transform: translateY(100%); }
            
            .playlist-sidebar { 
                width: 100%; max-width: 100%; 
                padding: 60px 15px 15px 15px; 
                box-sizing: border-box;
            }
            
            #debug-console { 
                position: fixed;
                width: calc(100% - 20px); left: 10px; right: 10px;
                top: auto; bottom: 10px; max-height: 120px;
            }
            
            .vol-popup { bottom: 50px; }
            .vol-popup.show { bottom: 55px; }
            
            /* æ‹–æ‹½é®ç½© */
            .drag-mask h1 { font-size: 1.5rem; }
            .drag-mask p { font-size: 0.9rem; }
            
            /* ç§»åŠ¨ç«¯ï¼šæ˜¾ç¤ºé«˜çº§æŒ‰é’®ï¼Œéšè—åŸæ¥çš„ä¸‰ä¸ª */
            .mobile-only { display: block; }
            .desktop-only { display: none !important; }
            .advanced-menu { right: 0; left: auto; }
        }
        
        /* è¶…å°å±å¹• */
        @media screen and (max-width: 400px) {
            .main-container { padding: 60px 10px 90px 10px; }
            .cover-wrapper { width: 60vw; padding-bottom: 60vw; max-width: 220px; }
            .track-title { font-size: 1.3rem; }
            .glass-btn { padding: 4px 6px; font-size: 0.65rem; }
            .controls-row { gap: 10px; }
            .btn { width: 38px; height: 38px; }
            .btn-play { width: 50px; height: 50px; }
            .lyrics-box { height: 150px; }
        }
    </style>
</head>
<body id="body">
    
    <div id="debug-console"><div>> Debugger Ready.</div></div>
    <canvas id="visual-canvas"></canvas>
    <div class="drag-mask"><h1>æŠ•å–‚éŸ³ä¹</h1><p>MP3 / FLAC / OGG / SLI</p></div>

    <!-- ç½‘æ˜“äº‘æœç´¢é¢æ¿ -->
    <div class="netease-panel" id="netease-panel">
        <div class="netease-content">
            <div class="netease-header">
                <h3>ğŸµ ç½‘æ˜“äº‘éŸ³ä¹</h3>
                <button class="netease-close" onclick="document.getElementById('netease-panel').classList.remove('show')">&times;</button>
            </div>
            <!-- ç”¨æˆ·çŠ¶æ€æ  -->
            <div id="netease-user-bar" class="netease-user-bar" style="display:none">
                <img class="netease-avatar" id="netease-avatar" src="">
                <div class="netease-user-info">
                    <div class="netease-nickname" id="netease-nickname">ç”¨æˆ·å</div>
                    <small class="netease-user-id" id="netease-user-id">ID: </small>
                    <span class="netease-user-type normal" id="netease-user-type">æ™®é€šç”¨æˆ·</span>
                </div>
                <button class="netease-logout-btn" onclick="neteaseLogout()">é€€å‡º</button>
            </div>
            <!-- éŸ³è´¨é€‰æ‹© -->
            <div id="netease-quality-bar" class="netease-quality-bar" style="display:none">
                <label>ğŸ§ éŸ³è´¨:</label>
                <select id="netease-quality-select" class="netease-quality-select">
                    <option value="standard">æ ‡å‡† (128kbps)</option>
                    <option value="higher">è¾ƒé«˜ (192kbps)</option>
                    <option value="exhigh">æé«˜ (320kbps)</option>
                    <option value="lossless">æ— æŸ (FLAC)</option>
                    <option value="hires">Hi-Res</option>
                </select>
            </div>
            <button id="netease-login-btn" class="netease-login-btn" onclick="showQRLogin()">ğŸ” æ‰«ç ç™»å½•ç½‘æ˜“äº‘è´¦å·</button>
            
            <div class="netease-tabs">
                <button class="netease-tab active" data-tab="search">ğŸ” æœç´¢æ­Œæ›²</button>
                <button class="netease-tab" data-tab="playlist">ğŸ“‹ å¯¼å…¥æ­Œå•</button>
                <button class="netease-tab" data-tab="mylist">â¤ï¸ æˆ‘çš„æ­Œå•</button>
            </div>
            <!-- æœç´¢æ­Œæ›² -->
            <div class="netease-tab-content" id="tab-search">
                <div class="netease-search-box">
                    <input type="text" class="netease-input" id="netease-search-input" placeholder="è¾“å…¥æ­Œåã€æ­Œæ‰‹...">
                    <button class="netease-search-btn" id="netease-search-btn">æœç´¢</button>
                </div>
                <div class="netease-results" id="netease-search-results">
                    <div class="netease-empty">è¾“å…¥å…³é”®è¯æœç´¢æ­Œæ›²</div>
                </div>
            </div>
            <!-- å¯¼å…¥æ­Œå• -->
            <div class="netease-tab-content" id="tab-playlist" style="display:none">
                <div class="netease-search-box">
                    <input type="text" class="netease-input" id="netease-playlist-input" placeholder="ç²˜è´´æ­Œå•é“¾æ¥æˆ–ID...">
                    <button class="netease-search-btn" id="netease-playlist-btn">è·å–</button>
                </div>
                <div id="netease-playlist-preview"></div>
                <div class="netease-results" id="netease-playlist-results">
                    <div class="netease-empty">æ”¯æŒæ ¼å¼ï¼š<br>https://music.163.com/playlist?id=xxx<br>æˆ–ç›´æ¥è¾“å…¥æ­Œå•ID</div>
                </div>
            </div>
            <!-- æˆ‘çš„æ­Œå• -->
            <div class="netease-tab-content" id="tab-mylist" style="display:none">
                <div id="mylist-content" class="netease-results" style="border:none;background:none">
                    <div class="netease-empty">è¯·å…ˆç™»å½•ç½‘æ˜“äº‘è´¦å·</div>
                </div>
            </div>
            <!-- äºŒç»´ç ç™»å½• -->
            <div class="netease-tab-content" id="tab-qrlogin" style="display:none">
                <div class="qrcode-container">
                    <div id="qrcode-img-wrap"><div class="netease-loading">ç”ŸæˆäºŒç»´ç ä¸­...</div></div>
                    <div class="qrcode-tip">è¯·ä½¿ç”¨ç½‘æ˜“äº‘éŸ³ä¹APPæ‰«æäºŒç»´ç ç™»å½•</div>
                    <div class="qrcode-status waiting" id="qrcode-status">ç­‰å¾…æ‰«æ...</div>
                    <button class="glass-btn" style="margin-top:15px" onclick="refreshQRCode()">ğŸ”„ åˆ·æ–°äºŒç»´ç </button>
                </div>
            </div>
        </div>
    </div>

    <div class="top-bar">
        <div class="tool-group">
            <button id="btn-import" class="glass-btn mobile-only" title="å¯¼å…¥éŸ³ä¹æ–‡ä»¶">ğŸ“‚ å¯¼å…¥</button>
            <input type="file" id="file-input" multiple accept="audio/*,.lrc,.sli" style="display:none">
            <button id="toggle-netease-panel" class="glass-btn" title="æœç´¢ç½‘æ˜“äº‘éŸ³ä¹">â˜ï¸ <span class="btn-text">äº‘éŸ³ä¹</span></button>
            <button id="toggle-netease" class="glass-btn desktop-only" title="è‡ªåŠ¨ä»ç½‘æ˜“äº‘æœç´¢æ­Œè¯">ğŸ“ <span class="btn-text">äº‘è¯</span></button>
            <select id="effect-select" class="glass-btn desktop-only">
                <option value="none">âœ¨ æ— ç‰¹æ•ˆ</option>
                <option value="snow">â„ï¸ å‡›å†¬é£é›ª</option>
                <option value="bars">ğŸ“Š å¾‹åŠ¨é¢‘è°±</option>
                <option value="waves">ğŸŒŠ æå…‰æ³¢æµª</option>
            </select>
            <button id="toggle-debug" class="glass-btn desktop-only">ğŸ Debug</button>
        </div>
        <div class="tool-group">
            <button id="toggle-analyze" class="glass-btn desktop-only">ğŸ” æ™ºèƒ½åˆ†æ</button>
            <button id="toggle-loop-panel" class="glass-btn desktop-only">ğŸ” å¾ªç¯è®¾å®š</button>
            <button id="toggle-list" class="glass-btn">ğŸ“œ <span class="btn-text">åˆ—è¡¨</span></button>
            <!-- ç§»åŠ¨ç«¯é«˜çº§èœå• -->
            <div class="advanced-menu-container mobile-only">
                <button id="toggle-advanced" class="glass-btn">âš™ï¸ é«˜çº§</button>
                <div class="advanced-menu" id="advanced-menu">
                    <button class="advanced-menu-item" data-action="debug">ğŸ Debug</button>
                    <button class="advanced-menu-item" data-action="analyze">ğŸ” æ™ºèƒ½åˆ†æ</button>
                    <button class="advanced-menu-item" data-action="loop">ğŸ” å¾ªç¯è®¾å®š</button>
                    <button class="advanced-menu-item" data-action="netease-lyrics">ğŸ“ äº‘è¯å¼€å…³</button>
                    <button class="advanced-menu-item" data-action="effects">âœ¨ è§†è§‰ç‰¹æ•ˆ</button>
                </div>
            </div>
        </div>
    </div>

    <div class="panel-float" id="analyze-panel">
        <h4 class="panel-title">Loop Analyzer (æ™ºèƒ½å¯¹é½åˆ†æ)<button class="panel-close" onclick="this.closest('.panel-float').classList.remove('show')">&times;</button></h4>
        <div style="font-size:0.8rem; color:#666; margin-bottom:10px;">
            ä¸çŸ¥é“åœ¨å“ªé‡Œè®¾ç½®å¾ªç¯ç‚¹ï¼Ÿè¯•è¯•æ™ºèƒ½åˆ†æï¼<br>
            1. ç²—ç•¥è®¾ç½® A/B ç‚¹ (å‰åè¯¯å·®<2s)<br>
            2. ç‚¹å‡»â€œå¼€å§‹åŒ¹é…â€ä¼šè‡ªåŠ¨å¯»æ‰¾æœ€ä½³æ¥ç¼å“¦ï¼
        </div>
        <div class="panel-row">
            <span>Rough Start (A)</span>
            <input type="number" id="ana-start" class="panel-input" step="0.1" placeholder="0.0">
        </div>
        <div class="panel-row">
            <span>Rough End (B)</span>
            <input type="number" id="ana-end" class="panel-input" step="0.1" placeholder="0.0">
        </div>
        
        <div class="analyze-btn-group">
            <button class="glass-btn" onclick="capturePoint('a')">ğŸ“ å®šä½ A</button>
            <button class="glass-btn" onclick="capturePoint('b')">ğŸ“ å®šä½ B</button>
        </div>
        <div class="analyze-btn-group">
            <button class="glass-btn" onclick="previewPoint('a')">ğŸ”Š è¯•å¬ A</button>
            <button class="glass-btn" onclick="previewPoint('b')">ğŸ”Š è¯•å¬ B</button>
        </div>
        
        <button class="glass-btn big-btn" onclick="runAnalysis()" style="margin-top:10px;">âœ¨ å¼€å§‹ç²¾ç¡®åŒ¹é…</button>
        <button class="glass-btn big-btn" onclick="exportSLI()" style="margin-top:8px; background:#27ae60;">ğŸ’¾ å¯¼å‡º .sli æ–‡ä»¶</button>
        <div id="ana-msg" style="font-size:0.75rem; text-align:center; min-height:1.2em; margin-top:5px;"></div>
    </div>

    <div class="loop-panel panel-float" id="loop-panel">
        <h4 class="panel-title">Loop Controller<button class="panel-close" onclick="this.closest('.panel-float').classList.remove('show')">&times;</button></h4>
        <div class="panel-row"><span>å¼€å¯å¾ªç¯</span><input type="checkbox" id="loop-enable"></div>
        <div class="panel-row" style="background:rgba(0,0,0,0.05); padding:5px; border-radius:5px;"><span title="ä¿®æ­£é‡‡æ ·ç‡">Base Rate (Hz)</span><input type="number" id="base-rate" class="panel-input" value="44100" step="100"></div>
        <div class="panel-row"><span>Start (A)</span><input type="number" id="loop-start" class="panel-input" step="0.001" value="0"></div>
        <div class="panel-row"><span>End (B)</span><input type="number" id="loop-end" class="panel-input" step="0.001" value="0"></div>
        <div style="display:flex; gap:10px; margin-top:5px;">
            <button class="glass-btn" style="flex:1; justify-content:center;" onclick="setLoopPoint('a')">Set A</button>
            <button class="glass-btn" style="flex:1; justify-content:center;" onclick="setLoopPoint('b')">Set B</button>
        </div>
        <div id="loop-msg" style="font-size:0.7rem; color:green; height:15px; text-align:right;"></div>
    </div>

    <div class="playlist-sidebar" id="playlist-sidebar"><h3 style="margin-top:0;">PLAYLIST</h3><div id="pl-container"></div></div>

    <div class="main-container">
        <div class="left-panel">
            <div class="cover-wrapper" id="cover-wrap">
                <div class="default-disc"></div>
                <img src="" class="album-img" id="album-img" crossorigin="anonymous">
                <div class="loading-tip" id="loading-tip">Decoding Audio...</div>
            </div>
            <div class="progress-section">
                <div class="time-display">
                    <span id="curr-time">00:00</span>
                    <span id="loop-status" style="color:#e74c3c; display:none; font-weight:bold; font-size:0.8rem">âˆ SEAMLESS</span>
                    <span id="total-time">00:00</span>
                </div>
                <div class="progress-bar-bg" id="prog-bg">
                    <div class="buffer-line" id="buffer-line"></div>
                    <div class="progress-line" id="prog-line"></div>
                    <div class="loop-marker" id="marker-a" data-label="A"></div>
                    <div class="loop-marker" id="marker-b" data-label="B"></div>
                </div>
            </div>
        </div>

        <div class="right-panel">
            <div class="track-header">
                <div class="track-title" id="track-title">Aurora Player</div>
                <div class="track-artist" id="track-artist">System Ready</div>
            </div>
            <div class="lyrics-box" id="lyrics-box">
                <div class="lyrics-scroll" id="lyrics-content"><div class="lyric-line active" style="margin-top: 100px;">Ready.</div></div>
            </div>
            <div class="controls-row">
                <button class="btn" id="mode-btn"><svg id="icon-list-loop" viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/></svg><svg id="icon-random" style="display:none" viewBox="0 0 24 24"><path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/></svg><svg id="icon-single" style="display:none" viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4zm-4-2V9h-1l-2 1v1h1.5v4H13z"/></svg></button>
                <button class="btn" id="prev-btn"><svg viewBox="0 0 24 24"><path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/></svg></button>
                <button class="btn btn-play" id="play-btn"><svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></button>
                <button class="btn" id="next-btn"><svg viewBox="0 0 24 24"><path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/></svg></button>
                <div class="vol-container">
                    <div class="vol-popup" id="vol-popup"><input type="range" class="vol-range" id="vol-range" min="0" max="1" step="0.01" value="1"></div>
                    <button class="btn" id="vol-btn" title="Volume"><svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg></button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const debugConsole = document.getElementById('debug-console');
        function log(msg, type='') {
            console.log(msg);
            const div = document.createElement('div');
            div.className = `log-item ${type==='error'?'log-err':(type==='success'?'log-suc':'')}`;
            div.textContent = `> ${msg}`;
            debugConsole.appendChild(div);
            debugConsole.scrollTop = debugConsole.scrollHeight;
        }

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let actx = new AudioContext();
        let audioBuffer = null, sourceNode = null, gainNode = actx.createGain(), analyser = actx.createAnalyser();
        gainNode.connect(analyser); analyser.connect(actx.destination); analyser.fftSize = 512;

        let playbackState = { startTime: 0, pauseTime: 0, isPlaying: false, duration: 0 };
        let playlist = [], curIdx = -1, playMode = 0;
        let lyrics = [], isSyncedLyrics = true;
        let neteaseSearchEnabled = false; // ç½‘æ˜“äº‘æ­Œè¯æœç´¢å¼€å…³ï¼Œé»˜è®¤å…³é—­
        let loopState = { active: false, start: 0, end: 0 };
        let particles = [];
        let currentAbortController = null; // ç”¨äºå–æ¶ˆä¹‹å‰çš„ç½‘ç»œè¯·æ±‚
        let currentPlaylistSongs = []; // å½“å‰æ­Œå•çš„æ‰€æœ‰æ­Œæ›²
        let currentPage = 0; // å½“å‰é¡µç 
        const SONGS_PER_PAGE = 50; // æ¯é¡µæ˜¾ç¤ºçš„æ­Œæ›²æ•°é‡

        const el = {
            img: document.getElementById('album-img'), coverWrap: document.getElementById('cover-wrap'),
            title: document.getElementById('track-title'), artist: document.getElementById('track-artist'),
            lyricBox: document.getElementById('lyrics-content'),
            progBg: document.getElementById('prog-bg'), progLine: document.getElementById('prog-line'), bufferLine: document.getElementById('buffer-line'),
            currTime: document.getElementById('curr-time'), totalTime: document.getElementById('total-time'),
            plContainer: document.getElementById('pl-container'), playBtn: document.getElementById('play-btn'),
            effectSel: document.getElementById('effect-select'), canvas: document.getElementById('visual-canvas'),
            loopPanel: document.getElementById('loop-panel'), loopStart: document.getElementById('loop-start'), loopEnd: document.getElementById('loop-end'), loopEnable: document.getElementById('loop-enable'),
            baseRateInput: document.getElementById('base-rate'), loopMsg: document.getElementById('loop-msg'),
            markerA: document.getElementById('marker-a'), markerB: document.getElementById('marker-b'),
            modeBtn: document.getElementById('mode-btn'), loadTip: document.getElementById('loading-tip'),
            volBtn: document.getElementById('vol-btn'), volPopup: document.getElementById('vol-popup'), volRange: document.getElementById('vol-range'),
            // Analyze UI
            anaPanel: document.getElementById('analyze-panel'), anaStart: document.getElementById('ana-start'), anaEnd: document.getElementById('ana-end'), anaMsg: document.getElementById('ana-msg')
        };
        const colorThief = new ColorThief();
        const canvasCtx = el.canvas.getContext('2d');

        // --- æ ¸å¿ƒï¼šè‡ªåŠ¨æ³¢å½¢åŒ¹é…ç®—æ³• (å‡çº§ç‰ˆï¼šMSE + è¿‡é›¶ç‚¹ä¼˜åŒ–) ---
        function runAnalysis() {
            if (!audioBuffer) { el.anaMsg.textContent = "Please load audio first!"; return; }
            
            const roughA = parseFloat(el.anaStart.value);
            const roughB = parseFloat(el.anaEnd.value);
            if (isNaN(roughA) || isNaN(roughB) || roughB <= roughA) {
                el.anaMsg.textContent = "Invalid range (A must < B)"; return;
            }

            el.anaMsg.textContent = "Analyzing... (This may take a moment)";
            el.anaMsg.style.color = "var(--accent)";

            requestAnimationFrame(() => {
                setTimeout(() => {
                    try {
                        // å°è¯•ä¸‰æ¬¡ï¼šåŸå§‹Bç‚¹ã€B+0.1sã€B-0.1s
                        const attempts = [
                            { bOffset: 0, label: "åŸå§‹" },
                            { bOffset: 0.1, label: "B+0.1s" },
                            { bOffset: -0.1, label: "B-0.1s" }
                        ];
                        
                        let bestResult = null;
                        let bestConfidence = 0;
                        let bestLabel = "";
                        
                        for (const attempt of attempts) {
                            const adjustedB = roughB + attempt.bOffset;
                            if (adjustedB <= roughA) continue; // è·³è¿‡æ— æ•ˆèŒƒå›´
                            
                            const result = findBestMatch(audioBuffer, roughA, adjustedB);
                            if (result) {
                                const confidence = Math.max(0, (1 - result.diff) * 100);
                                log(`å°è¯• ${attempt.label}: ç½®ä¿¡åº¦ ${confidence.toFixed(1)}%`);
                                
                                // å¦‚æœç½®ä¿¡åº¦ >= 99%ï¼Œç«‹å³é‡‡ç”¨
                                if (confidence >= 99) {
                                    bestResult = result;
                                    bestConfidence = confidence;
                                    bestLabel = attempt.label;
                                    break; // æ‰¾åˆ°æ»¡æ„ç»“æœï¼Œåœæ­¢å°è¯•
                                }
                                
                                // è®°å½•æœ€ä½³ç»“æœ
                                if (confidence > bestConfidence) {
                                    bestResult = result;
                                    bestConfidence = confidence;
                                    bestLabel = attempt.label;
                                }
                            }
                        }
                        
                        // åˆ¤æ–­æœ€ç»ˆç»“æœ
                        if (bestResult && bestConfidence >= 99) {
                            applyLoop(bestResult.start, bestResult.end);
                            el.anaMsg.textContent = `âœ¨ æ¬¸å˜¿å˜¿ æ‰¾åˆ°äº†! [${bestLabel}] (ç½®ä¿¡åº¦: ${bestConfidence.toFixed(1)}%)`;
                            el.anaMsg.style.color = "#27ae60";
                            log(`Auto-Loop: ${bestResult.start.toFixed(4)}s -> ${bestResult.end.toFixed(4)}s`, 'success');
                        } else if (bestResult) {
                            el.anaMsg.textContent = `âŒ å¥½åƒä¸å¯¹å“¦ï¼Ÿ (æœ€é«˜: ${bestConfidence.toFixed(1)}% < 99%). è¯·å†è°ƒæ•´ A/B ç‚¹è¯•è¯•å§ï¼`;
                            el.anaMsg.style.color = "#e74c3c";
                            log(`All attempts failed. Best: ${bestConfidence.toFixed(1)}%`, 'error');
                        } else {
                            el.anaMsg.textContent = "Could not find a seamless match nearby.";
                            el.anaMsg.style.color = "#e74c3c";
                        }
                    } catch (e) {
                        el.anaMsg.textContent = "Error: " + e.message;
                        console.error(e);
                    }
                }, 50);
            });
        }

        /**
         * å¯»æ‰¾æœ€ä½³å¾ªç¯ç‚¹ (æ”¹è‰¯ç‰ˆ)
         * 1. ç²—ç•¥æœç´¢ï¼šä½¿ç”¨å‡æ–¹å·® (MSE) æ‰¾åˆ°æ³¢å½¢æœ€ç›¸ä¼¼çš„ä½ç½®
         * 2. ç²¾ç»†è°ƒæ•´ï¼šå¯»æ‰¾æœ€è¿‘çš„"è¿‡é›¶ç‚¹ (Zero Crossing)"ï¼Œæ¶ˆé™¤çˆ†éŸ³
         */
        function findBestMatch(buffer, timeA, timeB) {
            const chan0 = buffer.getChannelData(0); 
            // å¦‚æœæ˜¯åŒå£°é“ï¼Œå–ä¸¤ä¸ªå£°é“å¹³å‡å€¼è¿›è¡Œåˆ†æï¼Œæ•ˆæœæ›´å‡†
            let data = chan0;
            if (buffer.numberOfChannels > 1) {
                const chan1 = buffer.getChannelData(1);
                data = new Float32Array(chan0.length);
                for(let i=0; i<chan0.length; i++) data[i] = (chan0[i] + chan1[i]) / 2;
            }

            const sr = buffer.sampleRate;
            
            // å‚æ•°è®¾å®š
            const searchRadius = 3.0; // æœç´¢åŠå¾„æ‰©å¤§åˆ° 3ç§’
            const windowSize = Math.floor(0.15 * sr); // åŒ¹é…çª—å£ 150ms (è¶³å¤Ÿè¯†åˆ«èŠ‚å¥)
            
            const centerB = Math.floor(timeB * sr);
            const centerA = Math.floor(timeA * sr);

            // 1. å®šä¹‰ B ç‚¹çš„ç‰¹å¾æ¨¡æ¿ (å– B ç‚¹ä¹‹å‰çš„ä¸€æ®µå£°éŸ³)
            const templateStart = centerB - windowSize;
            
            // è¾¹ç•Œæ£€æŸ¥
            if (templateStart < 0 || centerB >= data.length) throw new Error("End point out of bounds");
            
            // A ç‚¹æœç´¢èŒƒå›´
            const startIdx = Math.max(0, centerA - Math.floor(searchRadius * sr));
            const endIdx = Math.min(centerB - windowSize * 2, centerA + Math.floor(searchRadius * sr));

            // --- é˜¶æ®µ 1: ç²—ç•¥ MSE æ‰«æ (è·³æ­¥æ‰«æä»¥æå‡é€Ÿåº¦) ---
            let bestOffset = -1;
            let minDiff = Infinity;
            const step = 4; // ç²¾åº¦æ­¥é•¿

            for (let i = startIdx; i < endIdx; i += step) {
                let diff = 0;
                // ä¼˜åŒ–ï¼šåªå¯¹æ¯”éƒ¨åˆ†é‡‡æ ·ç‚¹ä¼°ç®—ç›¸ä¼¼åº¦ï¼Œæå¤§æå‡æ€§èƒ½
                for (let j = 0; j < windowSize; j += 10) { 
                    const delta = data[i + j] - data[templateStart + j];
                    diff += delta * delta;
                    // å¦‚æœå·®å¼‚å·²ç»å¤§äºå½“å‰æœ€å°å€¼ï¼Œæå‰æ”¾å¼ƒ (å‰ªæä¼˜åŒ–)
                    if (diff > minDiff) break;
                }
                
                if (diff < minDiff) {
                    minDiff = diff;
                    bestOffset = i;
                }
            }

            // --- é˜¶æ®µ 2: å±€éƒ¨ç²¾ç»†ä¼˜é€‰ (é€ç‚¹æ‰«æ) ---
            let fineBest = bestOffset;
            let fineMinDiff = Infinity;
            const fineRange = 200; // åœ¨ç²—ç•¥ç‚¹å‰å 200 é‡‡æ ·å†…ç²¾ç»†æ‰¾

            for (let i = bestOffset - fineRange; i <= bestOffset + fineRange; i++) {
                let diff = 0;
                for (let j = 0; j < windowSize; j += 2) { // æé«˜é‡‡æ ·å¯†åº¦
                    const delta = data[i + j] - data[templateStart + j];
                    diff += delta * delta;
                }
                if (diff < fineMinDiff) {
                    fineMinDiff = diff;
                    fineBest = i;
                }
            }

            // è®¡ç®— A ç‚¹ä½ç½®
            let refinedA = fineBest + windowSize; 

            // è®¡ç®—å½’ä¸€åŒ–å·®å¼‚åº¦
            const normalizedDiff = fineMinDiff / (windowSize / 2);
            
            return { 
                start: refinedA / sr, 
                end: timeB,
                diff: normalizedDiff 
            };
        }

        // è¾…åŠ©ï¼šæ•è·å½“å‰æ’­æ”¾æ—¶é—´
        function capturePoint(type) {
            const t = getCurrentTime();
            if(type === 'a') el.anaStart.value = t.toFixed(3);
            else el.anaEnd.value = t.toFixed(3);
        }
        
        // è¾…åŠ©ï¼šè¯•å¬
        function previewPoint(type) {
            const t = parseFloat(type==='a' ? el.anaStart.value : el.anaEnd.value);
            if (!isNaN(t)) {
                // æ’­æ”¾è¯¥ç‚¹å‰åå„3ç§’ (å…±6ç§’)
                startAudio(Math.max(0, t - 3));
                setTimeout(() => stopAudio(), 6000);
            }
        }

        // å¯¼å‡º .sli æ–‡ä»¶
        function exportSLI() {
            if (!loopState.active || loopState.start >= loopState.end) {
                el.anaMsg.textContent = "è¯·å…ˆè®¾ç½®æœ‰æ•ˆçš„å¾ªç¯åŒºé—´å‘¢ï¼";
                el.anaMsg.style.color = "red";
                return;
            }
            
            const rate = parseInt(el.baseRateInput.value) || 44100;
            // SLIæ ¼å¼: From = ç»“æŸé‡‡æ ·ç‚¹; To = å¼€å§‹é‡‡æ ·ç‚¹
            const fromSamples = Math.round(loopState.end * rate);
            const toSamples = Math.round(loopState.start * rate);
            
            const sliContent = `From = ${fromSamples};\nTo = ${toSamples};`;
            
            // åˆ›å»º Blob å¹¶ä¸‹è½½
            const blob = new Blob([sliContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            
            // ä½¿ç”¨å½“å‰æ›²ç›®åç§°
            const fileName = playlist[curIdx]?.name || 'loop';
            a.download = `${fileName}.sli`;
            
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            el.anaMsg.textContent = `å·²å¯¼å‡º: ${fileName}.sli`;
            el.anaMsg.style.color = "#27ae60";
            log(`SLI Exported: From=${fromSamples}, To=${toSamples}`, 'success');
        }

        async function parseFlacTagsNative(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const buffer = e.target.result;
                    const view = new DataView(buffer);
                    let offset = 0;
                    if (view.getUint32(0) !== 0x664C6143) { resolve(null); return; }
                    offset += 4;
                    log("FLAC Header Found.", 'success');
                    
                    let tags = {};
                    let loopLimit = 0;
                    
                    // éå†æ‰€æœ‰å…ƒæ•°æ®å—
                    while(offset < view.byteLength && loopLimit < 100) {
                        loopLimit++;
                        const header = view.getUint8(offset);
                        const isLast = (header & 0x80) !== 0;
                        const type = header & 0x7F;
                        const len = view.getUint32(offset) & 0x00FFFFFF; 
                        offset += 4;
                        
                        const blockEnd = offset + len;
                        
                        // Type 0: STREAMINFO (é‡‡æ ·ç‡ã€ä½æ·±åº¦ç­‰)
                        if (type === 0 && len >= 18) {
                            try {
                                // Bytes 10-13: é‡‡æ ·ç‡(20bits) + é€šé“æ•°(3bits) + ä½æ·±åº¦(5bits) + æ€»é‡‡æ ·æ•°é«˜4ä½
                                const byte10 = view.getUint8(offset + 10);
                                const byte11 = view.getUint8(offset + 11);
                                const byte12 = view.getUint8(offset + 12);
                                
                                // é‡‡æ ·ç‡: å‰20ä½ (byte10å…¨éƒ¨ + byte11å…¨éƒ¨ + byte12å‰4ä½)
                                const sampleRate = (byte10 << 12) | (byte11 << 4) | (byte12 >> 4);
                                // ä½æ·±åº¦: byte12å1ä½ + byte13å‰4ä½ (5ä½æ€»å…±), +1å¾—åˆ°å®é™…å€¼
                                const byte13 = view.getUint8(offset + 13);
                                const bitsPerSample = (((byte12 & 0x01) << 4) | (byte13 >> 4)) + 1;
                                
                                tags.sampleRate = sampleRate;
                                tags.bitsPerSample = bitsPerSample;
                                log(`FLAC: ${sampleRate}Hz ${bitsPerSample}bit`, 'success');
                            } catch(err) { log("STREAMINFO Parse Error: " + err, 'error'); }
                        }
                        
                        // Type 4: Vorbis Comment (æ ‡ç­¾ä¿¡æ¯)
                        if (type === 4) { 
                            try {
                                let pos = offset;
                                const vendorLen = view.getUint32(pos, true);
                                pos += 4 + vendorLen;
                                const commentListLen = view.getUint32(pos, true);
                                pos += 4;
                                const decoder = new TextDecoder("utf-8");
                                for(let i=0; i<commentListLen; i++) {
                                    const commentLen = view.getUint32(pos, true);
                                    pos += 4;
                                    const commentStr = decoder.decode(new Uint8Array(buffer, pos, commentLen));
                                    pos += commentLen;
                                    const splitIdx = commentStr.indexOf('=');
                                    if(splitIdx > -1) {
                                        const key = commentStr.substring(0, splitIdx).toUpperCase();
                                        const val = commentStr.substring(splitIdx + 1);
                                        if(key === 'LYRICS' || key === 'UNSYNCED LYRICS') tags.lyrics = val;
                                        else if (key === 'TITLE') tags.title = val;
                                        else if (key === 'ARTIST') tags.artist = val;
                                        else if (key === 'ALBUM') tags.album = val;
                                    }
                                }
                                log("FLAC Vorbis Comment parsed.", 'success');
                            } catch(err) { log("Vorbis Comment Parse Error: " + err, 'error'); }
                        }
                        
                        // Type 6: PICTURE (å°é¢å›¾ç‰‡)
                        if (type === 6) {
                            try {
                                let pos = offset;
                                // è·³è¿‡ picture type (4 bytes)
                                pos += 4;
                                // MIME type é•¿åº¦ (big endian)
                                const mimeLen = view.getUint32(pos);
                                pos += 4;
                                // MIME type å­—ç¬¦ä¸²
                                const mimeBytes = new Uint8Array(buffer, pos, mimeLen);
                                const mimeType = new TextDecoder("ascii").decode(mimeBytes);
                                pos += mimeLen;
                                // è·³è¿‡ description é•¿åº¦å’Œå†…å®¹
                                const descLen = view.getUint32(pos);
                                pos += 4 + descLen;
                                // è·³è¿‡ width, height, color depth, indexed colors (å„4å­—èŠ‚)
                                pos += 16;
                                // å›¾ç‰‡æ•°æ®é•¿åº¦
                                const picLen = view.getUint32(pos);
                                pos += 4;
                                // æ£€æŸ¥æ•°æ®æ˜¯å¦å®Œæ•´
                                if (pos + picLen <= buffer.byteLength) {
                                    const picData = new Uint8Array(buffer, pos, picLen);
                                    tags.picture = {
                                        format: mimeType,
                                        data: picData
                                    };
                                    log(`FLAC Picture found: ${mimeType}, ${picLen} bytes`, 'success');
                                } else {
                                    log(`FLAC Picture truncated, need ${pos + picLen} bytes, only have ${buffer.byteLength}`, 'error');
                                }
                            } catch(err) { log("FLAC Picture Parse Error: " + err, 'error'); }
                        }
                        
                        offset = blockEnd;
                        if (isLast) break;
                    }
                    
                    resolve(Object.keys(tags).length > 0 ? tags : null);
                };
                // å¢å¤§è¯»å–å¤§å°åˆ° 5MBï¼Œç¡®ä¿èƒ½è¯»å–åˆ°å¤§å°é¢å›¾ç‰‡
                reader.readAsArrayBuffer(file.slice(0, 5 * 1024 * 1024));
            });
        }

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => document.body.addEventListener(e, ev => { ev.preventDefault(); ev.stopPropagation(); }));
        document.body.addEventListener('dragenter', () => document.body.classList.add('drag-on'));
        document.body.addEventListener('dragleave', (e) => { if(e.clientX===0 && e.clientY===0) document.body.classList.remove('drag-on'); });
        document.body.addEventListener('drop', handleDrop);

        // æ–‡ä»¶å¯¼å…¥æŒ‰é’®äº‹ä»¶
        const fileInput = document.getElementById('file-input');
        document.getElementById('btn-import').addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFiles(Array.from(e.target.files));
                e.target.value = ''; // é‡ç½®ï¼Œå…è®¸é‡å¤é€‰æ‹©åŒä¸€æ–‡ä»¶
            }
        });

        function handleFiles(files) {
            const audios = files.filter(f => f.type.startsWith('audio/') || /\.(mp3|flac|wav|m4a|ogg)$/i.test(f.name));
            const lrcs = {}, slis = {};
            files.forEach(f => {
                if(f.name.endsWith('.lrc')) lrcs[f.name.replace('.lrc','')] = f;
                if(f.name.endsWith('.sli') || f.name.includes('.ogg.sli')) {
                    let base = f.name.replace('.sli','').replace('.ogg','');
                    slis[base] = f;
                }
            });
            if(audios.length) {
                playlist = audios.map(f => {
                    const base = f.name.replace(/\.[^.]+$/, "");
                    return { file: f, name: base, lrcFile: lrcs[base] || null, sliFile: slis[base] || null };
                });
                playlist.sort((a,b) => a.name.localeCompare(b.name));
                renderPlaylist();
                playTrack(0);
            } else if (Object.keys(slis).length > 0 && curIdx !== -1) {
                const cur = playlist[curIdx];
                if(slis[cur.name]) { cur.sliFile = slis[cur.name]; parseSLI(cur); }
            }
        }

        function handleDrop(e) {
            document.body.classList.remove('drag-on');
            handleFiles(Array.from(e.dataTransfer.files));
        }

        async function playTrack(i) {
            if(i < 0 || i >= playlist.length) return;
            curIdx = i; renderPlaylist();
            const track = playlist[i];
            stopAudio();
            currentAudioQuality = ''; // å…ˆæ¸…é™¤ï¼Œåé¢ä¼šæ ¹æ®æ–‡ä»¶ä¿¡æ¯è®¾ç½®

            el.title.textContent = track.name; el.artist.textContent = "Loading...";
            el.img.style.opacity = 0; el.img.src = ''; el.loadTip.style.display = 'block';
            el.progLine.style.width = '0%'; el.bufferLine.style.width = '0%';
            lyrics = []; isSyncedLyrics = true;
            el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">Parsing...</div>';
            resetLoopUI();
            log(`Track: ${track.name}`);

            try {
                const ab = await track.file.arrayBuffer();
                el.bufferLine.style.width = '30%';
                let meta = null;
                if(track.file.name.toLowerCase().endsWith('.flac')) {
                    log("Detect FLAC. Using Native Parser...");
                    meta = await parseFlacTagsNative(track.file);
                    // è®¡ç®—FLACæ¯”ç‰¹ç‡ï¼ˆæ–‡ä»¶å¤§å° / æ—¶é•¿ï¼‰
                    if (meta) {
                        meta.fileSize = track.file.size;
                    }
                } else {
                    // å¯¹äºMP3ç­‰æ–‡ä»¶ï¼Œè®¡ç®—æ¯”ç‰¹ç‡
                    const fileSize = track.file.size;
                    const ext = track.file.name.split('.').pop().toUpperCase();
                    
                    jsmediatags.read(track.file, {
                        onSuccess: (tag) => {
                            const c = {
                                title: tag.tags.title,
                                artist: tag.tags.artist,
                                lyrics: tag.tags.lyrics || (tag.tags.USLT ? tag.tags.USLT.data : ""),
                                picture: tag.tags.picture,
                                fileSize: fileSize,
                                fileExt: ext
                            };
                            applyMetadata(c, "ID3");
                        },
                        onError: () => {
                            updateTheme(null);
                            // æ²¡æœ‰ID3æ ‡ç­¾ï¼Œå°è¯•ç½‘æ˜“äº‘æœç´¢æˆ–æ˜¾ç¤º Pure Music
                            if(!track.lrcFile) {
                                if (neteaseSearchEnabled) {
                                    const songName = el.title.textContent;
                                    // å»¶è¿Ÿæœç´¢ï¼Œç­‰å¾… duration è®¾ç½®å®Œæˆ
                                    const trySearch = () => {
                                        if (playbackState.duration > 0) {
                                            searchNeteaselyrics(songName, '', playbackState.duration);
                                        } else {
                                            if (!trySearch.attempts) trySearch.attempts = 0;
                                            trySearch.attempts++;
                                            if (trySearch.attempts < 30) {
                                                setTimeout(trySearch, 100);
                                            } else {
                                                searchNeteaselyrics(songName, '', 0);
                                            }
                                        }
                                    };
                                    trySearch();
                                } else {
                                    el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">Pure Music</div>';
                                }
                            }
                        }
                    });
                }
                if(meta) applyMetadata(meta, "Native");

                el.bufferLine.style.width = '60%';
                audioBuffer = await actx.decodeAudioData(ab);
                el.bufferLine.style.width = '100%';
                playbackState.duration = audioBuffer.duration;
                el.totalTime.textContent = fmtTime(playbackState.duration);
                el.loadTip.style.display = 'none';
                
                // æ ¹æ®ä¸åŒæ ¼å¼è®¡ç®—å¹¶æ˜¾ç¤ºéŸ³è´¨ä¿¡æ¯
                if (pendingQualityInfo && playbackState.duration > 0) {
                    const ext = pendingQualityInfo.ext;
                    const bitrateKbps = Math.round((pendingQualityInfo.size * 8) / playbackState.duration / 1000);
                    const sampleRate = audioBuffer.sampleRate;
                    const channels = audioBuffer.numberOfChannels;
                    const srKhz = sampleRate >= 1000 ? (sampleRate / 1000).toFixed(sampleRate % 1000 === 0 ? 0 : 1) + 'kHz' : sampleRate + 'Hz';
                    
                    // æ ¹æ®æ ¼å¼æ˜¾ç¤ºä¸åŒçš„ä¿¡æ¯
                    switch(ext) {
                        case 'WAV':
                        case 'AIFF':
                        case 'AIF':
                            // æ— æŸæ ¼å¼ - æ˜¾ç¤ºé‡‡æ ·ç‡å’Œå£°é“
                            const chStr = channels === 1 ? 'Mono' : (channels === 2 ? 'Stereo' : `${channels}ch`);
                            currentAudioQuality = `${ext} ${srKhz} ${chStr}`;
                            break;
                        case 'OGG':
                        case 'OPUS':
                            // OGG/Opus - æ˜¾ç¤ºæ¯”ç‰¹ç‡ï¼ˆæœ‰æŸï¼‰
                            currentAudioQuality = `${ext} ~${bitrateKbps}kbps`;
                            break;
                        case 'AAC':
                        case 'M4A':
                        case 'MP4':
                            // AAC - æ˜¾ç¤ºæ¯”ç‰¹ç‡
                            currentAudioQuality = `AAC ${bitrateKbps}kbps`;
                            break;
                        case 'WMA':
                            currentAudioQuality = `WMA ${bitrateKbps}kbps`;
                            break;
                        case 'APE':
                        case 'TTA':
                        case 'TAK':
                            // æ— æŸå‹ç¼©æ ¼å¼ - æ˜¾ç¤ºé‡‡æ ·ç‡
                            currentAudioQuality = `${ext} ${srKhz}`;
                            break;
                        case 'MP3':
                        default:
                            // MP3å’Œå…¶ä»–æ ¼å¼ - æ˜¾ç¤ºæ¯”ç‰¹ç‡
                            currentAudioQuality = `${ext} ${bitrateKbps}kbps`;
                            break;
                    }
                    log(`Audio: ${currentAudioQuality}, ${sampleRate}Hz, ${channels}ch`);
                    pendingQualityInfo = null;
                }
                
                if(el.artist.textContent === "Loading...") el.artist.textContent = "Ready";
                if(track.sliFile) await parseSLI(track);
                startAudio(0);
                el.coverWrap.classList.add('playing');
                updatePlayIcon();
                updateMediaSession();
                if(track.lrcFile) readLrcFile(track.lrcFile);
            } catch(e) { log("Err: " + e, 'error'); alert("æ’­æ”¾å¤±è´¥ï¼Œè¯·æŸ¥çœ‹Debugçª—å£"); }
        }

        function updateMediaSession() {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: el.title.textContent,
                    artist: el.artist.textContent,
                    artwork: [ { src: el.img.src, sizes: '512x512', type: 'image/png' } ]
                });
                navigator.mediaSession.setActionHandler('play', () => el.playBtn.click());
                navigator.mediaSession.setActionHandler('pause', () => el.playBtn.click());
                navigator.mediaSession.setActionHandler('previoustrack', () => document.getElementById('prev-btn').click());
                navigator.mediaSession.setActionHandler('nexttrack', () => document.getElementById('next-btn').click());
            }
        }

        function applyMetadata(common, source) {
            if(common.title) el.title.textContent = common.title;
            if(common.artist) el.artist.textContent = common.artist;
            
            // è®¾ç½®æœ¬åœ°æ–‡ä»¶éŸ³è´¨æ ‡ç­¾
            if (common.sampleRate && common.bitsPerSample) {
                // FLACæ–‡ä»¶ - æ˜¾ç¤ºä½æ·±åº¦å’Œé‡‡æ ·ç‡
                const srKhz = common.sampleRate >= 1000 ? (common.sampleRate / 1000).toFixed(common.sampleRate % 1000 === 0 ? 0 : 1) + 'kHz' : common.sampleRate + 'Hz';
                currentAudioQuality = `FLAC ${common.bitsPerSample}bit/${srKhz}`;
            } else if (common.fileSize && common.fileExt) {
                // å…¶ä»–æ ¼å¼ - ç¨ååœ¨è§£ç å®Œæˆåæ ¹æ®æ ¼å¼æ˜¾ç¤ºåˆé€‚ä¿¡æ¯
                pendingQualityInfo = { size: common.fileSize, ext: common.fileExt };
            }
            if(common.picture && typeof common.picture === 'object') {
                const data = common.picture.data;
                const format = common.picture.format;
                if(data && format) {
                    let base64 = "";
                    for(let j=0; j<data.length; j++) base64 += String.fromCharCode(data[j]);
                    el.img.src = `data:${format};base64,${window.btoa(base64)}`;
                    el.img.onload = () => { el.img.style.opacity = 1; updateTheme(el.img); updateMediaSession(); }
                }
            } else { updateTheme(null); }

            if(common.lyrics) {
                log("Lyrics found.", 'success');
                let clean = common.lyrics.replace(/\/\s*(?=\[\d{2}:)/g, '\n');
                if(!clean.includes('\n') && clean.includes('/')) clean = clean.replace(/\s*\/\s*/g, '\n');
                parseAndRenderLyrics(clean, source);
            } else if(lyrics.length === 0) {
                // æ²¡æœ‰å†…åµŒæ­Œè¯
                if (neteaseSearchEnabled) {
                    // å¼€å¯äº†ç½‘æ˜“äº‘æœç´¢ï¼Œå°è¯•æœç´¢
                    const songName = el.title.textContent;
                    const artistName = common.artist || '';
                    // å»¶è¿Ÿæœç´¢ï¼Œç­‰å¾… duration è®¾ç½®å®Œæˆ
                    const trySearch = () => {
                        if (playbackState.duration > 0) {
                            searchNeteaselyrics(songName, artistName, playbackState.duration);
                        } else {
                            // duration è¿˜æ²¡å‡†å¤‡å¥½ï¼Œ100ms åé‡è¯•ï¼Œæœ€å¤šé‡è¯• 30 æ¬¡
                            if (!trySearch.attempts) trySearch.attempts = 0;
                            trySearch.attempts++;
                            if (trySearch.attempts < 30) {
                                setTimeout(trySearch, 100);
                            } else {
                                // è¶…æ—¶ï¼Œç›´æ¥æœç´¢ä¸å¸¦æ—¶é•¿
                                searchNeteaselyrics(songName, artistName, 0);
                            }
                        }
                    };
                    trySearch();
                } else {
                    el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">Pure Music</div>';
                }
            }
        }

        function readLrcFile(file) {
            const r = new FileReader();
            r.onload = e => parseAndRenderLyrics(e.target.result, "LRC File");
            r.readAsText(file);
        }

        // ç½‘æ˜“äº‘éŸ³ä¹APIæœåŠ¡
        const NETEASE_API_HOST = 'https://minorimusicapi.zeabur.app';
        
        // Verceléƒ¨ç½²éœ€è¦æ·»åŠ çš„å‚æ•°ï¼ˆç»•è¿‡IPé™åˆ¶ï¼‰
        function buildApiUrl(path) {
            const separator = path.includes('?') ? '&' : '?';
            return `${NETEASE_API_HOST}${path}${separator}randomCNIP=true`;
        }

        async function searchNeteaselyrics(songName, artist, duration) {
            try {
                el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">ğŸ” æ­£åœ¨æœç´¢æ­Œè¯...</div>';
                
                // æ™ºèƒ½æå–æ­Œåå’Œæ­Œæ‰‹ - å¤„ç† "æ­Œæ‰‹ - æ­Œå" æ ¼å¼
                let searchSong = songName;
                let searchArtist = artist || '';
                
                // å¦‚æœæ ‡é¢˜åŒ…å« " - "ï¼Œåˆ†ç¦»æ­Œæ‰‹å’Œæ­Œå
                if (songName.includes(' - ')) {
                    const parts = songName.split(' - ');
                    if (parts.length >= 2) {
                        searchArtist = parts[0].trim();
                        searchSong = parts.slice(1).join(' - ').trim();
                    }
                }
                
                log(`Searching lyrics: "${searchSong}" by "${searchArtist}"`);
                
                // æœç´¢æ­Œæ›²
                const searchResp = await fetch(buildApiUrl(`/search?keywords=${encodeURIComponent(searchSong)}&limit=20`));
                if (!searchResp.ok) throw new Error('æœç´¢è¯·æ±‚å¤±è´¥');
                
                const searchData = await searchResp.json();
                if (searchData.code !== 200 || !searchData.result?.songs?.length) {
                    log('No songs found on Netease', 'error');
                    el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">æœªæ‰¾åˆ°åŒ¹é…æ­Œæ›²</div>';
                    return false;
                }
                
                log(`Found ${searchData.result.songs.length} songs`, 'success');
                
                // åŒ¹é…é€»è¾‘ï¼šæ­Œå â†’ æ­Œæ‰‹ â†’ æ—¶é•¿
                const songs = searchData.result.songs;
                log(`Found ${songs.length} candidates`);
                
                // è¾…åŠ©å‡½æ•°ï¼šæ ‡å‡†åŒ–å­—ç¬¦ä¸²
                const normalize = (s) => (s || '').toLowerCase().replace(/\s+/g, '');
                const targetName = normalize(searchSong);
                const targetArtist = normalize(searchArtist);
                
                // 1. å…ˆç­›é€‰æ­ŒååŒ¹é…çš„æ­Œæ›²
                let nameMatched = songs.filter(s => normalize(s.name) === targetName);
                
                // å¦‚æœå®Œå…¨åŒ¹é…æ²¡æœ‰ï¼Œå°è¯•åŒ…å«åŒ¹é…
                if (nameMatched.length === 0) {
                    nameMatched = songs.filter(s => 
                        normalize(s.name).includes(targetName) || 
                        targetName.includes(normalize(s.name))
                    );
                }
                
                let candidates = nameMatched.length > 0 ? nameMatched : songs;
                
                if (nameMatched.length > 0) {
                    log(`${nameMatched.length} songs with matching name`);
                } else {
                    log(`No exact name match, using all candidates`, 'warn');
                }
                
                // 2. ä»æ­ŒååŒ¹é…çš„æ­Œæ›²ä¸­ï¼Œä¼˜å…ˆé€‰æ­Œæ‰‹åŒ¹é…çš„
                let bestMatch = candidates[0];
                
                if (targetArtist && candidates.length > 1) {
                    // æ‰¾æ­Œæ‰‹å®Œå…¨åŒ¹é…çš„
                    const artistMatched = candidates.filter(s => {
                        const songArtists = (s.artists || []).map(a => normalize(a.name));
                        return songArtists.some(a => a === targetArtist || a.includes(targetArtist) || targetArtist.includes(a));
                    });
                    
                    if (artistMatched.length > 0) {
                        log(`${artistMatched.length} songs with matching artist`);
                        candidates = artistMatched;
                        bestMatch = candidates[0];
                    }
                }
                
                // 3. æœ€åæŒ‰æ—¶é•¿é€‰æœ€æ¥è¿‘çš„
                if (duration && duration > 0 && candidates.length > 1) {
                    const targetMs = duration * 1000;
                    let minDiff = Math.abs((bestMatch.duration || 0) - targetMs);
                    
                    for (const song of candidates) {
                        const songDur = song.duration || 0;
                        const diff = Math.abs(songDur - targetMs);
                        if (diff < minDiff) {
                            minDiff = diff;
                            bestMatch = song;
                        }
                    }
                    const diffSec = (minDiff/1000).toFixed(1);
                    log(`Best match: "${bestMatch.name}" by ${bestMatch.artists?.[0]?.name || '?'} (Î”${diffSec}s)`);
                } else {
                    log(`Selected: "${bestMatch.name}" by ${bestMatch.artists?.[0]?.name || '?'}`);
                }
                
                const songId = bestMatch.id;
                log(`Found song ID: ${songId} - ${bestMatch.name}`);
                
                // è·å–æ­Œè¯
                const lyricResp = await fetch(buildApiUrl(`/lyric?id=${songId}`));
                if (!lyricResp.ok) throw new Error('è·å–æ­Œè¯å¤±è´¥');
                
                const lyricData = await lyricResp.json();
                
                if (lyricData?.lrc?.lyric) {
                    log('Netease lyrics loaded!', 'success');
                    parseAndRenderLyrics(lyricData.lrc.lyric, 'ç½‘æ˜“äº‘');
                    return true;
                } else if (lyricData?.nolyric || lyricData?.uncollected) {
                    log('Song has no lyrics (instrumental)', 'warn');
                    el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">ğŸµ çº¯éŸ³ä¹ï¼Œæ— æ­Œè¯</div>';
                    return false;
                } else {
                    throw new Error('No lyrics in response');
                }
            } catch (e) {
                log('Netease search error: ' + e.message, 'error');
                el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">æ­Œè¯æœç´¢å¤±è´¥</div>';
                return false;
            }
        }
        
        // ç›´æ¥é€šè¿‡æ­Œæ›²IDè·å–æ­Œè¯ï¼ˆç”¨äºå·²çŸ¥IDçš„ç½‘æ˜“äº‘æ­Œæ›²ï¼‰
        async function fetchLyricById(songId) {
            // æ”¯æŒå¤–éƒ¨ä¼ å…¥AbortController
            let lyricSignal;
            if (arguments.length > 1 && arguments[1] && arguments[1].signal) {
                lyricSignal = arguments[1].signal;
            } else {
                if (window.neteaseLyricAbortController) window.neteaseLyricAbortController.abort();
                window.neteaseLyricAbortController = new AbortController();
                lyricSignal = window.neteaseLyricAbortController.signal;
            }
            try {
                el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">ğŸ” è·å–æ­Œè¯...</div>';
                const resp = await fetch(buildApiUrl(`/lyric?id=${songId}`), { signal: lyricSignal });
                if (resp.ok) {
                    const data = await resp.json();
                    if (data?.lrc?.lyric) {
                        log('Lyrics loaded!', 'success');
                        parseAndRenderLyrics(data.lrc.lyric, 'ç½‘æ˜“äº‘');
                        return true;
                    } else if (data?.nolyric || data?.uncollected) {
                        el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">ğŸµ çº¯éŸ³ä¹ï¼Œæ— æ­Œè¯</div>';
                        return false;
                    }
                }
                el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">æš‚æ— æ­Œè¯</div>';
                return false;
            } catch (e) {
                if (e.name === 'AbortError') {
                    // åˆ‡æ­Œæ—¶ä¸­æ–­ä¸æŠ¥é”™
                    return false;
                }
                log('Lyric fetch error: ' + e.message, 'error');
                el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">æ­Œè¯è·å–å¤±è´¥</div>';
                return false;
            }
        }

        function parseAndRenderLyrics(text, source) {
            const lines = text.split(/[\r\n]/);
            // æ”¯æŒå¤šç§æ—¶é—´æ ¼å¼: [00:00.00], [00:00.000], [00:00:00], [0:00.00]
            const timeReg = /\[(\d{1,2}):(\d{2})(?:[:.](\d{2,3}))?\]/g;
            lyrics = [];
            let hasTimeTag = false;
            
            lines.forEach(l => {
                const line = l.trim();
                if (!line) return;
                
                // æå–æ‰€æœ‰æ—¶é—´æ ‡ç­¾
                const times = [];
                let match;
                while ((match = timeReg.exec(line)) !== null) {
                    const min = parseInt(match[1]);
                    const sec = parseInt(match[2]);
                    let ms = match[3] ? parseInt(match[3]) : 0;
                    // å¦‚æœæ¯«ç§’æ˜¯2ä½æ•°ï¼Œéœ€è¦ä¹˜ä»¥10ï¼ˆå¦‚.12è¡¨ç¤º120æ¯«ç§’ï¼‰
                    if (match[3] && match[3].length === 2) ms *= 10;
                    times.push(min * 60 + sec + ms / 1000);
                }
                timeReg.lastIndex = 0; // é‡ç½®æ­£åˆ™
                
                // æå–æ­Œè¯æ–‡æœ¬ï¼ˆç§»é™¤æ‰€æœ‰æ—¶é—´æ ‡ç­¾å’Œå…ƒæ•°æ®æ ‡ç­¾å¦‚[ti:xxx]ï¼‰
                const txt = line.replace(/\[\d{1,2}:\d{2}(?:[:.\d]+)?\]/g, '')
                                .replace(/\[[a-zA-Z]+:.*?\]/g, '')
                                .trim();
                
                if (times.length > 0 && txt) {
                    hasTimeTag = true;
                    // ä¸€è¡Œå¯èƒ½æœ‰å¤šä¸ªæ—¶é—´æ ‡ç­¾ï¼ˆåˆå”±ç­‰ï¼‰
                    times.forEach(t => lyrics.push({ t, txt }));
                } else if (txt && !line.match(/^\[[a-zA-Z]+:/)) {
                    // éå…ƒæ•°æ®è¡Œæ‰æ·»åŠ 
                    lyrics.push({ t: -1, txt });
                }
            });
            
            // æŒ‰æ—¶é—´æ’åº
            lyrics.sort((a, b) => a.t - b.t);
            
            el.lyricBox.innerHTML = `<div style="height:120px"></div>`;
            isSyncedLyrics = hasTimeTag && lyrics.some(l => l.t >= 0);
            
            if(isSyncedLyrics) {
                lyrics.forEach(l => {
                    if(l.t < 0 || !l.txt) return;
                    const d = document.createElement('div'); 
                    d.className = 'lyric-line'; 
                    d.textContent = l.txt; 
                    d.onclick = () => startAudio(l.t); 
                    el.lyricBox.appendChild(d); 
                });
                el.artist.innerHTML += ` <span class="tag-source">${source}</span>`;
                if (currentAudioQuality) el.artist.innerHTML += ` <span class="tag-quality">${currentAudioQuality}</span>`;
                el.lyricBox.innerHTML += '<div style="height:150px"></div>';
                log(`Lyrics: ${lyrics.filter(l => l.t >= 0).length} lines`, 'success');
            } else if (lyrics.length > 0) {
                // æœ‰å†…å®¹ä½†æ— æ—¶é—´æ ‡ç­¾
                const content = lyrics.map(l => l.txt).join('\n');
                el.lyricBox.innerHTML = `<div style="padding:20px; text-align:center; white-space:pre-wrap; color:var(--text-main); font-size:1rem; line-height:1.8;">${content}</div>`;
                el.artist.innerHTML += ` <span class="tag-source">Unsynced</span>`;
                if (currentAudioQuality) el.artist.innerHTML += ` <span class="tag-quality">${currentAudioQuality}</span>`;
            } else {
                el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">æš‚æ— æ­Œè¯</div>';
            }
        }

        function startAudio(offset) {
            if(sourceNode) sourceNode.disconnect();
            sourceNode = actx.createBufferSource();
            sourceNode.buffer = audioBuffer;
            sourceNode.connect(gainNode);
            
            const isLooping = loopState.active && loopState.end <= audioBuffer.duration && loopState.start < loopState.end;
            
            if(isLooping) {
                sourceNode.loop = true; 
                sourceNode.loopStart = loopState.start; 
                sourceNode.loopEnd = loopState.end;
                document.getElementById('loop-status').style.display = 'inline';
            } else {
                sourceNode.loop = false; 
                document.getElementById('loop-status').style.display = 'none';
            }
            sourceNode.start(0, offset);
            playbackState.startTime = actx.currentTime - offset;
            playbackState.pauseTime = offset;
            playbackState.isPlaying = true;
            if('mediaSession' in navigator) navigator.mediaSession.playbackState = "playing";
            
            // ä½¿ç”¨é—­åŒ…ä¿å­˜å¾ªç¯çŠ¶æ€ï¼Œé¿å…åç»­çŠ¶æ€å˜åŒ–å½±å“åˆ¤æ–­
            const wasLooping = isLooping;
            sourceNode.onended = () => {
                // å¦‚æœæ˜¯å¾ªç¯æ¨¡å¼ï¼Œonended ä¸åº”è¯¥è§¦å‘åˆ‡æ­Œ
                // ä½†æŸäº›æµè§ˆå™¨å¯èƒ½åœ¨ç²¾åº¦é—®é¢˜ä¸‹æ„å¤–è§¦å‘ï¼Œè¿™é‡Œé‡æ–°å¯åŠ¨å¾ªç¯
                if(wasLooping && loopState.active && playbackState.isPlaying) {
                    log("Loop interrupted, restarting...", 'warn');
                    startAudio(loopState.start);
                    return;
                }
                // éå¾ªç¯æ¨¡å¼ä¸‹ï¼Œæ£€æŸ¥æ˜¯å¦çœŸçš„æ’­æ”¾å®Œäº†
                if(!wasLooping && playbackState.isPlaying && (getCurrentTime() >= playbackState.duration - 0.5)) {
                    handleNext();
                }
            };
        }
        function stopAudio() { 
            if(sourceNode) { try{sourceNode.stop()}catch(e){}; sourceNode.disconnect(); sourceNode=null; } 
            playbackState.isPlaying = false; 
            if('mediaSession' in navigator) navigator.mediaSession.playbackState = "paused";
            // å–æ¶ˆå½“å‰çš„ç½‘ç»œè¯·æ±‚
            if(currentAbortController) {
                currentAbortController.abort();
                currentAbortController = null;
            }
        }
        function getCurrentTime() {
            if(!playbackState.isPlaying) return playbackState.pauseTime;
            let t = actx.currentTime - playbackState.startTime;
            if(loopState.active && sourceNode.loop && t > loopState.end) { const dur = loopState.end - loopState.start; t = loopState.start + (t - loopState.end) % dur; } 
            else if (t > playbackState.duration) t = playbackState.duration;
            return t;
        }

        function renderLoop() {
            requestAnimationFrame(renderLoop);
            const now = getCurrentTime();
            el.currTime.textContent = fmtTime(now);
            if(playbackState.duration) el.progLine.style.width = (now / playbackState.duration) * 100 + '%';
            if(isSyncedLyrics && lyrics.length) {
                let idx = lyrics.findIndex(l => l.t > now) - 1;
                if(idx < 0) idx = lyrics.length - 1; if(now < lyrics[0]?.t) idx = -1;
                const activeLine = el.lyricBox.children[idx + 1];
                if(activeLine && !activeLine.classList.contains('active')) {
                    document.querySelectorAll('.lyric-line').forEach(l => l.classList.remove('active'));
                    activeLine.classList.add('active');
                    const offset = activeLine.offsetTop - el.lyricBox.parentNode.offsetHeight/2 + activeLine.offsetHeight/2;
                    el.lyricBox.style.transform = `translateY(-${offset}px)`;
                }
            }
            renderVisuals();
        }
        renderLoop();

        el.playBtn.onclick = () => {
            if(actx.state === 'suspended') actx.resume();
            if(playbackState.isPlaying) { playbackState.pauseTime = getCurrentTime(); stopAudio(); el.coverWrap.classList.remove('playing'); updatePlayIcon(); }
            else { if(audioBuffer) { startAudio(playbackState.pauseTime); el.coverWrap.classList.add('playing'); updatePlayIcon(); } }
        };
        
        // è¿›åº¦æ¡æ‹–åŠ¨æ”¯æŒ
        let isDraggingProgress = false;
        let wasPlayingBeforeDrag = false;
        
        function handleProgressSeek(e) {
            if(!playbackState.duration) return;
            const rect = el.progBg.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const pct = Math.max(0, Math.min(1, x / rect.width));
            const target = pct * playbackState.duration;
            el.progLine.style.width = pct * 100 + '%';
            el.currTime.textContent = fmtTime(target);
            return target;
        }
        
        el.progBg.onmousedown = e => {
            if(!playbackState.duration) return;
            isDraggingProgress = true;
            wasPlayingBeforeDrag = playbackState.isPlaying;
            if(wasPlayingBeforeDrag) stopAudio();
            playbackState.pauseTime = handleProgressSeek(e);
        };
        
        document.addEventListener('mousemove', e => {
            if(!isDraggingProgress) return;
            playbackState.pauseTime = handleProgressSeek(e);
        });
        
        document.addEventListener('mouseup', e => {
            if(!isDraggingProgress) return;
            isDraggingProgress = false;
            if(wasPlayingBeforeDrag) {
                startAudio(playbackState.pauseTime);
                el.coverWrap.classList.add('playing');
            }
        });
        
        // è§¦æ‘¸å±æ”¯æŒ
        el.progBg.ontouchstart = e => {
            if(!playbackState.duration) return;
            isDraggingProgress = true;
            wasPlayingBeforeDrag = playbackState.isPlaying;
            if(wasPlayingBeforeDrag) stopAudio();
            playbackState.pauseTime = handleProgressSeek(e);
        };
        
        el.progBg.ontouchmove = e => {
            if(!isDraggingProgress) return;
            e.preventDefault();
            playbackState.pauseTime = handleProgressSeek(e);
        };
        
        el.progBg.ontouchend = e => {
            if(!isDraggingProgress) return;
            isDraggingProgress = false;
            if(wasPlayingBeforeDrag) {
                startAudio(playbackState.pauseTime);
                el.coverWrap.classList.add('playing');
            }
        };
        
        el.volBtn.onclick = () => { el.volPopup.classList.toggle('show'); };
        el.volRange.oninput = () => { gainNode.gain.value = el.volRange.value; };

        document.addEventListener('keydown', (e) => {
            if(e.target.tagName === 'INPUT') return;
            if(e.code === 'Space') { e.preventDefault(); el.playBtn.click(); } 
            else if (e.code === 'ArrowLeft') { if (audioBuffer) { const t = Math.max(0, getCurrentTime() - 5); if (playbackState.isPlaying) startAudio(t); else { playbackState.pauseTime = t; updateUI(t); } } } 
            else if (e.code === 'ArrowRight') { if (audioBuffer) { const t = Math.min(playbackState.duration, getCurrentTime() + 5); if (playbackState.isPlaying) startAudio(t); else { playbackState.pauseTime = t; updateUI(t); } } } 
            else if (e.code === 'ArrowUp') { e.preventDefault(); el.volRange.value = Math.min(1, parseFloat(el.volRange.value) + 0.05); gainNode.gain.value = el.volRange.value; el.volPopup.classList.add('show'); clearTimeout(window.volTimer); window.volTimer = setTimeout(() => el.volPopup.classList.remove('show'), 2000); } 
            else if (e.code === 'ArrowDown') { e.preventDefault(); el.volRange.value = Math.max(0, parseFloat(el.volRange.value) - 0.05); gainNode.gain.value = el.volRange.value; el.volPopup.classList.add('show'); clearTimeout(window.volTimer); window.volTimer = setTimeout(() => el.volPopup.classList.remove('show'), 2000); }
        });
        function updateUI(t) { el.currTime.textContent = fmtTime(t); el.progLine.style.width = (t / playbackState.duration) * 100 + '%'; }

        function handleNext() {
            if(playMode === 1) playTrack(Math.floor(Math.random()*playlist.length));
            else if(playMode === 2) startAudio(0);
            else playTrack(curIdx + 1 >= playlist.length ? 0 : curIdx + 1);
        }
        document.getElementById('prev-btn').onclick = () => playTrack(curIdx - 1 < 0 ? playlist.length-1 : curIdx - 1);
        document.getElementById('next-btn').onclick = handleNext;
        el.modeBtn.onclick = () => {
            playMode = (playMode + 1) % 3;
            ['icon-list-loop', 'icon-random', 'icon-single'].forEach(id => document.getElementById(id).style.display = 'none');
            document.getElementById(['icon-list-loop', 'icon-random', 'icon-single'][playMode]).style.display = 'block';
        };

        async function parseSLI(track) {
            return new Promise(resolve => {
                const r = new FileReader();
                r.onload = e => {
                    const m = e.target.result.match(/From\s*=\s*(\d+)\s*;\s*To\s*=\s*(\d+)/i);
                    if(m) {
                        const rate = parseInt(el.baseRateInput.value) || 44100;
                        applyLoop(parseInt(m[2])/rate, parseInt(m[1])/rate);
                        el.loopMsg.textContent = `SLI Loaded`;
                    }
                    resolve();
                };
                r.readAsText(track.sliFile);
            });
        }
        function applyLoop(s, e) {
            el.loopStart.value = s.toFixed(3); el.loopEnd.value = e.toFixed(3);
            el.loopEnable.checked = true; loopState = { active: true, start: s, end: e };
            updateLoopMarkers();
        }
        window.setLoopPoint = function(t) {
            const now = getCurrentTime();
            if(t==='a') el.loopStart.value=now.toFixed(3); else el.loopEnd.value=now.toFixed(3);
            el.loopEnable.checked = true; el.loopEnable.dispatchEvent(new Event('change'));
        };
        el.loopEnable.addEventListener('change', e => {
            if(e.target.checked) {
                const s = parseFloat(el.loopStart.value), e_val = parseFloat(el.loopEnd.value);
                if(e_val > s) { loopState = { active: true, start: s, end: e_val }; if(playbackState.isPlaying) startAudio(getCurrentTime()); }
            } else { loopState.active = false; if(playbackState.isPlaying) startAudio(getCurrentTime()); }
            updateLoopMarkers();
        });
        function resetLoopUI() { loopState.active=false; el.loopEnable.checked=false; updateLoopMarkers(); }
        function updateLoopMarkers() {
            if(!loopState.active) { el.markerA.style.display='none'; el.markerB.style.display='none'; document.getElementById('loop-status').style.display='none'; return; }
            const d = playbackState.duration || 1;
            el.markerA.style.left = (loopState.start/d)*100+'%'; el.markerB.style.left = (loopState.end/d)*100+'%';
            el.markerA.style.display='block'; el.markerB.style.display='block'; document.getElementById('loop-status').style.display='inline';
        }

        function updatePlayIcon() { el.playBtn.innerHTML = playbackState.isPlaying ? '<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>' : '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>'; }
        function fmtTime(s) { const m = Math.floor(s/60); const sc = Math.floor(s%60); return `${m.toString().padStart(2,'0')}:${sc.toString().padStart(2,'0')}`; }
        function renderPlaylist() {
            el.plContainer.innerHTML = '';
            playlist.forEach((t, i) => {
                const d = document.createElement('div'); d.className = `pl-item ${i === curIdx ? 'active' : ''}`;
                const icon = t.netease ? 'â˜ï¸ ' : '';
                d.innerHTML = `<span style="width:20px; opacity:0.5">${i+1}</span> ${icon}${t.name}`;
                d.onclick = () => playTrackFromPlaylist(i); el.plContainer.appendChild(d);
            });
        }
        function updateTheme(img) {
            let c1 = "#e0c3fc", c2 = "#8ec5fc";
            if(img) { try { const rgb = colorThief.getColor(img); c1 = `rgb(${Math.floor((rgb[0]+255)/2)},${Math.floor((rgb[1]+255)/2)},${Math.floor((rgb[2]+255)/2)})`; c2 = `rgb(${Math.floor((rgb[0]+200)/2)},${Math.floor((rgb[1]+220)/2)},${Math.floor((rgb[2]+255)/2)})`; } catch(e){} }
            document.body.style.setProperty('--bg-1', c1); document.body.style.setProperty('--bg-2', c2);
        }
        function renderVisuals() {
            const mode = el.effectSel.value, w = el.canvas.width = window.innerWidth, h = el.canvas.height = window.innerHeight;
            canvasCtx.clearRect(0,0,w,h); if(mode==='none') return;
            let data = new Uint8Array(analyser.frequencyBinCount); analyser.getByteFrequencyData(data);
            if(mode==='bars') { const bw=(w/data.length)*2.5; let x=0; for(let i=0;i<data.length;i++){ const H=data[i]*1.5; canvasCtx.fillStyle=`rgba(255,255,255,0.3)`; canvasCtx.fillRect(x,h-H/2,bw,H/2); x+=bw+1; } }
            else if(mode==='snow') {
                // è‡ªé€‚åº”é›ªèŠ±æ•°é‡å¹¶ä¿æŒå·¦å³å‡åŒ€åˆ†å¸ƒ
                const maxParticles = Math.max(60, Math.floor(w / 8));
                while (particles.length < maxParticles) {
                    particles.push({ x: Math.random() * w, y: Math.random() * -h, r: Math.random() * 3 + 1, s: Math.random() * 2 + 0.5 });
                }
                const bass = (data && data[10]) ? data[10] : 0;
                canvasCtx.fillStyle = "rgba(255,255,255,0.9)";
                for (let i = 0; i < particles.length; i++) {
                    const p = particles[i];
                    // å‚ç›´ç§»åŠ¨ï¼Œå—ä½é¢‘å½±å“ä½†å¹…åº¦è¾ƒå°
                    p.y += p.s * (1 + (bass / 256) * 0.8);
                    // æ¸©å’Œæ°´å¹³æ¼‚ç§»å¹¶åŠ éšæœºæŠ–åŠ¨ï¼Œé¿å…åå‘ä¸€ä¾§
                    p.x += Math.sin(p.y * 0.01) * 0.5 + (Math.random() - 0.5) * 0.3;
                    // è¶Šç•Œå¤„ç†ï¼šä»é¡¶éƒ¨éšæœºXé‡ç½®ï¼Œä¿æŒæ•´ä½“å‡åŒ€
                    if (p.y > h) {
                        p.y = -Math.random() * 20;
                        p.x = Math.random() * w;
                    }
                    if (p.x < -50 || p.x > w + 50) {
                        p.x = Math.random() * w;
                    }
                    canvasCtx.beginPath();
                    canvasCtx.arc(p.x, p.y, Math.max(1, p.r), 0, Math.PI * 2);
                    canvasCtx.fill();
                }
            } else if(mode==='waves') {
                canvasCtx.beginPath(); canvasCtx.moveTo(0,h/2);
                for(let i=0;i<data.length;i++){ canvasCtx.lineTo((i/data.length)*w, h/2+Math.sin(i*0.1+performance.now()/1000)*data[i]+Math.cos(i*0.05)*50); }
                canvasCtx.strokeStyle="rgba(255,255,255,0.4)"; canvasCtx.lineWidth=2; canvasCtx.stroke();
            }
        }

        document.getElementById('toggle-list').onclick = () => document.getElementById('playlist-sidebar').classList.toggle('show');
        document.getElementById('toggle-loop-panel').onclick = () => document.getElementById('loop-panel').classList.toggle('show');
        document.getElementById('toggle-analyze').onclick = () => document.getElementById('analyze-panel').classList.toggle('show');
        document.getElementById('toggle-debug').onclick = () => {
            const dbg = document.getElementById('debug-console');
            dbg.style.display = (dbg.style.display === 'none' || dbg.style.display === '') ? 'block' : 'none';
        };
        
        // ç½‘æ˜“äº‘æ­Œè¯å¼€å…³
        const neteaseBtn = document.getElementById('toggle-netease');
        neteaseBtn.onclick = () => {
            neteaseSearchEnabled = !neteaseSearchEnabled;
            neteaseBtn.style.background = neteaseSearchEnabled ? '#27ae60' : '';
            neteaseBtn.style.color = neteaseSearchEnabled ? '#fff' : '';
            log(`Netease lyrics search: ${neteaseSearchEnabled ? 'ON' : 'OFF'}`);
        };
        
        // ========== ç½‘æ˜“äº‘éŸ³ä¹æœç´¢ & æ­Œå•å¯¼å…¥ ==========
        const neteasePanel = document.getElementById('netease-panel');
        const neteaseTabs = document.querySelectorAll('.netease-tab');
        const searchInput = document.getElementById('netease-search-input');
        const searchBtn = document.getElementById('netease-search-btn');
        const searchResults = document.getElementById('netease-search-results');
        const playlistInput = document.getElementById('netease-playlist-input');
        const playlistBtn = document.getElementById('netease-playlist-btn');
        const playlistPreview = document.getElementById('netease-playlist-preview');
        const playlistResults = document.getElementById('netease-playlist-results');
        
        // æ‰“å¼€ç½‘æ˜“äº‘é¢æ¿
        document.getElementById('toggle-netease-panel').onclick = () => {
            neteasePanel.classList.add('show');
        };
        
        // ç‚¹å‡»èƒŒæ™¯å…³é—­
        neteasePanel.onclick = (e) => {
            if (e.target === neteasePanel) neteasePanel.classList.remove('show');
        };
        
        // Tab åˆ‡æ¢
        neteaseTabs.forEach(tab => {
            tab.onclick = () => {
                neteaseTabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                document.querySelectorAll('.netease-tab-content').forEach(c => c.style.display = 'none');
                document.getElementById('tab-' + tab.dataset.tab).style.display = 'flex';
                // åˆ‡æ¢åˆ°æˆ‘çš„æ­Œå•æ—¶ï¼Œåªæœ‰æœªåŠ è½½è¿‡æ‰åˆ·æ–°
                if (tab.dataset.tab === 'mylist' && neteaseUser && !myPlaylistsCache) {
                    loadMyPlaylists();
                }
            };
        });
        
        // ========== ç½‘æ˜“äº‘ç™»å½•ç³»ç»Ÿ ==========
        let neteaseUser = null;
        let neteaseCookie = localStorage.getItem('netease_cookie') || '';
        let qrCheckTimer = null;
        let myPlaylistsCache = null; // æˆ‘çš„æ­Œå•ç¼“å­˜
        let pendingQualityInfo = null; // ç­‰å¾…è®¡ç®—çš„éŸ³è´¨ä¿¡æ¯ï¼ˆMP3ç­‰ï¼‰
        let currentAudioQuality = ''; // å½“å‰æ’­æ”¾éŸ³è´¨
        let neteaseVipType = 0; // 0=æ™®é€š 1=VIP 2=SVIP 3=éŸ³ä¹åŒ…
        let neteaseQuality = localStorage.getItem('netease_quality') || 'exhigh'; // é»˜è®¤æé«˜
        
        // åˆå§‹åŒ–éŸ³è´¨é€‰æ‹©å™¨
        const qualitySelect = document.getElementById('netease-quality-select');
        qualitySelect.value = neteaseQuality;
        qualitySelect.onchange = () => {
            neteaseQuality = qualitySelect.value;
            localStorage.setItem('netease_quality', neteaseQuality);
            log(`éŸ³è´¨è®¾ç½®: ${qualitySelect.options[qualitySelect.selectedIndex].text}`);
        };
        
        // æ£€æŸ¥ç™»å½•çŠ¶æ€
        async function checkLoginStatus() {
            if (!neteaseCookie) return false;
            
            try {
                const resp = await fetch(buildApiUrl(`/login/status?cookie=${encodeURIComponent(neteaseCookie)}`));
                if (resp.ok) {
                    const json = await resp.json();
                    if (json.data?.profile) {
                        neteaseUser = json.data.profile;
                        // è·å–VIPä¿¡æ¯
                        await fetchVipInfo();
                        updateUserUI();
                        log(`Logged in as: ${neteaseUser.nickname}`, 'success');
                        return true;
                    }
                }
            } catch (e) {
                log('Login check failed: ' + e.message, 'error');
            }
            return false;
        }
        
        // è·å–VIPä¿¡æ¯
        async function fetchVipInfo() {
            try {
                const resp = await fetch(buildApiUrl(`/vip/info?cookie=${encodeURIComponent(neteaseCookie)}`));
                if (resp.ok) {
                    const json = await resp.json();
                    // redVipLevel: 0=æ™®é€š 1=VIP; musicPackage=éŸ³ä¹åŒ…
                    const vipInfo = json.data;
                    if (vipInfo?.redVipLevel >= 7) {
                        neteaseVipType = 2; // SVIP
                        neteaseQuality = localStorage.getItem('netease_quality') || 'lossless';
                    } else if (vipInfo?.redVipLevel >= 1) {
                        neteaseVipType = 1; // VIP
                        neteaseQuality = localStorage.getItem('netease_quality') || 'lossless';
                    } else if (vipInfo?.musicPackage?.vipCode) {
                        neteaseVipType = 3; // éŸ³ä¹åŒ…
                        neteaseQuality = localStorage.getItem('netease_quality') || 'lossless';
                    } else {
                        neteaseVipType = 0; // æ™®é€š
                        neteaseQuality = localStorage.getItem('netease_quality') || 'exhigh';
                    }
                    qualitySelect.value = neteaseQuality;
                    localStorage.setItem('netease_quality', neteaseQuality);
                }
            } catch (e) {
                log('VIP info fetch failed', 'warn');
            }
        }
        
        // æ›´æ–°ç”¨æˆ·ç•Œé¢
        function updateUserUI() {
            const userBar = document.getElementById('netease-user-bar');
            const loginBtn = document.getElementById('netease-login-btn');
            const qualityBar = document.getElementById('netease-quality-bar');
            
            if (neteaseUser) {
                document.getElementById('netease-avatar').src = neteaseUser.avatarUrl;
                document.getElementById('netease-nickname').textContent = neteaseUser.nickname;
                document.getElementById('netease-user-id').textContent = 'ID: ' + neteaseUser.userId;
                
                // æ˜¾ç¤ºVIPçŠ¶æ€
                const userTypeEl = document.getElementById('netease-user-type');
                const typeMap = {
                    0: { text: 'æ™®é€šç”¨æˆ·', cls: 'normal' },
                    1: { text: 'VIPä¼šå‘˜', cls: 'vip' },
                    2: { text: 'SVIPä¼šå‘˜', cls: 'svip' },
                    3: { text: 'éŸ³ä¹åŒ…', cls: 'music-pack' }
                };
                const typeInfo = typeMap[neteaseVipType] || typeMap[0];
                userTypeEl.textContent = typeInfo.text;
                userTypeEl.className = 'netease-user-type ' + typeInfo.cls;
                
                userBar.style.display = 'flex';
                loginBtn.style.display = 'none';
                qualityBar.style.display = 'flex';
            } else {
                userBar.style.display = 'none';
                loginBtn.style.display = 'block';
                qualityBar.style.display = 'none';
            }
        }
        
        // æ˜¾ç¤ºäºŒç»´ç ç™»å½•
        async function showQRLogin() {
            // åˆ‡æ¢åˆ°ç™»å½•Tab
            document.querySelectorAll('.netease-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.netease-tab-content').forEach(c => c.style.display = 'none');
            document.getElementById('tab-qrlogin').style.display = 'block';
            
            await generateQRCode();
        }
        window.showQRLogin = showQRLogin;
        
        // ç”ŸæˆäºŒç»´ç 
        async function generateQRCode() {
                        // äºŒç»´ç ç›¸å…³è¯·æ±‚AbortController
                        if (window.neteaseQrAbortController) {
                            window.neteaseQrAbortController.abort();
                        }
                        window.neteaseQrAbortController = new AbortController();
                        const qrSignal = window.neteaseQrAbortController.signal;
            const imgWrap = document.getElementById('qrcode-img-wrap');
            const status = document.getElementById('qrcode-status');
            imgWrap.innerHTML = '<div class="netease-loading">ç”ŸæˆäºŒç»´ç ä¸­...</div>';
            status.textContent = 'ç­‰å¾…æ‰«æ...';
            status.className = 'qrcode-status waiting';
            
            // æ¸…é™¤æ—§çš„å®šæ—¶å™¨
            if (qrCheckTimer) clearInterval(qrCheckTimer);
            
            try {
                // è·å–äºŒç»´ç key
                const keyResp = await fetch(buildApiUrl(`/login/qr/key?timestamp=${Date.now()}`), { signal: qrSignal });
                if (!keyResp.ok) throw new Error('æ— æ³•è·å–äºŒç»´ç ');
                const keyJson = await keyResp.json();
                if (!keyJson.data?.unikey) throw new Error('æ— æ³•è·å–äºŒç»´ç key');
                const qrKey = keyJson.data.unikey;
                // è·å–äºŒç»´ç å›¾ç‰‡
                const imgResp = await fetch(buildApiUrl(`/login/qr/create?key=${qrKey}&qrimg=true&timestamp=${Date.now()}`), { signal: qrSignal });
                if (!imgResp.ok) throw new Error('æ— æ³•ç”ŸæˆäºŒç»´ç å›¾ç‰‡');
                const imgJson = await imgResp.json();
                if (!imgJson.data?.qrimg) throw new Error('æ— æ³•ç”ŸæˆäºŒç»´ç ');
                imgWrap.innerHTML = `<img src="${imgJson.data.qrimg}" alt="QR Code">`;
                // è½®è¯¢æ£€æŸ¥æ‰«ç çŠ¶æ€
                qrCheckTimer = setInterval(async () => {
                    try {
                        if (qrSignal.aborted) return;
                        const checkResp = await fetch(buildApiUrl(`/login/qr/check?key=${qrKey}&timestamp=${Date.now()}&noCookie=true`), { signal: qrSignal });
                        if (!checkResp.ok) return;
                        const checkJson = await checkResp.json();
                        if (checkJson.code === 800) {
                            status.textContent = 'äºŒç»´ç å·²è¿‡æœŸï¼Œè¯·åˆ·æ–°';
                            status.className = 'qrcode-status expired';
                            clearInterval(qrCheckTimer);
                        } else if (checkJson.code === 801) {
                            status.textContent = 'ç­‰å¾…æ‰«æ...';
                            status.className = 'qrcode-status waiting';
                        } else if (checkJson.code === 802) {
                            status.textContent = 'å·²æ‰«æï¼Œè¯·åœ¨æ‰‹æœºä¸Šç¡®è®¤ç™»å½•';
                            status.className = 'qrcode-status scanned';
                        } else if (checkJson.code === 803) {
                            status.textContent = 'ç™»å½•æˆåŠŸï¼';
                            status.className = 'qrcode-status success';
                            clearInterval(qrCheckTimer);
                            // ä¿å­˜cookie
                            neteaseCookie = checkJson.cookie || '';
                            localStorage.setItem('netease_cookie', neteaseCookie);
                            // è·å–ç”¨æˆ·ä¿¡æ¯
                            await checkLoginStatus();
                            // åˆ‡æ¢åˆ°æœç´¢Tab
                            setTimeout(() => {
                                document.querySelectorAll('.netease-tab')[0].click();
                            }, 1000);
                        }
                    } catch (e) {}
                }, 2000);
            } catch (e) {
                imgWrap.innerHTML = '<div class="netease-empty">ç”Ÿæˆå¤±è´¥: ' + e.message + '</div>';
                log('QR generate error: ' + e.message, 'error');
            }
        }
        
        // åˆ·æ–°äºŒç»´ç 
        window.refreshQRCode = generateQRCode;
        
        // é€€å‡ºç™»å½•
        window.neteaseLogout = function() {
            neteaseCookie = '';
            neteaseUser = null;
            myPlaylistsCache = null; // æ¸…é™¤æ­Œå•ç¼“å­˜
            localStorage.removeItem('netease_cookie');
            updateUserUI();
            document.getElementById('mylist-content').innerHTML = '<div class="netease-empty">è¯·å…ˆç™»å½•ç½‘æ˜“äº‘è´¦å·</div>';
            log('Logged out');
        };
        
        // åŠ è½½æˆ‘çš„æ­Œå•
        async function loadMyPlaylists() {
            const container = document.getElementById('mylist-content');
            
            if (!neteaseUser) {
                container.innerHTML = '<div class="netease-empty">è¯·å…ˆç™»å½•ç½‘æ˜“äº‘è´¦å·</div>';
                return;
            }
            
            // å¦‚æœæœ‰ç¼“å­˜ç›´æ¥ä½¿ç”¨
            if (myPlaylistsCache) {
                container.innerHTML = myPlaylistsCache;
                return;
            }
            
            container.innerHTML = '<div class="netease-loading">åŠ è½½ä¸­...</div>';
            
            try {
                const resp = await fetch(buildApiUrl(`/user/playlist?uid=${neteaseUser.userId}&cookie=${encodeURIComponent(neteaseCookie)}`));
                if (!resp.ok) throw new Error('è·å–æ­Œå•å¤±è´¥');
                
                const json = await resp.json();
                const playlists = json.playlist;
                
                if (!playlists || playlists.length === 0) {
                    container.innerHTML = '<div class="netease-empty">æš‚æ— æ­Œå•</div>';
                    return;
                }
                
                // åˆ†ç±»ï¼šæˆ‘åˆ›å»ºçš„ & æˆ‘æ”¶è—çš„
                const created = playlists.filter(p => p.creator?.userId === neteaseUser.userId);
                const collected = playlists.filter(p => p.creator?.userId !== neteaseUser.userId);
                
                let html = '';
                
                if (created.length > 0) {
                    html += '<div class="my-playlists-title">ğŸ“ æˆ‘åˆ›å»ºçš„æ­Œå•</div>';
                    created.forEach(p => {
                        html += `
                            <div class="netease-item" onclick="loadPlaylistById(${p.id})">
                                <img class="netease-item-cover" src="${p.coverImgUrl}?param=100y100">
                                <div class="netease-item-info">
                                    <div class="netease-item-name">${p.name}</div>
                                    <div class="netease-item-artist">${p.trackCount} é¦–</div>
                                </div>
                            </div>
                        `;
                    });
                }
                
                if (collected.length > 0) {
                    html += '<div class="my-playlists-title" style="margin-top:15px">â¤ï¸ æˆ‘æ”¶è—çš„æ­Œå•</div>';
                    collected.forEach(p => {
                        html += `
                            <div class="netease-item" onclick="loadPlaylistById(${p.id})">
                                <img class="netease-item-cover" src="${p.coverImgUrl}?param=100y100">
                                <div class="netease-item-info">
                                    <div class="netease-item-name">${p.name}</div>
                                    <div class="netease-item-artist">${p.trackCount} é¦– Â· ${p.creator?.nickname || ''}</div>
                                </div>
                            </div>
                        `;
                    });
                }
                
                myPlaylistsCache = html; // ä¿å­˜ç¼“å­˜
                container.innerHTML = html;
                
            } catch (e) {
                container.innerHTML = '<div class="netease-empty">åŠ è½½å¤±è´¥: ' + e.message + '</div>';
            }
        }
        
        // ç‚¹å‡»æ­Œå•åŠ è½½
        window.loadPlaylistById = async function(id) {
            // åˆ‡æ¢åˆ°æ­Œå•Tab
            document.querySelectorAll('.netease-tab')[1].click();
            document.getElementById('netease-playlist-input').value = id;
            await fetchPlaylist(id);
        };
        
        // åˆå§‹åŒ–æ—¶æ£€æŸ¥ç™»å½•çŠ¶æ€
        checkLoginStatus();
        
        // å½“å‰åŠ è½½çš„æ­Œå•æ•°æ®
        let currentPlaylistData = null;
        
        // æœç´¢æ­Œæ›²
        async function searchNeteaseSongs(keyword) {
            if (!keyword.trim()) return;
            searchResults.innerHTML = '<div class="netease-loading">ğŸ” æœç´¢ä¸­...</div>';
            searchBtn.disabled = true;
            
            try {
                const resp = await fetch(buildApiUrl(`/search?keywords=${encodeURIComponent(keyword)}&limit=30`));
                if (!resp.ok) throw new Error('æœç´¢å¤±è´¥');
                
                const json = await resp.json();
                if (json.code !== 200 || !json.result?.songs?.length) {
                    searchResults.innerHTML = '<div class="netease-empty">æœªæ‰¾åˆ°ç›¸å…³æ­Œæ›²</div>';
                    return;
                }
                
                renderSongList(json.result.songs, searchResults, 0);
            } catch (e) {
                searchResults.innerHTML = '<div class="netease-empty">æœç´¢å¤±è´¥: ' + e.message + '</div>';
            } finally {
                searchBtn.disabled = false;
            }
        }
        
        // æ¸²æŸ“æ­Œæ›²åˆ—è¡¨ï¼ˆæ”¯æŒåˆ†é¡µï¼‰
        function renderSongList(songs, container, page = 0) {
            // ä¿æŒç”¨æˆ·å½“å‰é¡µ
            if (typeof renderSongList._page !== 'undefined' && typeof page === 'undefined') {
                page = renderSongList._page;
            }
            renderSongList._page = page;
            currentPlaylistSongs = songs;
            currentPage = page;
            const start = page * SONGS_PER_PAGE;
            const end = Math.min(start + SONGS_PER_PAGE, songs.length);
            const pageSongs = songs.slice(start, end);
            container.innerHTML = '';
            // ä½¿ç”¨ DocumentFragment æ‰¹é‡æ·»åŠ å…ƒç´ ï¼Œæé«˜æ€§èƒ½
            const fragment = document.createDocumentFragment();
            pageSongs.forEach(song => {
                const artists = (song.artists || song.ar || []).map(a => a.name).join(', ');
                const album = song.album?.name || song.al?.name || '';
                const duration = song.duration || song.dt || 0;
                const cover = song.album?.picUrl || song.al?.picUrl || '';
                const item = document.createElement('div');
                item.className = 'netease-item';
                item.innerHTML = `
                    <img class="netease-item-cover" data-src="${cover ? cover + '?param=100y100' : ''}" onerror="this.style.display='none'" loading="lazy">
                    <div class="netease-item-info">
                        <div class="netease-item-name">${song.name}</div>
                        <div class="netease-item-artist">${artists}${album ? ' Â· ' + album : ''}</div>
                    </div>
                    <span class="netease-item-duration">${fmtTime(duration / 1000)}</span>
                    <button class="netease-item-play">â–¶</button>
                `;
                item.querySelector('.netease-item-play').onclick = (e) => {
                    e.stopPropagation();
                    playNeteaseSong(song);
                };
                item.onclick = () => playNeteaseSong(song);
                fragment.appendChild(item);
            });
            container.appendChild(fragment);
            // æ·»åŠ åˆ†é¡µæ§ä»¶
            if (songs.length > SONGS_PER_PAGE) {
                const paginationDiv = document.createElement('div');
                paginationDiv.className = 'netease-pagination';
                paginationDiv.style.cssText = 'display: flex; justify-content: center; gap: 10px; margin-top: 15px; padding: 10px;';
                const totalPages = Math.ceil(songs.length / SONGS_PER_PAGE);
                // ä¸Šä¸€é¡µæŒ‰é’®
                if (page > 0) {
                    const prevBtn = document.createElement('button');
                    prevBtn.textContent = 'â—€ ä¸Šä¸€é¡µ';
                    prevBtn.style.cssText = 'padding: 8px 15px; border: 1px solid #ddd; border-radius: 5px; background: white; cursor: pointer;';
                    prevBtn.onclick = () => renderSongList(songs, container, page - 1);
                    paginationDiv.appendChild(prevBtn);
                }
                // é¡µç ä¿¡æ¯
                const pageInfo = document.createElement('span');
                pageInfo.textContent = `ç¬¬ ${page + 1} / ${totalPages} é¡µ (${songs.length} é¦–æ­Œæ›²)`;
                pageInfo.style.cssText = 'padding: 8px 15px; color: #666;';
                paginationDiv.appendChild(pageInfo);
                // ä¸‹ä¸€é¡µæŒ‰é’®
                if (end < songs.length) {
                    const nextBtn = document.createElement('button');
                    nextBtn.textContent = 'ä¸‹ä¸€é¡µ â–¶';
                    nextBtn.style.cssText = 'padding: 8px 15px; border: 1px solid #ddd; border-radius: 5px; background: white; cursor: pointer;';
                    nextBtn.onclick = () => renderSongList(songs, container, page + 1);
                    paginationDiv.appendChild(nextBtn);
                }
                container.appendChild(paginationDiv);
            }
            // é‡æ–°åˆå§‹åŒ–æ‡’åŠ è½½
            lazyLoadImages();
        }
        
        // æ’­æ”¾ç½‘æ˜“äº‘æ­Œæ›²
        async function playNeteaseSong(song) {
            // play token é˜²æ­¢æ—§çš„æ’­æ”¾è¯·æ±‚å®Œæˆåè¦†ç›–æ–°çš„æ’­æ”¾
            if (!window._playActionTokenSeed) window._playActionTokenSeed = 1;
            const myPlayToken = ++window._playActionTokenSeed;
            window._currentPlayActionToken = myPlayToken;

            const songId = song.id;
            let songName = song.name;
            let artists = (song.artists || song.ar || []).map(a => a.name).join(', ');
            let cover = song.album?.picUrl || song.al?.picUrl || '';
            
            log(`Playing: ${songName} - ${artists}`);
            neteasePanel.classList.remove('show');
            
            // å¦‚æœæ²¡æœ‰å°é¢ï¼Œå…ˆè·å–æ­Œæ›²è¯¦æƒ…
            if (!cover) {
                try {
                    const detailResp = await fetch(buildApiUrl(`/song/detail?ids=${songId}`));
                    if (detailResp.ok) {
                        const detailJson = await detailResp.json();
                        if (detailJson.songs?.[0]) {
                            const detail = detailJson.songs[0];
                            cover = detail.al?.picUrl || '';
                            artists = (detail.ar || []).map(a => a.name).join(', ');
                        }
                    }
                } catch (e) {}
            }
            
            // æ›´æ–°UI
            el.title.textContent = songName;
            el.artist.textContent = artists;
            if (cover) {
                el.img.src = cover;
                el.img.onload = () => { el.img.style.opacity = 1; updateTheme(el.img); };
            } else {
                el.img.style.opacity = 0;
                updateTheme(null);
            }
            
            el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">ğŸ”„ è·å–éŸ³é¢‘...</div>';
            // ç«‹å³ä¸­æ–­ä¸Šä¸€ä¸ªæ’­æ”¾æ“ä½œå¹¶åœæ­¢å£°éŸ³
            stopAudio();
            resetLoopUI();
            lyrics = [];
            
            // åˆ›å»ºæ–°çš„ AbortControllerï¼ˆä¸play tokené…åˆï¼‰
            if (window.currentAbortController) window.currentAbortController.abort();
            window.currentAbortController = new AbortController();
            const signal = window.currentAbortController.signal;
            
            try {
                // è·å–éŸ³é¢‘URL - ä½¿ç”¨æ–°ç‰ˆAPIæŒ‡å®šéŸ³è´¨
                const cookieParam = neteaseCookie ? `&cookie=${encodeURIComponent(neteaseCookie)}` : '';
                const levelParam = `&level=${neteaseQuality}`;
                // åœ¨å‘èµ·è¯·æ±‚å‰æ£€æŸ¥token
                if (window._currentPlayActionToken !== myPlayToken) throw new Error('stale');
                const resp = await fetch(buildApiUrl(`/song/url/v1?id=${songId}${levelParam}${cookieParam}`), { signal });
                if (window._currentPlayActionToken !== myPlayToken) { signal.abort(); throw new Error('stale'); }
                
                if (!resp.ok) throw new Error('è·å–éŸ³é¢‘å¤±è´¥');
                
                const json = await resp.json();
                if (json.code !== 200 || !json.data?.[0]?.url) {
                    throw new Error('æ— æ³•è·å–éŸ³é¢‘é“¾æ¥' + (neteaseCookie ? '' : 'ï¼Œç™»å½•åå¯æ’­æ”¾æ›´å¤šæ­Œæ›²'));
                }
                
                let audioUrl = json.data[0].url;
                const audioInfo = json.data[0];
                // è·å–éŸ³è´¨ä¿¡æ¯ - APIå¯èƒ½è¿”å›: br(æ¯”ç‰¹ç‡), type(æ ¼å¼), level, sr(é‡‡æ ·ç‡)ç­‰
                const brKbps = audioInfo.br ? Math.round(audioInfo.br / 1000) : null;
                const audioType = (audioInfo.type || 'mp3').toUpperCase();
                const sampleRate = audioInfo.sr || null; // é‡‡æ ·ç‡ (å¦‚44100)
                
                // Debugæ˜¾ç¤ºåŸå§‹ä¿¡æ¯
                log(`Audio: ${audioType} ${brKbps || '?'}kbps${sampleRate ? ` ${sampleRate}Hz` : ''}`, 'success');
                
                // æ ¹æ®æ ¼å¼å’Œå¯ç”¨ä¿¡æ¯æ„å»ºéŸ³è´¨æ ‡ç­¾
                let qualityStr = audioType;
                if (audioType === 'FLAC' || audioType === 'WAV' || audioType === 'AIFF') {
                    // æ— æŸæ ¼å¼ - ä¼˜å…ˆæ˜¾ç¤ºé‡‡æ ·ç‡ä¿¡æ¯
                    if (sampleRate) {
                        const srKhz = sampleRate >= 1000 ? (sampleRate / 1000).toFixed(sampleRate % 1000 === 0 ? 0 : 1) + 'kHz' : sampleRate + 'Hz';
                        // FLACé€šå¸¸æ˜¯16bitæˆ–24bitï¼Œæ ¹æ®æ¯”ç‰¹ç‡ä¼°ç®—
                        // 16bit/44.1kHz stereo â‰ˆ 1411kbps, 24bit/96kHz stereo â‰ˆ 4608kbps
                        if (brKbps) {
                            const estBitDepth = brKbps > 2000 ? 24 : 16;
                            qualityStr = `${audioType} ${estBitDepth}bit/${srKhz}`;
                        } else {
                            qualityStr = `${audioType} ${srKhz}`;
                        }
                    } else if (brKbps) {
                        // æ²¡æœ‰é‡‡æ ·ç‡ä½†æœ‰æ¯”ç‰¹ç‡ï¼Œæ ¹æ®æ¯”ç‰¹ç‡ä¼°ç®—
                        const estBitDepth = brKbps > 2000 ? 24 : 16;
                        const estSr = brKbps > 2000 ? '96kHz' : '44.1kHz';
                        qualityStr = `${audioType} ${estBitDepth}bit/${estSr}`;
                    }
                } else {
                    // æœ‰æŸæ ¼å¼ - æ˜¾ç¤ºæ¯”ç‰¹ç‡
                    if (brKbps) {
                        qualityStr = `${audioType} ${brKbps}kbps`;
                    }
                }
                
                currentAudioQuality = qualityStr;
                
                // ç¡®ä¿ä½¿ç”¨ https
                audioUrl = audioUrl.replace('http://', 'https://');
                log(`Audio URL: ${audioUrl}`);
                
                el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">â³ åŠ è½½éŸ³é¢‘...</div>';
                el.loadTip.style.display = 'block';
                el.bufferLine.style.width = '30%';
                
                // è·å–éŸ³é¢‘æ•°æ®
                // äºŒæ¬¡æ£€æŸ¥ï¼šç¡®ä¿ä»æ˜¯å½“å‰æ’­æ”¾è¯·æ±‚
                if (window._currentPlayActionToken !== myPlayToken) { signal.abort(); throw new Error('stale'); }
                const audioResp = await fetch(audioUrl, { signal });
                if (window._currentPlayActionToken !== myPlayToken) { signal.abort(); throw new Error('stale'); }
                if (!audioResp.ok) throw new Error('éŸ³é¢‘åŠ è½½å¤±è´¥');
                
                el.bufferLine.style.width = '60%';
                const ab = await audioResp.arrayBuffer();
                if (window._currentPlayActionToken !== myPlayToken) { signal.abort(); throw new Error('stale'); }
                
                el.bufferLine.style.width = '80%';
                audioBuffer = await actx.decodeAudioData(ab);
                if (window._currentPlayActionToken !== myPlayToken) { signal.abort(); throw new Error('stale'); }
                
                el.bufferLine.style.width = '100%';
                playbackState.duration = audioBuffer.duration;
                el.totalTime.textContent = fmtTime(playbackState.duration);
                el.loadTip.style.display = 'none';
                
                // æ›´æ–°å½“å‰æ’­æ”¾é¡¹çš„ songDataï¼ˆä¸è¦†ç›–æ•´ä¸ªæ’­æ”¾åˆ—è¡¨ï¼‰
                if (playlist[curIdx]) {
                    playlist[curIdx].songData = song;
                }
                renderPlaylist();
                
                startAudio(0);
                el.coverWrap.classList.add('playing');
                updatePlayIcon();
                updateMediaSession();
                
                // ç›´æ¥ç”¨æ­Œæ›²IDè·å–æ­Œè¯ï¼ˆå·²çŸ¥IDæ— éœ€æœç´¢ï¼‰ï¼Œä¼ å…¥å½“å‰æ’­æ”¾çš„abort signal
                try { fetchLyricById(songId, window.currentAbortController); } catch(_) {}
                
            } catch (e) {
                if (e.message === 'stale' || e.name === 'AbortError') {
                    // è¿‡æœŸæˆ–è¢«å–æ¶ˆï¼Œä¸è®°å½•ä¸ºé”™è¯¯
                    log('Play request aborted/stale');
                    return;
                }
                log('Play error: ' + e.message, 'error');
                el.lyricBox.innerHTML = `<div class="lyric-line active" style="margin-top:100px">âŒ ${e.message}</div>`;
                el.loadTip.style.display = 'none';
            } finally {
                if (window.currentAbortController && window.currentAbortController.signal.aborted) window.currentAbortController = null;
            }
        }
        
        // å–æ¶ˆæ­Œå•è¯·æ±‚
        window.cancelPlaylistRequest = function() {
            if (window.currentPlaylistAbortController) {
                window.currentPlaylistAbortController.abort();
                window.currentPlaylistAbortController = null;
            }
        };
        
        // è·å–æ­Œå•
        async function fetchPlaylist(input) {
                                    // åˆ†æ­¥åŠ è½½å”¯ä¸€tokenï¼Œåˆ‡æ­Œå•æ—¶åªå…è®¸å½“å‰tokençš„loadBatchæ¸²æŸ“
                                    if (!window._playlistLoadTokenSeed) window._playlistLoadTokenSeed = 1;
                                    const myLoadToken = ++window._playlistLoadTokenSeed;
                                    window._currentPlaylistLoadToken = myLoadToken;
                        // åˆ‡æ¢æ­Œå•æ—¶ï¼Œå…ˆä¸­æ–­ä¸Šä¸€ä¸ªåŠ è½½
                        if (window.currentPlaylistAbortController) {
                            window.currentPlaylistAbortController.abort();
                            window.currentPlaylistAbortController = null;
                        }
            // è§£ææ­Œå•ID
            let playlistId = input.trim();
            
            // ä»é“¾æ¥ä¸­æå–ID
            const match = input.match(/playlist[?/].*?id[=/]?(\d+)/i) || input.match(/(\d{5,})/);
            if (match) playlistId = match[1];
            
            if (!playlistId || !/^\d+$/.test(playlistId)) {
                playlistResults.innerHTML = '<div class="netease-empty">æ— æ•ˆçš„æ­Œå•é“¾æ¥æˆ–ID</div>';
                return;
            }
            
            playlistResults.innerHTML = '<div class="netease-loading">ğŸ”„ è·å–æ­Œå•ä¿¡æ¯... <button onclick="cancelPlaylistRequest()" style="margin-left:10px; padding:2px 8px; font-size:12px;">å–æ¶ˆ</button></div>';
            playlistPreview.innerHTML = '';
            playlistBtn.disabled = true;
            currentPlaylistData = null;
            
            // åˆ›å»º AbortController ç”¨äºå–æ¶ˆè¯·æ±‚
            const abortController = new AbortController();
            window.currentPlaylistAbortController = abortController; // å…¨å±€ä¿å­˜ç”¨äºå–æ¶ˆ
            
            const timeoutId = setTimeout(() => {
                abortController.abort();
                playlistResults.innerHTML = '<div class="netease-empty">è¯·æ±‚è¶…æ—¶ï¼Œè¯·é‡è¯•</div>';
                playlistBtn.disabled = false;
            }, 15000); // 15ç§’è¶…æ—¶
            
            try {
                const cookieParam = neteaseCookie ? `&cookie=${encodeURIComponent(neteaseCookie)}` : '';
                playlistResults.innerHTML = '<div class="netease-loading">ğŸ”„ è¿æ¥ç½‘æ˜“äº‘éŸ³ä¹...</div>';
                // 1. è·å–æ­Œå•åŸºæœ¬ä¿¡æ¯ï¼ˆä¸å¸¦tracksï¼‰
                const resp = await fetch(buildApiUrl(`/playlist/detail?id=${playlistId}&s=0${cookieParam}`), {
                    signal: abortController.signal,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                    }
                });
                clearTimeout(timeoutId);
                if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
                const json = await resp.json();
                if (json.code !== 200 || !json.playlist) {
                    throw new Error('æ— æ³•è·å–æ­Œå•ä¿¡æ¯ï¼Œå¯èƒ½éœ€è¦ç™»å½•æˆ–æ­Œå•ä¸å­˜åœ¨');
                }
                const data = json.playlist;
                currentPlaylistData = data;
                // æ˜¾ç¤ºæ­Œå•åŸºæœ¬ä¿¡æ¯ï¼ˆæ— tracksï¼‰
                const trackCount = data.trackCount || 0;
                playlistPreview.innerHTML = `
                    <div class=\"netease-playlist-info\">
                        <img class=\"netease-playlist-cover\" data-src=\"${data.coverImgUrl}?param=200y200\" loading=\"lazy\">
                        <div class=\"netease-playlist-meta\">
                            <div class=\"netease-playlist-name\">${data.name}</div>
                            <div class=\"netease-playlist-desc\">${trackCount} é¦–æ­Œæ›² Â· ${data.playCount ? Math.floor(data.playCount/10000) + 'ä¸‡æ’­æ”¾' : ''}</div>
                            <button class=\"netease-import-btn\" onclick=\"importPlaylistToQueue()\">ğŸ“¥ å¯¼å…¥åˆ°æ’­æ”¾åˆ—è¡¨</button>
                        </div>
                    </div>
                `;
                playlistResults.innerHTML = `<div class=\"netease-loading\">ğŸ”„ æ­Œå•ä¿¡æ¯åŠ è½½å®Œæˆï¼Œæ­£åœ¨åˆ†æ­¥åŠ è½½æ­Œæ›²... (å…±${trackCount}é¦–)</div>`;
                // 2. åˆ†æ­¥åŠ è½½æ­Œæ›²è¯¦æƒ…
                let allTracks = [];
                const limit = 50;
                let offset = 0;
                let loading = true;
                async function loadBatch() {
                    // åªå…è®¸å½“å‰æ­Œå•çš„åˆ†æ­¥åŠ è½½æ¸²æŸ“
                    if (!loading || abortController.signal.aborted || window._currentPlaylistLoadToken !== myLoadToken) return;
                    const url = buildApiUrl(`/playlist/track/all?id=${playlistId}&limit=${limit}&offset=${offset}${cookieParam}`);
                    const batchResp = await fetch(url, { signal: abortController.signal });
                    if (abortController.signal.aborted) return;
                    if (!batchResp.ok) throw new Error('æ­Œæ›²è¯¦æƒ…åŠ è½½å¤±è´¥');
                    const batchJson = await batchResp.json();
                    if (abortController.signal.aborted) return;
                    if (batchJson.code !== 200 || !batchJson.songs) throw new Error('æ­Œæ›²è¯¦æƒ…è·å–å¤±è´¥');
                    allTracks = allTracks.concat(batchJson.songs);
                    if (abortController.signal.aborted) return;
                    // æ¯åŠ è½½ä¸€æ‰¹éƒ½åˆ·æ–°åˆ†é¡µæ§ä»¶ï¼Œå…è®¸ç”¨æˆ·åˆ‡æ¢å·²åŠ è½½çš„ä»»æ„æ‰¹æ¬¡
                    // åªåœ¨é¦–æ¬¡åŠ è½½æ—¶ç”¨0é¡µï¼Œåç»­ä¿æŒç”¨æˆ·å½“å‰é¡µ
                    let keepPage = typeof renderSongList._page === 'number' ? renderSongList._page : 0;
                    if (window._currentPlaylistLoadToken !== myLoadToken) return;
                    renderSongList(allTracks, playlistResults, keepPage);
                    offset += limit;
                    if (allTracks.length < trackCount && batchJson.songs.length > 0) {
                        if (abortController.signal.aborted) return;
                        // åªæ˜¾ç¤ºè¿›åº¦æç¤ºï¼Œä¸è¦†ç›–å·²åŠ è½½å†…å®¹
                        const progressDiv = document.createElement('div');
                        progressDiv.className = 'netease-loading';
                        progressDiv.textContent = `ğŸ”„ æ­£åœ¨åŠ è½½ç¬¬ ${Math.floor(offset/limit)+1} æ‰¹... (${allTracks.length}/${trackCount})`;
                        // ç§»é™¤æ—§çš„è¿›åº¦æç¤º
                        const old = playlistResults.querySelector('.netease-loading');
                        if (old) old.remove();
                        playlistResults.appendChild(progressDiv);
                        setTimeout(() => {
                            if (window._currentPlaylistLoadToken === myLoadToken) loadBatch();
                        }, 100); // é€’å½’åŠ è½½ä¸‹ä¸€æ‰¹
                    } else {
                        loading = false;
                        if (abortController.signal.aborted) return;
                        // ç§»é™¤è¿›åº¦æç¤º
                        const old = playlistResults.querySelector('.netease-loading');
                        if (old) old.remove();
                        if (window._currentPlaylistLoadToken !== myLoadToken) return;
                        renderSongList(allTracks, playlistResults, 0);
                        // æ›´æ–° currentPlaylistData.tracks ä¾›å¯¼å…¥
                        currentPlaylistData.tracks = allTracks;
                    }
                }
                await loadBatch();
            } catch (e) {
                clearTimeout(timeoutId);
                if (e.name === 'AbortError') {
                    playlistResults.innerHTML = '<div class="netease-empty">è¯·æ±‚å·²å–æ¶ˆæˆ–è¶…æ—¶</div>';
                } else {
                    playlistResults.innerHTML = '<div class="netease-empty">è·å–å¤±è´¥: ' + e.message + '</div>';
                }
            } finally {
                playlistBtn.disabled = false;
                window.currentPlaylistAbortController = null;
            }
        }
        
        // å¯¼å…¥æ­Œå•åˆ°æ’­æ”¾é˜Ÿåˆ—
        window.importPlaylistToQueue = async function() {
            if (!currentPlaylistData || !currentPlaylistData.tracks) return;
            
            const tracks = currentPlaylistData.tracks;
            log(`Importing ${tracks.length} songs from playlist`);
            
            // åˆ›å»ºæ’­æ”¾åˆ—è¡¨æ¡ç›®
            playlist = tracks.map(song => {
                const artists = (song.ar || []).map(a => a.name).join(', ');
                return {
                    name: `${song.name} - ${artists}`,
                    netease: true,
                    songId: song.id,
                    songData: song
                };
            });
            
            curIdx = -1;
            renderPlaylist();
            neteasePanel.classList.remove('show');
            document.getElementById('playlist-sidebar').classList.add('show');
            
            log(`Imported ${playlist.length} songs`, 'success');
            
            // è‡ªåŠ¨æ’­æ”¾ç¬¬ä¸€é¦–
            if (playlist.length > 0) {
                playTrackFromPlaylist(0);
            }
        };
        
        // ä»æ’­æ”¾åˆ—è¡¨æ’­æ”¾ï¼ˆæ”¯æŒæœ¬åœ°å’Œç½‘æ˜“äº‘ï¼‰
        async function playTrackFromPlaylist(i) {
            if (i < 0 || i >= playlist.length) return;
            const track = playlist[i];
            curIdx = i;
            renderPlaylist();
            
            if (track.netease) {
                // ç½‘æ˜“äº‘æ­Œæ›²
                if (track.songData) {
                    await playNeteaseSong(track.songData);
                } else {
                    // éœ€è¦é‡æ–°è·å–æ­Œæ›²ä¿¡æ¯
                    el.lyricBox.innerHTML = '<div class="lyric-line active" style="margin-top:100px">ğŸ”„ è·å–æ­Œæ›²ä¿¡æ¯...</div>';
                    try {
                        const resp = await fetch(buildApiUrl(`/song/detail?ids=${track.songId}`));
                        if (resp.ok) {
                            const json = await resp.json();
                            if (json.songs?.[0]) {
                                track.songData = json.songs[0];
                                await playNeteaseSong(track.songData);
                                return;
                            }
                        }
                    } catch (e) {
                        log('Error: ' + e.message, 'error');
                    }
                }
            } else {
                // æœ¬åœ°æ–‡ä»¶
                await playTrack(i);
            }
        }
        
        // ä¿®æ”¹ handleNext ä½¿ç”¨æ–°çš„æ’­æ”¾å‡½æ•°
        const originalHandleNext = handleNext;
        handleNext = function() {
            if (playlist.length === 0) return;
            let nextIdx;
            if (playMode === 1) nextIdx = Math.floor(Math.random() * playlist.length);
            else if (playMode === 2) nextIdx = curIdx;
            else nextIdx = curIdx + 1 >= playlist.length ? 0 : curIdx + 1;
            
            playTrackFromPlaylist(nextIdx);
        };
        
        // ä¿®æ”¹ä¸Šä¸€æ›²/ä¸‹ä¸€æ›²æŒ‰é’®
        document.getElementById('prev-btn').onclick = () => {
            if (playlist.length === 0) return;
            playTrackFromPlaylist(curIdx - 1 < 0 ? playlist.length - 1 : curIdx - 1);
        };
        document.getElementById('next-btn').onclick = handleNext;
        
        // æœç´¢æŒ‰é’®å’Œå›è½¦
        searchBtn.onclick = () => searchNeteaseSongs(searchInput.value);
        searchInput.onkeypress = (e) => { if (e.key === 'Enter') searchNeteaseSongs(searchInput.value); };
        
        // æ­Œå•æŒ‰é’®å’Œå›è½¦
        playlistBtn.onclick = () => fetchPlaylist(playlistInput.value);
        playlistInput.onkeypress = (e) => { if (e.key === 'Enter') fetchPlaylist(playlistInput.value); };
        
        // ç§»åŠ¨ç«¯é«˜çº§èœå•
        const advancedBtn = document.getElementById('toggle-advanced');
        const advancedMenu = document.getElementById('advanced-menu');
        if (advancedBtn && advancedMenu) {
            advancedBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                advancedMenu.classList.toggle('show');
            });
            
            // ç‚¹å‡»èœå•é¡¹
            advancedMenu.querySelectorAll('.advanced-menu-item').forEach(item => {
                item.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const action = this.dataset.action;
                    advancedMenu.classList.remove('show');
                    
                    if (action === 'debug') {
                        const dbg = document.getElementById('debug-console');
                        dbg.style.display = (dbg.style.display === 'none' || dbg.style.display === '') ? 'block' : 'none';
                    } else if (action === 'analyze') {
                        document.getElementById('analyze-panel').classList.toggle('show');
                    } else if (action === 'loop') {
                        document.getElementById('loop-panel').classList.toggle('show');
                    } else if (action === 'netease-lyrics') {
                        // åˆ‡æ¢äº‘è¯å¼€å…³
                        neteaseSearchEnabled = !neteaseSearchEnabled;
                        neteaseBtn.style.background = neteaseSearchEnabled ? '#27ae60' : '';
                        neteaseBtn.style.color = neteaseSearchEnabled ? '#fff' : '';
                        log(`Netease lyrics search: ${neteaseSearchEnabled ? 'ON' : 'OFF'}`);
                        alert(`äº‘è¯æœç´¢å·²${neteaseSearchEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
                    } else if (action === 'effects') {
                        // å¾ªç¯åˆ‡æ¢ç‰¹æ•ˆ
                        const options = ['none', 'snow', 'bars', 'waves'];
                        const names = ['æ— ç‰¹æ•ˆ', 'å‡›å†¬é£é›ª', 'å¾‹åŠ¨é¢‘è°±', 'æå…‰æ³¢æµª'];
                        const current = options.indexOf(el.effectSel.value);
                        const next = (current + 1) % options.length;
                        el.effectSel.value = options[next];
                        alert(`ç‰¹æ•ˆ: ${names[next]}`);
                    }
                });
            });
            
            // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­èœå•
            document.addEventListener('click', function(e) {
                if (!advancedBtn.contains(e.target) && !advancedMenu.contains(e.target)) {
                    advancedMenu.classList.remove('show');
                }
            });
        } else {
            console.log('Advanced menu elements not found:', { advancedBtn, advancedMenu });
        }
        
        updateTheme(null);
        
        // æ‡’åŠ è½½å›¾ç‰‡å®ç°
        const lazyLoadImages = () => {
            const imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        img.src = img.dataset.src;
                        img.classList.remove('lazy');
                        observer.unobserve(img);
                    }
                });
            });
            
            // è§‚å¯Ÿæ‰€æœ‰æ‡’åŠ è½½å›¾ç‰‡
            document.querySelectorAll('img[data-src]').forEach(img => {
                imageObserver.observe(img);
            });
        };
        
        // åˆå§‹åŒ–æ‡’åŠ è½½
        lazyLoadImages();
        
    </script>
</body>
</html>
